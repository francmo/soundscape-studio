<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>🎧 Soundscape Studio - Professional Field Recording & Composition</title>

    <!-- Open Graph meta tags for WhatsApp and Facebook preview -->
    <meta property="og:title" content="🎧 Soundscape Studio - Aggiornamento Importante! 🎵 • 📊 Export professionali (Excel, Word, PDF) • 🗺️ Export GIS (KML, GeoJSON, CSV) • 💾 Backup completo illimitato • 🎵 Export archivio audio ZIP • ⭐ Markers illimitati • 🔗 Accedi: 🇮🇹 https://soundscape-project-studio.netlify.app 🇬🇧 https://soundscape-studio-eng.netlify.app • 💡 Usa dal browser, App iOS/Android in arrivo!">
    <meta property="og:description" content="🙏">
    <meta property="og:url" content="https://soundscape-project-studio.netlify.app">
    <meta property="og:type" content="website">
    <meta property="og:locale" content="it_IT">

    <!-- Twitter Card (bonus, funziona anche su altri social) -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="🎧 Soundscape Studio - Professional Field Recording & Composition">
    <meta name="twitter:description" content="🎵 Aggiornamento Importante! Export professionali, GIS, backup illimitato, markers illimitati. Usa dal browser!">
    <meta name="twitter:image" content="https://soundscape-project-studio.netlify.app/icon-512.png">

    <!-- Leaflet.js for interactive maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Tone.js for high-quality sampled instruments -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <!-- jsPDF for PDF export (Premium feature) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- SheetJS for Excel export (Premium feature) -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js" defer></script>

    <!-- JSZip for creating ZIP archives (Premium feature) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- Lame.js for MP3 encoding (Audio export) -->
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>

    <!-- Docxtemplater for Word export (Premium feature) -->
    <script src="https://unpkg.com/docxtemplater@3.42.3/build/docxtemplater.js"></script>
    <script src="https://unpkg.com/pizzip@3.1.6/dist/pizzip.js"></script>

    <!-- EmailJS for contact form -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>

    <!-- Firebase SDK for PWA (Analytics & Crashlytics) -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics-compat.js"></script>

    <!-- Firebase Integration Script -->
    <script src="firebase-init.js"></script>

    <!-- Google Analytics GA4 for PWA -->
    <script src="google-analytics.js"></script>

    <!-- Capacitor Core (Native App Framework) -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/@capacitor/core@latest/dist/capacitor.js"></script>

    <!-- IAP Integration (RevenueCat) -->
    <script type="module" src="iap-integration.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            overflow-x: hidden;
            width: 100%;
            max-width: 100vw;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #e8f5f1 0%, #d4f1e8 100%);
            min-height: 100vh;
            color: #2c3e50;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #2d5f4f 0%, #3d7f6f 100%);
            color: white;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        /* Navigation */
        .nav {
            display: flex;
            gap: 10px;
            padding: 15px 20px;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow-x: auto;
        }

        .nav-button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: #f8f9f5;
            color: #2d5f4f;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .nav-button:hover {
            background: #2d5f4f;
            color: white;
        }

        .nav-button.active {
            background: #2d5f4f;
            color: white;
        }

        /* Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        /* Sections */
        .section {
            display: none;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
        }

        .section.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Dashboard Cards */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            box-sizing: border-box;
            max-width: 100%;
            overflow-x: hidden;
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(45,95,79,0.2);
        }

        .card h3 {
            color: #2d5f4f;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .card p {
            color: #666;
            font-size: 14px;
            line-height: 1.6;
        }

        .card input, .card select, .card textarea, .card button {
            max-width: 100%;
            box-sizing: border-box;
        }

        .card-icon {
            font-size: 40px;
            margin-bottom: 15px;
        }

        /* Premium Banner */
        .premium-banner {
            background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 20px;
            box-shadow: 0 4px 12px rgba(212,175,55,0.3);
        }

        /* Paywall Modal */
        .paywall-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .paywall-modal.active {
            display: flex;
        }

        .paywall-content {
            background: white;
            padding: 15px;
            border-radius: 16px;
            max-width: 450px;
            max-height: 70vh;
            width: 85%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }

        body.modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .paywall-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 50%;
            font-size: 32px;
            cursor: pointer;
            color: #666;
            line-height: 1;
            padding: 5px;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
            font-weight: bold;
        }

        .paywall-close:hover {
            background: #d4af37;
            color: white;
            border-color: #d4af37;
            transform: scale(1.1);
        }

        .premium-features {
            list-style: none;
            margin: 20px 0;
        }

        .premium-features li {
            padding: 12px 0;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .premium-features li:last-child {
            border-bottom: none;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2d5f4f, #8ba888);
            transition: width 0.3s;
        }

        /* Spectrogram Container */
        .spectrogram-container {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .spectrogram-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .spectrogram-button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .btn-primary {
            background: #f4a261;
            color: white;
        }

        .btn-primary:hover {
            background: #e89b5a;
        }

        .btn-secondary {
            background: #8ba888;
            color: white;
        }

        .btn-secondary:hover {
            background: #7a9777;
        }

        .btn-danger {
            background: #e76f51;
            color: white;
        }

        .btn-danger:hover {
            background: #d66548;
        }

        #spectrogramCanvas {
            width: 100%;
            height: 300px;
            border-radius: 8px;
            background: #000;
        }

        .spectrogram-info {
            display: flex;
            justify-content: space-between;
            color: #8ba888;
            font-size: 12px;
            margin-top: 10px;
            font-family: monospace;
        }

        /* Exercise Grid */
        .exercise-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }

        .exercise-card {
            position: relative;
            background: white;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #2d5f4f;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s;
        }

        .exercise-card:hover {
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(45,95,79,0.2);
        }

        .exercise-category {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .cat-ascolto { background: #ffeaa7; color: #2d3436; }
        .cat-registrazione { background: #74b9ff; color: #2d3436; }
        .cat-editing { background: #a29bfe; color: white; }
        .cat-composizione { background: #fd79a8; color: white; }

        .exercise-title {
            font-size: 18px;
            font-weight: 600;
            color: #2d5f4f;
            margin-bottom: 8px;
        }

        .exercise-meta {
            font-size: 13px;
            color: #666;
        }

        /* Toolkit */
        .toolkit-section {
            margin-bottom: 30px;
        }

        .toolkit-section h3 {
            color: #2d5f4f;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .reference-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .reference-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }

        .reference-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        /* Reference Modal */
        .reference-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 10000;
            overflow-y: auto;
        }

        .reference-modal-content {
            background: white;
            margin: 50px auto;
            padding: 30px;
            max-width: 800px;
            border-radius: 12px;
            position: relative;
        }

        .reference-modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 30px;
            cursor: pointer;
            color: #666;
        }

        .reference-modal-close:hover {
            color: #2d5f4f;
        }

        .frequency-bar {
            display: flex;
            height: 60px;
            margin: 20px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .frequency-section {
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 11px;
            text-align: center;
            padding: 5px;
            position: relative;
        }

        .eq-diagram {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
        }

        /* Equipment Cards */
        .equipment-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .equipment-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-left: 4px solid #2d5f4f;
        }

        .equipment-card h4 {
            color: #2d5f4f;
            margin: 0 0 10px 0;
            font-size: 18px;
        }

        .equipment-card .price {
            color: #8ba888;
            font-weight: bold;
            font-size: 16px;
            margin: 10px 0;
        }

        .equipment-card .category-badge {
            display: inline-block;
            background: #2d5f4f;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            margin-bottom: 10px;
        }

        .equipment-card ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .equipment-card ul li {
            margin: 5px 0;
            font-size: 14px;
            color: #555;
        }

        /* Library Cards */
        .library-item {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-left: 4px solid #2d5f4f;
            margin-bottom: 15px;
            transition: all 0.3s;
        }

        .library-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .library-item h4 {
            color: #2d5f4f;
            margin: 0 0 10px 0;
            font-size: 18px;
        }

        .library-item .author {
            color: #666;
            font-size: 14px;
            margin-bottom: 10px;
            font-style: italic;
        }

        .library-item .description {
            color: #555;
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .library-item .link-btn {
            display: inline-block;
            background: #2d5f4f;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 14px;
            transition: all 0.3s;
        }

        .library-item .link-btn:hover {
            background: #1f4538;
            transform: translateX(3px);
        }

        .library-category {
            display: inline-block;
            background: #e8f5e9;
            color: #2d5f4f;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        /* Audio Upload */
        .upload-area {
            border: 2px dashed #8ba888;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: #2d5f4f;
            background: #f8f9f5;
        }

        .upload-area input {
            display: none;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-box {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 32px;
            font-weight: 700;
            color: #2d5f4f;
        }

        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        /* Filter Buttons */
        .filter-btn {
            padding: 8px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 20px;
            background: white;
            color: #666;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .filter-btn:hover {
            border-color: #2d5f4f;
            background: #f8f9f5;
        }

        .filter-btn.active {
            border-color: #2d5f4f;
            background: #2d5f4f;
            color: white;
        }

        /* Example Image Cards */
        .example-image-card {
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .example-image-card:hover {
            transform: translateY(-4px);
        }

        .example-image-card canvas {
            transition: border-color 0.3s;
        }

        .example-image-card:hover canvas {
            border-color: #2d5f4f !important;
            box-shadow: 0 4px 8px rgba(45,95,79,0.3);
        }

        /* Footer */
        .section-footer {
            margin-top: 40px;
            padding: 30px 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
        }

        .footer-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .footer-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .footer-btn.whatsapp {
            background: #25D366;
            color: white;
        }

        .footer-btn.whatsapp:hover {
            background: #1da851;
        }

        .footer-btn.facebook {
            background: #1877F2;
            color: white;
        }

        .footer-btn.facebook:hover {
            background: #145dbf;
        }

        .footer-btn.paypal {
            background: #FFC439;
            color: #003087;
        }

        .footer-btn.paypal:hover {
            background: #e6b033;
        }

        .footer-btn.feedback {
            background: #2d5f4f;
            color: white;
        }

        .footer-btn.feedback:hover {
            background: #1f4538;
        }

        .footer-credits {
            color: #666;
            font-size: 14px;
            line-height: 1.6;
        }

        .footer-credits strong {
            color: #2d5f4f;
        }

        /* Leaflet Popup Responsive Fix */
        .leaflet-popup-content-wrapper {
            max-width: calc(100vw - 60px) !important;
            box-sizing: border-box !important;
        }

        .leaflet-popup-content {
            max-width: 100% !important;
            box-sizing: border-box !important;
            overflow: hidden !important;
            word-wrap: break-word !important;
        }

        .leaflet-container {
            max-width: 100% !important;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>🎧 Soundscape Studio</h1>
        <p>Professional Field Recording & Composition Toolkit</p>
    </div>

    <!-- Navigation -->
    <div class="nav">
        <button class="nav-button active" onclick="showSection('dashboard')">🏠 Dashboard</button>
        <button class="nav-button" onclick="showSection('exercises')">🔔 Esercizi Soundscape</button>
        <button class="nav-button" onclick="showMapSection()">🗺️ Soundscape Map</button>
        <button class="nav-button" onclick="showSection('spectrogram')">🎵 Spettrogramma</button>
        <button class="nav-button" onclick="showSection('toolkit')">🔧 Toolkit</button>
        <button class="nav-button" onclick="showSection('library')">📚 Biblioteca</button>
        <button class="nav-button" onclick="showSection('export')">📤 Esportazione</button>
        <button class="nav-button" onclick="showSection('about')">ℹ️ About</button>
        <button class="nav-button" onclick="showSection('guide')">📖 Guida</button>
    </div>

    <!-- Container -->
    <div class="container">

        <!-- DASHBOARD SECTION -->
        <div id="dashboard" class="section active">
            <h2 style="margin-bottom: 20px; color: #2d5f4f;">👋 Benvenuto nel tuo Studio</h2>

            <!-- PWA VERSION: No Premium banner - all features are free -->

            <!-- Esercizi Completati -->
            <div class="card" style="margin-bottom: 30px;">
                <h3 style="color: #2d5f4f; margin-bottom: 15px; text-align: center;">📝 I tuoi Esercizi Completati</h3>
                <div id="completedExercisesList" style="max-height: 400px; overflow-y: auto; overflow-x: hidden; width: 100%;">
                    <!-- Verrà popolato dinamicamente -->
                </div>
                <button onclick="showAllCompletedExercises()" style="margin-top: 15px; padding: 10px 20px; background: #2d5f4f; color: white; border: none; border-radius: 8px; cursor: pointer; width: 100%; font-weight: 600;">
                    📋 Vedi Tutti gli Esercizi Completati
                </button>
            </div>

            <!-- Quick Access -->
            <h3 style="margin: 30px 0 15px; color: #2d5f4f;">🚀 Accesso Rapido</h3>
            <div class="dashboard-grid">
                <div class="card" onclick="showSection('exercises')">
                    <div class="card-icon">🎯</div>
                    <h3>Esercizi del Giorno</h3>
                    <p>Esercizi guidati per field recording</p>
                </div>

                <div class="card" onclick="showSection('toolkit')">
                    <div class="card-icon">🔧</div>
                    <h3>Toolkit Professionale</h3>
                    <p>Guide tecniche, reference charts, templates</p>
                </div>

                <div class="card" onclick="showSection('library')">
                    <div class="card-icon">📚</div>
                    <h3>Biblioteca</h3>
                    <p>Storia, teoria, articoli e risorse</p>
                </div>
            </div>

            <!-- Footer -->
            <div class="section-footer">
                <div class="footer-buttons">
                    <a href="#" onclick="shareApp('whatsapp'); return false;" class="footer-btn whatsapp">
                        📱 Condividi su WhatsApp
                    </a>
                    <a href="#" onclick="shareApp('facebook'); return false;" class="footer-btn facebook">
                        📘 Condividi su Facebook
                    </a>
                    <a href="https://www.paypal.com/paypalme/francescomariano" class="footer-btn paypal" target="_blank">
                        💰 Sostieni con Donazione
                    </a>
                    <a href="mailto:soundscapestudiopro@gmail.com?subject=Feedback%20Soundscape%20Studio" class="footer-btn feedback">
                        ✉️ Invia Feedback
                    </a>
                </div>
                <div class="footer-credits">
                    <p><strong>Ideato e sviluppato da Francesco Mariano</strong></p>
                    <p>Gruppo Apuano Sperimentale</p>
                </div>
            </div>
        </div>

        <!-- EXERCISES SECTION -->
        <div id="exercises" class="section">
            <h2 style="margin-bottom: 20px; color: #2d5f4f;">🔔 Esercizi Soundscape</h2>

            <!-- Filters -->
            <div style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <div style="margin-bottom: 15px;">
                    <strong style="color: #2d5f4f;">Filtra per Categoria:</strong>
                    <div style="display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap;">
                        <button class="filter-btn active" onclick="filterExercises('all')" data-filter="all">
                            Tutti
                        </button>
                        <button class="filter-btn" onclick="filterExercises('ascolto-base')" data-filter="ascolto-base">
                            👂 Ascolto Base
                        </button>
                        <button class="filter-btn" onclick="filterExercises('movimento-suono')" data-filter="movimento-suono">
                            🚶 Movimento e Suono
                        </button>
                        <button class="filter-btn" onclick="filterExercises('ascolto-estremo')" data-filter="ascolto-estremo">
                            🔭 Ascolto Estremo
                        </button>
                        <button class="filter-btn" onclick="filterExercises('produzione-imitazione')" data-filter="produzione-imitazione">
                            🎭 Produzione e Imitazione
                        </button>
                        <button class="filter-btn" onclick="filterExercises('giochi-vocali')" data-filter="giochi-vocali">
                            🗣️ Giochi Vocali
                        </button>
                        <button class="filter-btn" onclick="filterExercises('registrazione-analisi')" data-filter="registrazione-analisi">
                            🎚️ Registrazione e Analisi
                        </button>
                        <button class="filter-btn" onclick="filterExercises('silenzio-memoria')" data-filter="silenzio-memoria">
                            🤫 Silenzio e Memoria
                        </button>
                        <button class="filter-btn" onclick="filterExercises('comunita-ambiente')" data-filter="comunita-ambiente">
                            🏛️ Comunità e Ambiente
                        </button>
                        <button class="filter-btn" onclick="filterExercises('parchi-spazi')" data-filter="parchi-spazi">
                            🌳 Parchi e Spazi
                        </button>
                    </div>
                </div>
            </div>

            <div class="exercise-grid" id="exerciseGrid">
                <!-- Esercizi verranno generati via JavaScript -->
            </div>

            <!-- Footer -->
            <div class="section-footer">
                <div class="footer-buttons">
                    <a href="#" onclick="shareApp('whatsapp'); return false;" class="footer-btn whatsapp">
                        📱 Condividi su WhatsApp
                    </a>
                    <a href="#" onclick="shareApp('facebook'); return false;" class="footer-btn facebook">
                        📘 Condividi su Facebook
                    </a>
                    <a href="https://www.paypal.com/paypalme/francescomariano" class="footer-btn paypal" target="_blank">
                        💰 Sostieni con Donazione
                    </a>
                    <a href="mailto:soundscapestudiopro@gmail.com?subject=Feedback%20Soundscape%20Studio" class="footer-btn feedback">
                        ✉️ Invia Feedback
                    </a>
                </div>
                <div class="footer-credits">
                    <p><strong>Ideato e sviluppato da Francesco Mariano</strong></p>
                    <p>Gruppo Apuano Sperimentale</p>
                </div>
            </div>
        </div>

        <!-- TOOLKIT SECTION -->
        <div id="toolkit" class="section">
            <h2 style="margin-bottom: 20px; color: #2d5f4f;">🔧 Toolkit Professionale</h2>

            <!-- Reference Guides - Cliccabili -->
            <div class="toolkit-section">
                <h3>📐 Reference Guides</h3>
                <div class="reference-grid">
                    <div class="reference-item" onclick="showReferenceModal('polar-patterns')" style="cursor: pointer;">
                        <div style="font-size: 30px; margin-bottom: 10px;">🎙️</div>
                        <strong>Polar Patterns</strong>
                        <p style="font-size: 12px; color: #666; margin-top: 5px;">Guida diagrammi polari</p>
                    </div>
                    <div class="reference-item" onclick="showReferenceModal('frequency-chart')" style="cursor: pointer;">
                        <div style="font-size: 30px; margin-bottom: 10px;">📊</div>
                        <strong>Frequency Chart</strong>
                        <p style="font-size: 12px; color: #666; margin-top: 5px;">Range frequenze</p>
                    </div>
                    <div class="reference-item" onclick="showReferenceModal('eq-settings')" style="cursor: pointer;">
                        <div style="font-size: 30px; margin-bottom: 10px;">🎚️</div>
                        <strong>EQ Settings</strong>
                        <p style="font-size: 12px; color: #666; margin-top: 5px;">EQ per ambienti</p>
                    </div>
                    <div class="reference-item" onclick="showReferenceModal('sample-rate')" style="cursor: pointer;">
                        <div style="font-size: 30px; margin-bottom: 10px;">💿</div>
                        <strong>Sample Rate</strong>
                        <p style="font-size: 12px; color: #666; margin-top: 5px;">Guida formati audio</p>
                    </div>
                </div>
            </div>

            <!-- Equipment Tabs -->
            <div class="toolkit-section" style="margin-top: 30px;">
                <h3>🎙️ Equipaggiamento Consigliato</h3>

                <!-- Tab Navigation -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                    <button class="filter-btn active" onclick="showEquipmentTab('recorders')" data-equipment="recorders">
                        🎙️ Field Recorders
                    </button>
                    <button class="filter-btn" onclick="showEquipmentTab('microphones')" data-equipment="microphones">
                        🎤 Microfoni
                    </button>
                    <button class="filter-btn" onclick="showEquipmentTab('windscreens')" data-equipment="windscreens">
                        🌬️ Paraventi
                    </button>
                    <button class="filter-btn" onclick="showEquipmentTab('stands')" data-equipment="stands">
                        🎚️ Supporti
                    </button>
                    <button class="filter-btn" onclick="showEquipmentTab('storage')" data-equipment="storage">
                        💾 Memory Card
                    </button>
                    <button class="filter-btn" onclick="showEquipmentTab('bags')" data-equipment="bags">
                        🎒 Borse
                    </button>
                    <button class="filter-btn" onclick="showEquipmentTab('smartphones')" data-equipment="smartphones">
                        📱 Smartphone
                    </button>
                    <button class="filter-btn" onclick="showEquipmentTab('software')" data-equipment="software">
                        💻 Software
                    </button>
                </div>

                <!-- Tab Content -->
                <div id="equipment-content">
                    <!-- Content will be loaded by JavaScript -->
                </div>
            </div>

            <!-- Footer -->
            <div class="section-footer">
                <div class="footer-buttons">
                    <a href="#" onclick="shareApp('whatsapp'); return false;" class="footer-btn whatsapp">
                        📱 Condividi su WhatsApp
                    </a>
                    <a href="#" onclick="shareApp('facebook'); return false;" class="footer-btn facebook">
                        📘 Condividi su Facebook
                    </a>
                    <a href="https://www.paypal.com/paypalme/francescomariano" class="footer-btn paypal" target="_blank">
                        💰 Sostieni con Donazione
                    </a>
                    <a href="mailto:soundscapestudiopro@gmail.com?subject=Feedback%20Soundscape%20Studio" class="footer-btn feedback">
                        ✉️ Invia Feedback
                    </a>
                </div>
                <div class="footer-credits">
                    <p><strong>Ideato e sviluppato da Francesco Mariano</strong></p>
                    <p>Gruppo Apuano Sperimentale</p>
                </div>
            </div>
        </div>

        <!-- LIBRARY SECTION -->
        <div id="library" class="section">
            <h2 style="margin-bottom: 20px; color: #2d5f4f;">📚 Biblioteca Soundscape</h2>

            <!-- Tab Navigation -->
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <button class="filter-btn active" onclick="showLibraryTab('books')" data-library="books">
                    📕 Libri Essenziali
                </button>
                <button class="filter-btn" onclick="showLibraryTab('videos')" data-library="videos">
                    🎬 Video & Documentari
                </button>
                <button class="filter-btn" onclick="showLibraryTab('audio')" data-library="audio">
                    🎧 Esempi Audio
                </button>
                <button class="filter-btn" onclick="showLibraryTab('papers')" data-library="papers">
                    📄 Paper & Articoli
                </button>
                <button class="filter-btn" onclick="showLibraryTab('resources')" data-library="resources">
                    🔗 Risorse Online
                </button>
            </div>

            <!-- Tab Content -->
            <div id="library-content">
                <!-- Content will be loaded by JavaScript -->
            </div>

            <!-- Footer -->
            <div class="section-footer">
                <div class="footer-buttons">
                    <a href="#" onclick="shareApp('whatsapp'); return false;" class="footer-btn whatsapp">
                        📱 Condividi su WhatsApp
                    </a>
                    <a href="#" onclick="shareApp('facebook'); return false;" class="footer-btn facebook">
                        📘 Condividi su Facebook
                    </a>
                    <a href="https://www.paypal.com/paypalme/francescomariano" class="footer-btn paypal" target="_blank">
                        💰 Sostieni con Donazione
                    </a>
                    <a href="mailto:soundscapestudiopro@gmail.com?subject=Feedback%20Soundscape%20Studio" class="footer-btn feedback">
                        ✉️ Invia Feedback
                    </a>
                </div>
                <div class="footer-credits">
                    <p><strong>Ideato e sviluppato da Francesco Mariano</strong></p>
                    <p>Gruppo Apuano Sperimentale</p>
                </div>
            </div>
        </div>

        <!-- EXPORT SECTION -->
        <div id="export" class="section">
            <h2 style="margin-bottom: 30px; color: #2d5f4f; text-align: center;">📤 Esportazione & Backup</h2>

            <!-- Main Export Card -->
            <div class="card" style="margin-bottom: 30px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border: 2px solid #d4af37;">
                <div style="text-align: center; margin-bottom: 25px;">
                    <h3 style="color: #d4af37; margin-bottom: 15px; font-size: 24px;">💾 Backup & Esportazione Professionale</h3>
                    <p style="color: #666; font-size: 16px; line-height: 1.6;">
                        Proteggi il tuo lavoro e condividi i tuoi risultati in formato professionale.
                    </p>
                </div>

                <!-- Backup Completo -->
                <div style="margin-bottom: 25px;">
                    <h4 style="color: #2d5f4f; font-size: 16px; margin-bottom: 12px; font-weight: 600; border-bottom: 2px solid #d4af37; padding-bottom: 8px;">🔒 Backup & Ripristino Completo</h4>
                    <p style="color: #666; font-size: 14px; margin-bottom: 12px;">
                        Salva TUTTO il tuo archivio Soundscape (esercizi, audio, foto, markers) in un unico file JSON.
                    </p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <button onclick="exportCompleteBackup()" style="padding: 12px 18px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; box-shadow: 0 2px 8px rgba(212,175,55,0.3); transition: all 0.3s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(212,175,55,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(212,175,55,0.3)'">
                            💾 Backup Completo
                        </button>
                        <button onclick="importCompleteBackup()" style="padding: 12px 18px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; box-shadow: 0 2px 8px rgba(212,175,55,0.3); transition: all 0.3s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(212,175,55,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(212,175,55,0.3)'">
                            📥 Ripristina Backup
                        </button>
                    </div>
                </div>

                <!-- Export Esercizi -->
                <div style="margin-bottom: 25px;">
                    <h4 style="color: #2d5f4f; font-size: 16px; margin-bottom: 12px; font-weight: 600; border-bottom: 2px solid #d4af37; padding-bottom: 8px;">📝 Export Database Esercizi</h4>
                    <p style="color: #666; font-size: 14px; margin-bottom: 12px;">
                        Esporta tutti i tuoi esercizi completati in formati universali per analisi e condivisione.
                    </p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <button onclick="exportToExcel()" style="padding: 12px 18px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; box-shadow: 0 2px 8px rgba(212,175,55,0.3); transition: all 0.3s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(212,175,55,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(212,175,55,0.3)'">
                            📊 Excel (.xlsx)
                        </button>
                        <button onclick="exportToWord()" style="padding: 12px 18px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; box-shadow: 0 2px 8px rgba(212,175,55,0.3); transition: all 0.3s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(212,175,55,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(212,175,55,0.3)'">
                            📝 Word Report (.docx)
                        </button>
                    </div>
                </div>

                <!-- Export Avanzati (Collapsabile) -->
                <div style="margin-bottom: 25px; border: 2px solid #e9ecef; border-radius: 8px; overflow: hidden;">
                    <button id="advancedExportToggle" onclick="toggleAdvancedExport()" style="width: 100%; padding: 15px; background: #f8f9fa; border: none; cursor: pointer; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s;">
                        <span style="color: #2d5f4f; font-size: 16px; font-weight: 600;">
                            🔧 Export Avanzati (GIS / Ricerca)
                        </span>
                        <span id="advancedExportArrow" style="color: #2d5f4f; font-size: 20px; transition: transform 0.3s;">▼</span>
                    </button>

                    <div id="advancedExportContent" style="display: none; padding: 20px; background: white;">
                        <p style="color: #666; font-size: 14px; margin-bottom: 15px; line-height: 1.6;">
                            <strong>⚠️ Nota:</strong> Questi formati sono pensati per utenti avanzati che lavorano con software GIS, ricerca scientifica o analisi geospaziali.
                            Se vuoi solo salvare i tuoi dati, usa <strong>Backup Completo</strong> (contiene già tutti i marker).
                        </p>

                        <!-- KML Export con guida -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h5 style="color: #2d5f4f; margin: 0 0 10px 0; font-size: 15px;">🗺️ KML (Keyhole Markup Language)</h5>
                            <p style="font-size: 13px; color: #666; margin-bottom: 10px; line-height: 1.5;">
                                <strong>Cos'è:</strong> Formato per visualizzare punti geografici su mappe 3D<br>
                                <strong>Si apre con:</strong> Google Earth, Google Maps<br>
                                <strong>Uso tipico:</strong> Visualizzazione geografica, mappe interattive, documentazione visuale<br>
                                <strong>Per chi:</strong> Sound artists, documentaristi, ricercatori sul campo
                            </p>
                            <button onclick="exportToKML()" style="padding: 10px 16px; background: linear-gradient(135deg, #4285f4 0%, #34a853 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 13px;">
                                📥 Esporta KML
                            </button>
                        </div>

                        <!-- GeoJSON Export con guida -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h5 style="color: #2d5f4f; margin: 0 0 10px 0; font-size: 15px;">📄 GeoJSON (Geographic JSON)</h5>
                            <p style="font-size: 13px; color: #666; margin-bottom: 10px; line-height: 1.5;">
                                <strong>Cos'è:</strong> Standard JSON per dati geografici, leggibile da software GIS<br>
                                <strong>Si apre con:</strong> QGIS, ArcGIS, Mapbox Studio, software GIS professionali<br>
                                <strong>Uso tipico:</strong> Analisi spaziale, ricerca accademica, mappe web interattive<br>
                                <strong>Per chi:</strong> Ricercatori, urbanisti, data scientists, sviluppatori
                            </p>
                            <button onclick="exportMapGeoJSON()" style="padding: 10px 16px; background: linear-gradient(135deg, #4285f4 0%, #34a853 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 13px;">
                                📥 Esporta GeoJSON
                            </button>
                        </div>

                        <!-- CSV Mappa con guida -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #2d5f4f; margin: 0 0 10px 0; font-size: 15px;">📊 CSV Mappa (Spreadsheet)</h5>
                            <p style="font-size: 13px; color: #666; margin-bottom: 10px; line-height: 1.5;">
                                <strong>Cos'è:</strong> Tabella con coordinate geografiche e metadati<br>
                                <strong>Si apre con:</strong> Excel, Google Sheets, qualsiasi foglio di calcolo<br>
                                <strong>Uso tipico:</strong> Analisi dati tabulari, grafici, statistiche geografiche<br>
                                <strong>Per chi:</strong> Chiunque voglia analizzare i marker in forma tabellare
                            </p>
                            <button onclick="exportMapCSV()" style="padding: 10px 16px; background: linear-gradient(135deg, #4285f4 0%, #34a853 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 13px;">
                                📥 Esporta CSV Mappa
                            </button>
                        </div>

                        <div style="margin-top: 15px; padding: 12px; background: #fff3cd; border-radius: 6px; border-left: 4px solid #ffc107;">
                            <p style="font-size: 13px; color: #856404; margin: 0; line-height: 1.5;">
                                💡 <strong>Suggerimento:</strong> Se non sai quale formato scegliere, probabilmente non ti servono questi export.
                                Il <strong>Backup Completo (JSON)</strong> contiene già tutti i dati dei marker e può essere reimportato nell'app.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Export Audio -->
                <div>
                    <h4 style="color: #2d5f4f; font-size: 16px; margin-bottom: 12px; font-weight: 600; border-bottom: 2px solid #d4af37; padding-bottom: 8px;">🎵 Export Archivio Audio</h4>
                    <p style="color: #666; font-size: 14px; margin-bottom: 12px;">
                        Scarica tutti i tuoi file audio organizzati in un archivio ZIP con metadata completi.
                    </p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <button onclick="exportAudioZIP()" style="padding: 12px 18px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; box-shadow: 0 2px 8px rgba(212,175,55,0.3); transition: all 0.3s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(212,175,55,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(212,175,55,0.3)'">
                            🎵 Tutti gli Audio (ZIP)
                        </button>
                    </div>
                </div>

                <div style="margin-top: 25px; padding-top: 20px; border-top: 2px solid #e9ecef; text-align: center;">
                    <p style="font-size: 13px; color: #999;">
                        Proteggi e condividi il tuo archivio professionale di field recording
                    </p>
                </div>
            </div>

            <!-- Info Card -->
            <div class="card" style="background: linear-gradient(135deg, #f0f7f4 0%, #e8f5f1 100%); border-left: 5px solid #2d5f4f;">
                <h3 style="color: #2d5f4f; margin-bottom: 15px;">💡 Informazioni sui Formati</h3>

                <div style="margin-bottom: 15px;">
                    <p style="margin-bottom: 8px;"><strong style="color: #2d5f4f;">📊 Excel (.xlsx)</strong></p>
                    <p style="font-size: 14px; color: #666; line-height: 1.6;">
                        Tabella universale con data, titolo, categoria, difficoltà, luogo, coordinate, note e contatori audio/foto.
                        Apri con Excel, Numbers, Google Sheets o qualsiasi software di analisi dati.
                    </p>
                </div>

                <div style="margin-bottom: 15px;">
                    <p style="margin-bottom: 8px;"><strong style="color: #2d5f4f;">📝 Word (.docx)</strong></p>
                    <p style="font-size: 14px; color: #666; line-height: 1.6;">
                        Report formattato pronto per stampa con tutti i dettagli degli esercizi.
                        Perfetto per documentazione, portfolio o presentazioni. Compatibile con Word, Pages, Google Docs.
                    </p>
                </div>

                <div style="margin-bottom: 15px;">
                    <p style="margin-bottom: 8px;"><strong style="color: #2d5f4f;">🗺️ KML (Google Earth)</strong></p>
                    <p style="font-size: 14px; color: #666; line-height: 1.6;">
                        Formato geografico standard per Google Earth e Google Maps.
                        Visualizza i tuoi markers in 3D con icone colorate per categoria.
                    </p>
                </div>

                <div style="margin-bottom: 15px;">
                    <p style="margin-bottom: 8px;"><strong style="color: #2d5f4f;">📄 GeoJSON</strong></p>
                    <p style="font-size: 14px; color: #666; line-height: 1.6;">
                        Standard per applicazioni GIS professionali (QGIS, ArcGIS, Mapbox).
                        Include metadata completi per analisi geografiche avanzate.
                    </p>
                </div>

                <div style="margin-bottom: 15px;">
                    <p style="margin-bottom: 8px;"><strong style="color: #2d5f4f;">📊 CSV</strong></p>
                    <p style="font-size: 14px; color: #666; line-height: 1.6;">
                        Foglio di calcolo semplice per import rapido in Excel, database o script Python/R.
                    </p>
                </div>

                <div>
                    <p style="margin-bottom: 8px;"><strong style="color: #2d5f4f;">🎵 ZIP Audio</strong></p>
                    <p style="font-size: 14px; color: #666; line-height: 1.6;">
                        Archivio organizzato con cartelle per ogni esercizio, file audio originali e file di testo con metadata.
                        Backup completo del tuo archivio sonoro.
                    </p>
                </div>
            </div>

            <!-- Share & Support Section -->
            <div class="card" style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-top: 3px solid #2d5f4f; margin-top: 30px;">
                <h3 style="color: #2d5f4f; margin-bottom: 20px; text-align: center;">💚 Condividi e Supporta</h3>

                <p style="text-align: center; color: #666; font-size: 15px; margin-bottom: 20px; line-height: 1.6;">
                    Aiutami a far crescere questo progetto! Condividi l'app con amici e colleghi:
                </p>

                <!-- Share Buttons -->
                <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 25px; flex-wrap: wrap;">
                    <button onclick="shareApp('whatsapp')" style="padding: 12px 24px; background: linear-gradient(135deg, #25D366 0%, #128C7E 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; box-shadow: 0 2px 8px rgba(37,211,102,0.3); transition: all 0.3s; display: flex; align-items: center; gap: 8px;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(37,211,102,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(37,211,102,0.3)'">
                        <span style="font-size: 18px;">📱</span> Condividi su WhatsApp
                    </button>
                    <button onclick="shareApp('facebook')" style="padding: 12px 24px; background: linear-gradient(135deg, #1877F2 0%, #0C5FCD 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; box-shadow: 0 2px 8px rgba(24,119,242,0.3); transition: all 0.3s; display: flex; align-items: center; gap: 8px;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(24,119,242,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(24,119,242,0.3)'">
                        <span style="font-size: 18px;">👥</span> Condividi su Facebook
                    </button>
                </div>

                <!-- Donation Button -->
                <div style="border-top: 1px solid #dee2e6; padding-top: 20px; text-align: center;">
                    <p style="color: #666; font-size: 15px; margin-bottom: 15px; line-height: 1.6;">
                        Se trovi utile questo progetto, supportalo con una donazione:
                    </p>
                    <a href="https://www.paypal.com/donate/?hosted_button_id=YOUR_BUTTON_ID" target="_blank" rel="noopener noreferrer" style="display: inline-block; padding: 12px 28px; background: linear-gradient(135deg, #0070BA 0%, #1F8FCC 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; text-decoration: none; box-shadow: 0 2px 8px rgba(0,112,186,0.3); transition: all 0.3s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,112,186,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,112,186,0.3)'">
                        💰 Dona con PayPal
                    </a>
                </div>
            </div>
        </div>

        <!-- ABOUT SECTION -->
        <div id="about" class="section">
            <h2 style="margin-bottom: 30px; color: #2d5f4f; text-align: center;">ℹ️ About Soundscape Studio</h2>

            <!-- Introduzione al Progetto -->
            <div class="card" style="margin-bottom: 30px; background: linear-gradient(135deg, #f0f7f4 0%, #e8f5f1 100%); border-left: 5px solid #2d5f4f;">
                <h3 style="color: #2d5f4f; margin-bottom: 20px; font-size: 22px;">🎯 Il Progetto</h3>

                <p style="font-size: 16px; line-height: 1.8; color: #2c3e50; margin-bottom: 20px;">
                    <strong>Soundscape Studio</strong> fa parte di un più ampio progetto di <strong>ricerca e sviluppo di applicazioni didattiche per artisti e musicisti</strong>,
                    ideato da <strong>Francesco Mariano</strong> del <strong>Gruppo Apuano Sperimentale</strong>.
                </p>

                <p style="font-size: 16px; line-height: 1.8; color: #2c3e50; margin-bottom: 20px;">
                    Questo progetto nasce dall'esigenza di fornire strumenti professionali e accessibili per supportare la crescita artistica e tecnica
                    di musicisti, sound designer, compositori e sound artist. L'obiettivo è democratizzare l'accesso a competenze avanzate attraverso
                    piattaforme digitali interattive che combinano teoria, pratica ed esperienza sul campo.
                </p>

                <!-- Presentazione Francesco Mariano -->
                <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #4a9d7f;">
                    <h4 style="color: #2d5f4f; margin-bottom: 15px;">👤 Francesco Mariano</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-bottom: 15px;">
                        La mia ricerca artistica si concentra sulla <strong>composizione elettroacustica</strong>, <strong>installazioni sonore interattive</strong>,
                        <strong>soundscape composition</strong> e <strong>ambienti audio immersivi</strong> attraverso programmazione <strong>Max/MSP Jitter</strong>,
                        <strong>TouchDesigner</strong> e sviluppo di applicazioni e software interattivo in ambito artistico.
                    </p>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50;">
                        <strong>Docente di Interaction Design</strong> presso l'<strong>Accademia di Belle Arti di Macerata</strong> e l'<strong>Accademia di Belle Arti di Catania</strong>.
                    </p>
                </div>

                <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 20px;">
                    <h4 style="color: #2d5f4f; margin-bottom: 15px;">🌟 Filosofia del Progetto</h4>
                    <ul style="line-height: 2; color: #2c3e50; font-size: 15px;">
                        <li><strong>Apprendimento Attivo</strong>: Non solo teoria, ma esercizi pratici guidati</li>
                        <li><strong>Accessibilità</strong>: Strumenti professionali accessibili per tutti</li>
                        <li><strong>Professionalità</strong>: Standard professionali, attrezzature reali, workflow consolidati</li>
                        <li><strong>Comunità</strong>: Condivisione di esperienze, registrazioni e scoperte</li>
                        <li><strong>Innovazione</strong>: Uso di tecnologie moderne (IndexedDB, Web Audio API, GeoLocalizzazione)</li>
                    </ul>
                </div>

                <div style="background: #fffbe6; padding: 20px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #f4a261;">
                    <h4 style="color: #2d5f4f; margin-bottom: 15px;">🚀 Roadmap Futura</h4>
                    <p style="color: #2c3e50; line-height: 1.8; font-size: 15px; margin-bottom: 15px;">
                        <strong>📱 App iOS Soundscape Studio</strong> (in arrivo su App Store): Versione nativa con backup completo,
                        funzionalità offline avanzate, esportazione professionale e strumenti di analisi aggiuntivi. Sarà a pagamento
                        per sostenere lo sviluppo continuo del progetto.
                    </p>
                    <p style="color: #2c3e50; line-height: 1.8; font-size: 15px;">
                        Soundscape Studio è il primo di una serie di strumenti didattici dedicati a diverse discipline musicali e artistiche.
                        In futuro verranno sviluppate applicazioni per composizione, teoria musicale, sound design, produzione audio,
                        analisi acustica e molto altro.
                    </p>
                </div>
            </div>

            <!-- Cos'è il Soundscape -->
            <div class="card" style="margin-bottom: 30px;">
                <h3 style="color: #2d5f4f; margin-bottom: 20px; font-size: 22px;">🎧 Cos'è il Soundscape?</h3>

                <p style="font-size: 16px; line-height: 1.8; color: #2c3e50; margin-bottom: 20px;">
                    Il termine <strong>soundscape</strong> (paesaggio sonoro) fu coniato dal compositore e teorico canadese <strong>R. Murray Schafer</strong>
                    negli anni '70, come parte del suo rivoluzionario progetto <em>World Soundscape Project</em>.
                </p>

                <p style="font-size: 16px; line-height: 1.8; color: #2c3e50; margin-bottom: 20px;">
                    Un soundscape è l'insieme di tutti i suoni presenti in un ambiente specifico: naturali (vento, pioggia, animali),
                    umani (voci, traffico, macchine) e architettonici (riverberi, riflessioni). Non è solo "registrazione ambientale",
                    ma un approccio consapevole all'<strong>ascolto profondo</strong> e alla <strong>composizione con suoni reali</strong>.
                </p>

                <div style="background: #f8f9f5; padding: 20px; border-radius: 8px; margin-top: 20px;">
                    <h4 style="color: #2d5f4f; margin-bottom: 15px;">📚 Concetti Fondamentali di Schafer</h4>
                    <ul style="line-height: 2; color: #2c3e50; font-size: 15px;">
                        <li><strong>Keynote Sounds</strong>: Suoni di fondo costanti (vento, traffico lontano, mare)</li>
                        <li><strong>Signal Sounds</strong>: Suoni in primo piano che emergono (campanile, sirena, uccello)</li>
                        <li><strong>Soundmark</strong>: Suoni caratteristici di un luogo (come un "landmark" visivo)</li>
                        <li><strong>Hi-Fi vs Lo-Fi</strong>: Ambienti sonori puliti vs rumorosi/confusi</li>
                        <li><strong>Schizofonia</strong>: Separazione del suono dalla sua fonte originale (es. registrazioni)</li>
                    </ul>
                </div>

                <div style="background: #e8f5f1; padding: 20px; border-radius: 8px; margin-top: 20px;">
                    <h4 style="color: #2d5f4f; margin-bottom: 15px;">🎼 Applicazioni del Field Recording</h4>
                    <ul style="line-height: 2; color: #2c3e50; font-size: 15px;">
                        <li><strong>Musica Concreta</strong>: Composizione con suoni concreti (Pierre Schaeffer, Pierre Henry)</li>
                        <li><strong>Sound Art</strong>: Installazioni sonore, sculture acustiche</li>
                        <li><strong>Sound Design</strong>: Cinema, videogiochi, teatro</li>
                        <li><strong>Documentazione Acustica</strong>: Archivi sonori, ricerca antropologica</li>
                        <li><strong>Ecologia Acustica</strong>: Studio ambienti naturali, bioacustica</li>
                        <li><strong>Mindfulness Sonora</strong>: Deep listening, meditation, terapia del suono</li>
                    </ul>
                </div>
            </div>

            <!-- Contacts & Support -->
            <div class="card" style="background: linear-gradient(135deg, #2d5f4f 0%, #3d7f6f 100%); color: white;">
                <h3 style="margin-bottom: 20px; font-size: 22px; color: white;">📧 Contatti & Supporto</h3>

                <p style="font-size: 16px; line-height: 1.8; margin-bottom: 20px; color: #ffffff;">
                    Per domande, feedback, segnalazioni bug o collaborazioni, inviami un messaggio:
                </p>

                <!-- Form Contatto -->
                <form id="contactForm" style="background: rgba(255,255,255,0.15); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 14px; margin-bottom: 5px; color: #ffffff; font-weight: 600;">Il tuo Nome:</label>
                        <input type="text" id="contactName" required style="width: 100%; padding: 12px; border: none; border-radius: 6px; font-size: 14px; background: rgba(255,255,255,0.95);">
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 14px; margin-bottom: 5px; color: #ffffff; font-weight: 600;">La tua Email:</label>
                        <input type="email" id="contactEmail" required style="width: 100%; padding: 12px; border: none; border-radius: 6px; font-size: 14px; background: rgba(255,255,255,0.95);">
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 14px; margin-bottom: 5px; color: #ffffff; font-weight: 600;">Oggetto:</label>
                        <select id="contactSubject" required style="width: 100%; padding: 12px; border: none; border-radius: 6px; font-size: 14px; background: rgba(255,255,255,0.95);">
                            <option value="">Seleziona un oggetto...</option>
                            <option value="feedback">💬 Feedback</option>
                            <option value="bug">🐛 Segnalazione Bug</option>
                            <option value="feature">💡 Richiesta Funzionalità</option>
                            <option value="collaboration">🤝 Collaborazione</option>
                            <option value="other">❓ Altro</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 14px; margin-bottom: 5px; color: #ffffff; font-weight: 600;">Messaggio:</label>
                        <textarea id="contactMessage" required rows="5" style="width: 100%; padding: 12px; border: none; border-radius: 6px; font-size: 14px; resize: vertical; background: rgba(255,255,255,0.95);"></textarea>
                    </div>

                    <button type="submit" class="btn" style="width: 100%; padding: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        📨 Invia Messaggio
                    </button>

                    <p id="contactFormStatus" style="margin-top: 15px; text-align: center; font-size: 14px; color: #ffffff; display: none;"></p>
                </form>

                <div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <p style="font-size: 15px; margin-bottom: 5px; color: #ffffff;"><strong>👨‍💻 Sviluppato da:</strong></p>
                    <p style="font-size: 16px; color: #ffffff;">Francesco Mariano - Gruppo Apuano Sperimentale</p>
                </div>

                <div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px;">
                    <p style="font-size: 15px; margin-bottom: 10px; color: #ffffff;"><strong>💰 Supporta il Progetto:</strong></p>
                    <p style="font-size: 14px; line-height: 1.6; color: #ffffff;">
                        Se trovi utile questo progetto, considera di supportarlo tramite donazione PayPal.
                    </p>
                </div>
            </div>

            <!-- Share & Support Section -->
            <div class="card" style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-top: 3px solid #2d5f4f; margin-top: 30px;">
                <h3 style="color: #2d5f4f; margin-bottom: 20px; text-align: center;">💚 Condividi e Supporta</h3>

                <p style="text-align: center; color: #666; font-size: 15px; margin-bottom: 20px; line-height: 1.6;">
                    Aiutami a far crescere questo progetto! Condividi l'app con amici e colleghi:
                </p>

                <!-- Share Buttons -->
                <div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 25px; flex-wrap: wrap;">
                    <button onclick="shareApp('whatsapp')" style="padding: 12px 24px; background: linear-gradient(135deg, #25D366 0%, #128C7E 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; box-shadow: 0 2px 8px rgba(37,211,102,0.3); transition: all 0.3s; display: flex; align-items: center; gap: 8px;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(37,211,102,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(37,211,102,0.3)'">
                        <span style="font-size: 18px;">📱</span> Condividi su WhatsApp
                    </button>
                    <button onclick="shareApp('facebook')" style="padding: 12px 24px; background: linear-gradient(135deg, #1877F2 0%, #0C5FCD 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; box-shadow: 0 2px 8px rgba(24,119,242,0.3); transition: all 0.3s; display: flex; align-items: center; gap: 8px;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(24,119,242,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(24,119,242,0.3)'">
                        <span style="font-size: 18px;">👥</span> Condividi su Facebook
                    </button>
                </div>

                <!-- Donation Button -->
                <div style="border-top: 1px solid #dee2e6; padding-top: 20px; text-align: center;">
                    <p style="color: #666; font-size: 15px; margin-bottom: 15px; line-height: 1.6;">
                        Se trovi utile questo progetto, supportalo con una donazione:
                    </p>
                    <a href="https://www.paypal.com/donate/?hosted_button_id=YOUR_BUTTON_ID" target="_blank" rel="noopener noreferrer" style="display: inline-block; padding: 12px 28px; background: linear-gradient(135deg, #0070BA 0%, #1F8FCC 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; text-decoration: none; box-shadow: 0 2px 8px rgba(0,112,186,0.3); transition: all 0.3s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,112,186,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,112,186,0.3)'">
                        💰 Dona con PayPal
                    </a>
                </div>
            </div>
        </div>

        <!-- GUIDE SECTION -->
        <div id="guide" class="section">
            <h2 style="margin-bottom: 30px; color: #2d5f4f; text-align: center;">📖 Guida all'Uso</h2>

            <!-- Spiegazione Sezioni -->
            <div class="card" style="margin-bottom: 30px;">
                <h3 style="color: #2d5f4f; margin-bottom: 25px; font-size: 22px;">🧭 Come Usare Soundscape Studio</h3>

                <!-- Dashboard -->
                <div style="background: #f8f9f5; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #2d5f4f;">
                    <h4 style="color: #2d5f4f; margin-bottom: 12px; font-size: 18px;">🏠 Dashboard</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-bottom: 12px;">
                        La tua <strong>home base</strong>. Qui trovi:
                    </p>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li><strong>Esercizi Completati</strong>: Storico dei tuoi esercizi salvati con audio, foto e note</li>
                        <li><strong>Accessi Rapidi</strong>: Shortcut alle sezioni principali (Esercizi, Toolkit, Map, Biblioteca)</li>
                        <li><strong>Panoramica Attività</strong>: Visualizza i tuoi progressi nel field recording</li>
                    </ul>
                    <p style="font-size: 14px; color: #666; margin-top: 12px; font-style: italic;">
                        💡 Suggerimento: Torna qui dopo ogni sessione per rivedere il tuo lavoro!
                    </p>
                </div>

                <!-- Esercizi -->
                <div style="background: #fff8f0; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #d32f2f;">
                    <h4 style="color: #d32f2f; margin-bottom: 12px; font-size: 18px;">🔔 Esercizi Soundscape</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-bottom: 12px;">
                        Il <strong>cuore del toolkit</strong>. 96 esercizi professionali divisi in 12 categorie:
                    </p>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li><strong>Traffico Urbano</strong>: Auto, moto, bus, ingorghi</li>
                        <li><strong>Mercati</strong>: Voci, venditori, atmosfere commerciali</li>
                        <li><strong>Natura</strong>: Boschi, uccelli, pioggia, vento</li>
                        <li><strong>Costa</strong>: Mare, onde, porti, spiagge</li>
                        <li><strong>Ferrovie</strong>: Treni, stazioni, passaggi a livello</li>
                        <li><strong>Industria</strong>: Fabbriche, macchinari, cantieri</li>
                        <li><strong>Parchi Urbani</strong>: Città e natura combinati</li>
                        <li><strong>Voci/Folla</strong>: Manifestazioni, eventi, conversazioni</li>
                        <li><strong>Cantieri</strong>: Costruzioni, demolizioni, lavori stradali</li>
                        <li><strong>Aeroporti</strong>: Aerei, terminal, annunci</li>
                        <li><strong>Interni Pubblici</strong>: Musei, biblioteche, stazioni metro</li>
                        <li><strong>Eventi Speciali</strong>: Festival, concerti, celebrazioni</li>
                    </ul>
                    <p style="font-size: 14px; color: #666; margin-top: 12px; font-style: italic;">
                        💡 Come funziona:
                    </p>
                    <ol style="line-height: 1.8; color: #2c3e50; font-size: 14px; margin-left: 20px; margin-top: 8px;">
                        <li>Filtra per categoria o livello di difficoltà</li>
                        <li>Leggi brief, obiettivi, setup consigliato</li>
                        <li>Vai sul campo e registra</li>
                        <li>Torna nell'app e clicca "Inizia Esercizio"</li>
                        <li>Carica audio, foto, note, risposte alle domande guida</li>
                        <li>Salva tutto in locale (IndexedDB) - nessun account richiesto!</li>
                    </ol>
                </div>

                <!-- Soundscape Map -->
                <div style="background: #e8f5f1; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #4a9d7f;">
                    <h4 style="color: #2d5f4f; margin-bottom: 12px; font-size: 18px;">🗺️ Soundscape Map</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-bottom: 12px;">
                        Una <strong>mappa interattiva</strong> per documentare i tuoi soundscape:
                    </p>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li><strong>Geolocalizza</strong>: Clicca sulla mappa per aggiungere marker</li>
                        <li><strong>Categorizza</strong>: Traffico, mercato, natura, industriale, ecc.</li>
                        <li><strong>Registra o Carica</strong>: Aggiungi audio direttamente dal microfono o da file</li>
                        <li><strong>Annota</strong>: Descrivi il soundscape, orario, condizioni meteo</li>
                        <li><strong>Riproduci</strong>: Clicca sui marker per ascoltare le tue registrazioni</li>
                    </ul>
                    <p style="font-size: 14px; color: #666; margin-top: 12px; font-style: italic;">
                        💡 Usa la Map per costruire un <strong>archivio personale geolocalizzato</strong> delle tue registrazioni.
                        Perfetto per progetti di documentazione acustica urbana o naturale.
                    </p>
                </div>

                <!-- Toolkit -->
                <div style="background: #fff4f0; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ff6b35;">
                    <h4 style="color: #d32f2f; margin-bottom: 12px; font-size: 18px;">🔧 Toolkit</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-bottom: 12px;">
                        Una <strong>guida all'attrezzatura</strong> per field recording. Diviso in 3 livelli:
                    </p>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li><strong>🟢 Budget (€50-200)</strong>: Smartphone + app, registratori entry-level (Zoom H1n)</li>
                        <li><strong>🟡 Intermediate (€200-1000)</strong>: Zoom H5/F3, microfoni shotgun, accessori</li>
                        <li><strong>🔴 Professional (€1000+)</strong>: Zoom F6, Sound Devices, microfoni Sennheiser/Rode professionali</li>
                    </ul>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-top: 12px;">
                        Ogni prodotto include:
                    </p>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 14px; margin-left: 20px;">
                        <li>📄 <strong>Review professionale</strong>: Pro, contro, casi d'uso ideali</li>
                        <li>🛒 <strong>Link acquisto</strong>: Thomann (audio hardware) o Amazon (accessori/libri)</li>
                        <li>💰 <strong>Range di prezzo</strong>: Stima aggiornata</li>
                        <li>⚙️ <strong>Specifiche chiave</strong>: Risoluzione, canali, autonomia, peso</li>
                    </ul>
                    <p style="font-size: 14px; color: #666; margin-top: 12px; font-style: italic;">
                        💡 Non devi comprare tutto! Inizia con Budget, sperimenta, poi investi in base alle tue esigenze.
                    </p>
                </div>

                <!-- Biblioteca -->
                <div style="background: #f0f4ff; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #5b7cff;">
                    <h4 style="color: #2d5f4f; margin-bottom: 12px; font-size: 18px;">📚 Biblioteca</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-bottom: 12px;">
                        Risorse curate per approfondire teoria e pratica:
                    </p>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li><strong>📕 Libri Essenziali</strong>: Schafer, Krause, Watson, Oliveros - i classici del field recording</li>
                        <li><strong>🎬 Video & Documentari</strong>: Tutorial, interviste, documentari sul soundscape</li>
                        <li><strong>🎧 Esempi Audio</strong>: Registrazioni iconiche da studiare (Bernie Krause, Chris Watson)</li>
                        <li><strong>📄 Paper & Articoli</strong>: Ricerche accademiche su ecologia acustica, sound studies</li>
                        <li><strong>🔗 Risorse Online</strong>: Archivi sonori, community, forum, database</li>
                    </ul>
                    <p style="font-size: 14px; color: #666; margin-top: 12px; font-style: italic;">
                        💡 I link Amazon nella Biblioteca includono il tag affiliato <code>soundscapestu-21</code> - se acquisti da lì,
                        supporti lo sviluppo di questo progetto senza costi aggiuntivi!
                    </p>
                </div>
            </div>

            <!-- Versione Gratuita vs Premium -->
            <div class="card" style="margin-bottom: 30px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border: 2px solid #d4af37;">
                <h3 style="color: #d4af37; margin-bottom: 20px; font-size: 22px; text-align: center;">🆓 Versione Gratuita vs ⭐ Premium</h3>

                <div style="background: #fff; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #28a745;">
                    <h4 style="color: #28a745; margin-bottom: 12px; font-size: 18px;">🆓 Versione Gratuita</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-bottom: 12px;">
                        La versione gratuita ti permette di <strong>sperimentare tutte le funzionalità principali</strong> di Soundscape Studio:
                    </p>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li>✅ <strong>Tutti i 96 esercizi</strong> accessibili (12 categorie complete)</li>
                        <li>✅ <strong>Audio e foto illimitati</strong> per ogni esercizio completato</li>
                        <li>✅ <strong>Fino a 20 markers</strong> sulla mappa interattiva</li>
                        <li>✅ Salvataggio locale completo (IndexedDB + LocalStorage)</li>
                        <li>✅ Accesso a Toolkit, Biblioteca, Guida</li>
                    </ul>
                    <p style="font-size: 15px; line-height: 1.8; color: #d32f2f; margin-top: 15px; font-weight: 600;">
                        ⚠️ LIMITAZIONI:
                    </p>
                    <ul style="line-height: 1.8; color: #d32f2f; font-size: 15px; margin-left: 20px;">
                        <li>⚠️ <strong>Dati salvati SOLO localmente</strong> nel browser (rischio perdita dati)</li>
                        <li>⚠️ Se cancelli l'app o cambi dispositivo, <strong>perdi tutto il tuo archivio</strong></li>
                        <li>❌ <strong>Nessuna funzione di export</strong> (no PDF, no GeoJSON/CSV, no backup completo)</li>
                        <li>❌ Massimo <strong>20 markers sulla mappa</strong> (vs illimitati in Premium)</li>
                    </ul>
                    <p style="font-size: 14px; color: #666; margin-top: 12px; font-style: italic;">
                        💡 La versione gratuita è perfetta per <strong>provare l'app e i primi esercizi</strong>, ma non offre protezione per il tuo lavoro a lungo termine.
                    </p>
                </div>

                <div style="background: linear-gradient(135deg, #fff8e1 0%, #ffe082 20%); padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #d4af37;">
                    <h4 style="color: #d4af37; margin-bottom: 12px; font-size: 18px;">⭐ Versione Premium - "L'Archivio Professionale"</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-bottom: 12px;">
                        La versione Premium trasforma Soundscape Studio in un <strong>archivio professionale sicuro e condivisibile</strong>:
                    </p>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li>💾 <strong>Backup e Ripristino Completo</strong>: Esporta/importa tutti i dati (esercizi, audio, foto, markers) in un unico file JSON</li>
                        <li>📄 <strong>Export PDF Professionale</strong>: Genera report stampabili dei tuoi esercizi con audio, foto e note</li>
                        <li>🗺️ <strong>Export GeoJSON/CSV/KML/Excel/Word</strong>: Esporta i tuoi dati per analisi GIS, ricerca scientifica, condivisione con team</li>
                        <li>♾️ <strong>Markers illimitati</strong> sulla mappa (vs 20 in versione gratuita)</li>
                        <li>🚀 <strong>Tutte le future funzioni Pro</strong>: Nuove features, tool avanzati, integrazioni professionali</li>
                    </ul>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-top: 15px; font-weight: 600;">
                        🎯 A chi è rivolta la versione Premium?
                    </p>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 14px; margin-left: 20px;">
                        <li><strong>Sound designer professionisti</strong> che vogliono proteggere il proprio archivio sonoro</li>
                        <li><strong>Studenti universitari</strong> che devono presentare progetti di field recording</li>
                        <li><strong>Ricercatori e sound artists</strong> che necessitano di export GeoJSON per analisi scientifiche</li>
                        <li><strong>Appassionati seri</strong> che investono tempo nel field recording e non vogliono rischiare di perdere dati</li>
                    </ul>
                    <p style="font-size: 14px; color: #666; margin-top: 12px; font-style: italic;">
                        💡 Premium ti offre <strong>tranquillità</strong>: il tuo lavoro è al sicuro, condivisibile e professionale.
                    </p>
                </div>

                <div style="background: #f0f8ff; padding: 20px; border-radius: 8px; border-left: 4px solid #2196F3;">
                    <h4 style="color: #2196F3; margin-bottom: 12px; font-size: 16px;">💰 Come Passare a Premium?</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-bottom: 12px;">
                        L'upgrade a Premium avviene tramite <strong>acquisto in-app</strong> sull'App Store:
                    </p>
                    <ol style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li>Clicca su qualsiasi funzione Premium (es. "Backup Completo", "Export PDF")</li>
                        <li>Verrà mostrato il modal di upgrade con prezzo e dettagli</li>
                        <li>Conferma l'acquisto tramite Apple Pay / Touch ID / Face ID</li>
                        <li>Le funzioni Premium si attiveranno immediatamente!</li>
                    </ol>
                    <p style="font-size: 14px; color: #666; margin-top: 12px; font-style: italic;">
                        🔐 L'acquisto è gestito da Apple (sicuro, protetto) e può essere ripristinato su tutti i tuoi dispositivi.
                    </p>
                </div>
            </div>

            <!-- Tips & Best Practices -->
            <div class="card" style="margin-bottom: 30px; background: #fffbe6; border-left: 5px solid #f4a261;">
                <h3 style="color: #2d5f4f; margin-bottom: 20px; font-size: 22px;">💡 Tips & Best Practices</h3>

                <div style="margin-bottom: 20px;">
                    <h4 style="color: #2d5f4f; margin-bottom: 10px; font-size: 16px;">🎤 Durante la Registrazione</h4>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li>Usa sempre le <strong>cuffie</strong> per monitorare in tempo reale</li>
                        <li>Controlla i livelli: evita clipping (LED rossi), ma non registrare troppo basso</li>
                        <li>Registra almeno <strong>2-3 minuti</strong> per ogni soundscape (serve materiale per editing)</li>
                        <li>Fai più take dello stesso luogo (mattina vs sera, giorno feriale vs weekend)</li>
                        <li>Sperimenta angolazioni diverse: stereo XY, MS, spaced pair</li>
                        <li>Annota tutto: ora, meteo, eventi speciali, problemi tecnici</li>
                    </ul>
                </div>

                <div style="margin-bottom: 20px;">
                    <h4 style="color: #2d5f4f; margin-bottom: 10px; font-size: 16px;">📝 Documentazione</h4>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li>Scatta <strong>foto del setup</strong>: microfono, posizione, ambiente</li>
                        <li>Segna coordinate GPS precise (usa la Map!)</li>
                        <li>Descrivi dettagliatamente: "Piazza del mercato, sabato mattina 9:30, soleggiato, 50 persone circa"</li>
                        <li>Salva metadati tecnici: gain, sample rate, tipo di microfono</li>
                    </ul>
                </div>

                <div style="margin-bottom: 20px;">
                    <h4 style="color: #2d5f4f; margin-bottom: 10px; font-size: 16px;">🔒 Privacy & Legale</h4>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li>In Italia, registrare in <strong>spazi pubblici</strong> è generalmente legale (no aspettativa di privacy)</li>
                        <li>Evita conversazioni private riconoscibili (GDPR)</li>
                        <li>Chiedi permessi per spazi privati (musei, negozi, ristoranti)</li>
                        <li>Se pubblichi online, considera rilascio Creative Commons</li>
                    </ul>
                </div>

                <div>
                    <h4 style="color: #2d5f4f; margin-bottom: 10px; font-size: 16px;">🎓 Workflow Consigliato</h4>
                    <ol style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px;">
                        <li>Scegli 1-2 esercizi dalla sezione <strong>Esercizi</strong></li>
                        <li>Studia il brief e prepara attrezzatura (vedi <strong>Toolkit</strong>)</li>
                        <li>Vai sul campo e registra (usa <strong>Soundscape Map</strong> per geolocalizzare)</li>
                        <li>Torna a casa, completa l'esercizio nell'app (carica audio, foto, note)</li>
                        <li>Ascolta in back, analizza con le domande guida dell'esercizio</li>
                        <li>Approfondisci leggendo risorse dalla <strong>Biblioteca</strong></li>
                        <li>Ripeti! La pratica costante è fondamentale</li>
                    </ol>
                </div>
            </div>

            <!-- FAQ -->
            <div class="card" style="margin-bottom: 30px;">
                <h3 style="color: #2d5f4f; margin-bottom: 20px; font-size: 22px;">❓ FAQ - Domande Frequenti</h3>

                <div style="margin-bottom: 20px; padding-bottom: 20px; border-bottom: 2px solid #e8f5f1;">
                    <h4 style="color: #2d5f4f; margin-bottom: 8px; font-size: 16px;">Dove vengono salvati i miei dati?</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50;">
                        Tutto in <strong>locale sul tuo browser</strong> (IndexedDB). Non c'è nessun server, nessun account, nessun upload.
                        I tuoi audio, foto, esercizi restano privati sul tuo dispositivo.
                        <strong>⚠️ Attenzione</strong>: Se cancelli i dati del browser, perdi tutto! Usa la funzione "Esporta" per backup.
                    </p>
                </div>

                <div style="margin-bottom: 20px; padding-bottom: 20px; border-bottom: 2px solid #e8f5f1;">
                    <h4 style="color: #2d5f4f; margin-bottom: 8px; font-size: 16px;">Posso usare Soundscape Studio da mobile?</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50;">
                        Sì! Il sito è responsive. La registrazione audio funziona su browser mobile (Chrome, Safari).
                        La geolocalizzazione funziona perfettamente su smartphone. In futuro è prevista un'app iOS nativa dedicata.
                    </p>
                </div>

                <div style="margin-bottom: 20px; padding-bottom: 20px; border-bottom: 2px solid #e8f5f1;">
                    <h4 style="color: #2d5f4f; margin-bottom: 8px; font-size: 16px;">Come funziona il modello di business?</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50;">
                        Soundscape Studio è disponibile come <strong>app iOS su App Store</strong> con funzionalità complete:
                        esportazione professionale, accesso offline avanzato e strumenti di analisi.
                    </p>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50; margin-top: 10px;">
                        Il progetto si sostiene tramite <strong>vendita app</strong>, <strong>link affiliati</strong> (Thomann, Amazon) e donazioni PayPal volontarie.
                        Se trovi utile questo toolkit, considera di acquistare l'app, acquistare attrezzatura dai link forniti o fare una donazione per supportare lo sviluppo!
                    </p>
                </div>

                <div style="margin-bottom: 20px; padding-bottom: 20px; border-bottom: 2px solid #e8f5f1;">
                    <h4 style="color: #2d5f4f; margin-bottom: 8px; font-size: 16px;">Posso contribuire al progetto?</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50;">
                        Assolutamente! Puoi:
                    </p>
                    <ul style="line-height: 1.8; color: #2c3e50; font-size: 15px; margin-left: 20px; margin-top: 8px;">
                        <li>📧 Inviare feedback e suggerimenti via email</li>
                        <li>🎧 Condividere il progetto con altri sound recordist</li>
                        <li>💰 Fare una donazione PayPal</li>
                        <li>🛒 Acquistare attrezzatura dai link affiliati</li>
                        <li>📝 Segnalare bug o proporre nuovi esercizi</li>
                    </ul>
                </div>

                <div style="margin-bottom: 20px; padding-bottom: 20px; border-bottom: 2px solid #e8f5f1;">
                    <h4 style="color: #2d5f4f; margin-bottom: 8px; font-size: 16px;">Quanto spazio occupa sul browser?</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50;">
                        Dipende da quanti esercizi completi. Un esercizio con 5 audio (2-3 min ciascuno) e 3 foto occupa circa 20-50 MB.
                        La maggior parte dei browser moderni permette diversi GB di storage IndexedDB.
                        Puoi monitorare lo spazio nelle impostazioni del browser.
                    </p>
                </div>

                <div>
                    <h4 style="color: #2d5f4f; margin-bottom: 8px; font-size: 16px;">Posso condividere le mie registrazioni?</h4>
                    <p style="font-size: 15px; line-height: 1.8; color: #2c3e50;">
                        Al momento non c'è una funzione di sharing integrata (tutto è locale).
                        Puoi esportare i tuoi esercizi come file e condividerli manualmente.
                        In futuro potrebbe essere aggiunta una community/gallery opzionale.
                    </p>
                </div>
            </div>

            <!-- Contatti & Supporto -->
            <div class="card" style="background: linear-gradient(135deg, #2d5f4f 0%, #3d7f6f 100%); color: white;">
                <h3 style="margin-bottom: 20px; font-size: 22px; color: white;">📧 Contatti & Supporto</h3>

                <p style="font-size: 16px; line-height: 1.8; margin-bottom: 20px; color: #ffffff;">
                    Per domande, feedback, segnalazioni bug o collaborazioni, inviami un messaggio:
                </p>

                <!-- Form Contatto -->
                <form id="contactForm2" style="background: rgba(255,255,255,0.15); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 14px; margin-bottom: 5px; color: #ffffff; font-weight: 600;">Il tuo Nome:</label>
                        <input type="text" id="contactName2" required style="width: 100%; padding: 12px; border: none; border-radius: 6px; font-size: 14px; background: rgba(255,255,255,0.95);">
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 14px; margin-bottom: 5px; color: #ffffff; font-weight: 600;">La tua Email:</label>
                        <input type="email" id="contactEmail2" required style="width: 100%; padding: 12px; border: none; border-radius: 6px; font-size: 14px; background: rgba(255,255,255,0.95);">
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 14px; margin-bottom: 5px; color: #ffffff; font-weight: 600;">Oggetto:</label>
                        <select id="contactSubject2" required style="width: 100%; padding: 12px; border: none; border-radius: 6px; font-size: 14px; background: rgba(255,255,255,0.95);">
                            <option value="">Seleziona un oggetto...</option>
                            <option value="feedback">💬 Feedback</option>
                            <option value="bug">🐛 Segnalazione Bug</option>
                            <option value="feature">💡 Richiesta Funzionalità</option>
                            <option value="collaboration">🤝 Collaborazione</option>
                            <option value="other">❓ Altro</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 14px; margin-bottom: 5px; color: #ffffff; font-weight: 600;">Messaggio:</label>
                        <textarea id="contactMessage2" required rows="5" style="width: 100%; padding: 12px; border: none; border-radius: 6px; font-size: 14px; resize: vertical; background: rgba(255,255,255,0.95);"></textarea>
                    </div>

                    <button type="submit" class="btn" style="width: 100%; padding: 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        📨 Invia Messaggio
                    </button>

                    <p id="contactFormStatus2" style="margin-top: 15px; text-align: center; font-size: 14px; color: #ffffff; display: none;"></p>
                </form>

                <div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <p style="font-size: 15px; margin-bottom: 5px; color: #ffffff;"><strong>👨‍💻 Sviluppato da:</strong></p>
                    <p style="font-size: 16px; color: #ffffff;">Francesco Mariano - Gruppo Apuano Sperimentale</p>
                </div>

                <div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px;">
                    <p style="font-size: 15px; margin-bottom: 10px; color: #ffffff;"><strong>💰 Supporta il Progetto:</strong></p>
                    <p style="font-size: 14px; line-height: 1.6; color: #ffffff;">
                        Se trovi utile questo progetto, considera di supportarlo tramite donazione PayPal.
                    </p>
                </div>
            </div>

            <!-- Footer -->
            <div class="section-footer">
                <div class="footer-buttons">
                    <a href="#" onclick="shareApp('whatsapp'); return false;" class="footer-btn whatsapp">
                        📱 Condividi su WhatsApp
                    </a>
                    <a href="#" onclick="shareApp('facebook'); return false;" class="footer-btn facebook">
                        📘 Condividi su Facebook
                    </a>
                    <a href="https://www.paypal.com/paypalme/francescomariano" class="footer-btn paypal" target="_blank">
                        💰 Sostieni con Donazione
                    </a>
                    <a href="mailto:soundscapestudiopro@gmail.com?subject=Feedback%20Soundscape%20Studio" class="footer-btn feedback">
                        ✉️ Invia Feedback
                    </a>
                </div>
                <div class="footer-credits">
                    <p><strong>Ideato e sviluppato da Francesco Mariano</strong></p>
                    <p>Gruppo Apuano Sperimentale</p>
                </div>
            </div>
        </div>

        <!-- MAP SECTION -->
        <div id="map" class="section">
            <h2 style="margin-bottom: 20px; color: #2d5f4f;">🗺️ Soundscape Map</h2>

            <!-- Istruzioni -->
            <div class="card" style="background: #fffbe6; border-left: 4px solid #f4a261; margin-bottom: 20px;">
                <p style="color: #2d5f4f; font-weight: 600; margin-bottom: 8px;">📍 Come usare la mappa:</p>
                <p style="color: #666; font-size: 14px;">
                    1. Clicca sulla mappa per aggiungere un marker<br>
                    2. Seleziona una categoria (traffico, mercato, natura, ecc.)<br>
                    3. Aggiungi una descrizione<br>
                    4. Registra audio dal microfono o carica un file<br>
                    5. Riproduci i tuoi soundscape salvati!
                </p>
            </div>

            <!-- Map Container -->
            <div style="margin-bottom: 20px; width: 100%; max-width: 100%; overflow: hidden; box-sizing: border-box;">
                <div id="leafletMap" style="height: 500px; width: 100%; max-width: 100%; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); border: 2px solid #e0e0e0; margin-bottom: 20px; box-sizing: border-box;"></div>
            </div>

            <!-- Controls and Markers -->
            <div style="width: 100%; max-width: 100%; margin-bottom: 20px; box-sizing: border-box; overflow-x: hidden;">
                <!-- Sidebar with Controls -->
                <div style="width: 100%; max-width: 100%; box-sizing: border-box; overflow-x: hidden;">
                    <div class="card" style="width: 100%; max-width: 100%; overflow-x: hidden; box-sizing: border-box; padding: 15px;">
                        <h4 style="color: #2d5f4f; margin-bottom: 15px;">🎯 Aggiungi Marker</h4>

                        <p style="font-size: 14px; color: #666; margin-bottom: 10px;">Clicca sulla mappa per posizionare o:</p>
                        <button onclick="detectMapGPSLocation()" style="width: 100%; padding: 10px; background: #4a9d7f; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; margin-bottom: 15px;">
                            📍 Usa la Mia Posizione Attuale
                        </button>

                        <label style="display: block; font-weight: 600; color: #2d5f4f; margin-bottom: 8px; font-size: 14px;">Categoria:</label>
                        <select id="markerCategory" style="width: 100%; padding: 8px; border-radius: 6px; border: 2px solid #e0e0e0; margin-bottom: 15px;">
                            <option value="traffic">🚗 Traffico Urbano</option>
                            <option value="market">🛒 Mercato</option>
                            <option value="voices">👥 Voci/Folla</option>
                            <option value="industrial">🏭 Industriale</option>
                            <option value="railway">🚂 Ferroviaria</option>
                            <option value="coastal">🌊 Costiera</option>
                            <option value="forest">🌲 Boschiva</option>
                            <option value="park">🌳 Parco Urbano</option>
                            <option value="construction">🚧 Cantiere</option>
                            <option value="airport">✈️ Aeroporto</option>
                            <option value="other">📌 Altro</option>
                        </select>

                        <div style="margin-bottom: 15px; width: 100%; max-width: 100%; overflow: hidden; box-sizing: border-box;">
                            <label style="display: block; font-weight: 600; color: #2d5f4f; margin-bottom: 8px; font-size: 14px;">Note:</label>
                            <div style="width: 100%; max-width: 100%; overflow: hidden; box-sizing: border-box;">
                                <input type="text" id="markerNotes" placeholder="Descrizione del soundscape..." style="width: 100%; padding: 8px; border-radius: 6px; border: 2px solid #e0e0e0; font-size: 16px; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, sans-serif;" />
                            </div>
                        </div>

                        <!-- Spectrum Analyzer -->
                        <div style="margin-bottom: 15px; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 15px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                                <label style="font-weight: 600; color: #00d4ff; font-size: 13px; text-shadow: 0 0 10px rgba(0,212,255,0.5);">
                                    📊 Analizzatore Spettro
                                </label>
                                <span id="spectrumStatus" style="font-size: 11px; color: #888; background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 12px;">
                                    In attesa...
                                </span>
                            </div>
                            <canvas id="spectrumCanvas" width="800" height="300" style="width: 100%; height: 150px; border-radius: 8px; background: #0a0a15; box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);"></canvas>

                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                                <div style="font-size: 10px; color: #666;">
                                    <span style="color: #00d4ff;">20 Hz - 10 kHz</span>
                                </div>
                            </div>
                        </div>

                        <div style="border-top: 2px solid #e8f5f1; padding-top: 15px; margin-top: 15px;">
                            <h4 style="color: #2d5f4f; margin-bottom: 12px; font-size: 14px;">🎤 Audio</h4>

                            <!-- Recording Controls -->
                            <div id="recordingControls">
                                <button id="startRecording" class="btn" style="width: 100%; margin-bottom: 8px; background: #d32f2f; color: white;">
                                    🔴 Registra
                                </button>
                                <button id="stopRecording" class="btn" style="width: 100%; margin-bottom: 8px; display: none; background: #666;">
                                    ⏹️ Stop
                                </button>
                                <div id="recordingTime" style="text-align: center; font-size: 14px; color: #d32f2f; margin-bottom: 8px; display: none; font-weight: 600;">
                                    ⏱️ 00:00
                                </div>
                            </div>

                            <!-- Upload File -->
                            <label for="audioFileUpload" class="btn" style="width: 100%; text-align: center; display: inline-block; margin-bottom: 8px; background: #2d5f4f; color: white; cursor: pointer;">
                                📁 Carica File Audio
                            </label>
                            <input type="file" id="audioFileUpload" accept="audio/*" style="display: none;">

                            <!-- Audio Preview -->
                            <div id="audioPreview" style="display: none; margin-top: 10px; padding: 10px; background: #f8f9f5; border-radius: 6px; max-width: 100%; box-sizing: border-box; overflow: hidden;">
                                <p style="font-size: 12px; color: #2d5f4f; margin-bottom: 6px; font-weight: 600;">Preview:</p>
                                <audio id="audioPreviewPlayer" controls style="width: 100%; max-width: 100%; height: 32px; box-sizing: border-box;"></audio>
                            </div>
                        </div>
                    </div>

                    <!-- Markers List -->
                    <div class="card" style="margin-top: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <h4 style="color: #2d5f4f; margin: 0;">📍 I Tuoi Markers</h4>
                            <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                                <button onclick="exportToKML()" style="padding: 4px 10px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;" title="Esporta per Google Earth/Maps (Premium)">
                                    🗺️ KML
                                </button>
                                <button onclick="exportMapGeoJSON()" style="padding: 4px 10px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;" title="Esporta in formato GeoJSON (Premium)">
                                    📥 GeoJSON
                                </button>
                                <button onclick="exportMapCSV()" style="padding: 4px 10px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;" title="Esporta in formato CSV (Premium)">
                                    📊 CSV
                                </button>
                                <button onclick="deleteAllMarkers()" style="padding: 4px 10px; background: #d9534f; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;" title="Elimina tutti i markers">
                                    🗑️ Elimina Tutto
                                </button>
                            </div>
                        </div>
                        <div id="markersList" style="font-size: 14px; max-height: 600px; overflow-y: auto; padding-right: 8px;">
                            <p style="color: #999; font-style: italic;">Nessun marker salvato</p>
                        </div>
                    </div>
                </div>

                <!-- Markers List Expanded (right side) -->
                <div style="flex: 1;">
                    <!-- Placeholder for expanded view -->
                </div>
            </div>

            <!-- Footer -->
            <div class="section-footer">
                <div class="footer-buttons">
                    <a href="#" onclick="shareApp('whatsapp'); return false;" class="footer-btn whatsapp">
                        📱 Condividi su WhatsApp
                    </a>
                    <a href="#" onclick="shareApp('facebook'); return false;" class="footer-btn facebook">
                        📘 Condividi su Facebook
                    </a>
                    <a href="https://www.paypal.com/paypalme/francescomariano" class="footer-btn paypal" target="_blank">
                        💰 Sostieni con Donazione
                    </a>
                    <a href="mailto:soundscapestudiopro@gmail.com?subject=Feedback%20Soundscape%20Studio" class="footer-btn feedback">
                        ✉️ Invia Feedback
                    </a>
                </div>
                <div class="footer-credits">
                    <p><strong>Ideato e sviluppato da Francesco Mariano</strong></p>
                    <p>Gruppo Apuano Sperimentale</p>
                </div>
            </div>
        </div>

        <!-- SPECTROGRAM SECTION -->
        <div id="spectrogram" class="section">
            <h2 style="margin-bottom: 20px; color: #2d5f4f;">🎵 Spettrogramma</h2>

            <!-- Istruzioni -->
            <div class="card" style="background: #fffbe6; border-left: 4px solid #f4a261; margin-bottom: 20px;">
                <p style="color: #2d5f4f; font-weight: 600; margin-bottom: 8px;">🎼 Visualizza lo spettro audio:</p>
                <p style="color: #666; font-size: 14px;">
                    1. Seleziona un audio salvato dai tuoi esercizi<br>
                    2. Premi Play per avviare la riproduzione<br>
                    3. Osserva lo spettrogramma in tempo reale<br>
                    4. Analizza le frequenze del tuo soundscape
                </p>
            </div>

            <!-- Audio Source Selector -->
            <div class="card" style="margin-bottom: 20px;">
                <h4 style="color: #2d5f4f; margin-bottom: 15px;">🎧 Carica Audio</h4>

                <!-- Source Type Selector -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; color: #2d5f4f; margin-bottom: 8px; font-size: 14px;">Scegli sorgente audio:</label>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        <button onclick="showSpectrogramSource('exercises')" id="spectrogramSourceExercises" class="btn" style="background: #4a9d7f; color: white; font-size: 13px; padding: 10px;">
                            📝 Da Esercizi
                        </button>
                        <button onclick="showSpectrogramSource('markers')" id="spectrogramSourceMarkers" class="btn" style="background: #4a9d7f; color: white; font-size: 13px; padding: 10px;">
                            📍 Da Marker Map
                        </button>
                        <button onclick="showSpectrogramSource('device')" id="spectrogramSourceDevice" class="btn" style="background: #4a9d7f; color: white; font-size: 13px; padding: 10px;">
                            📁 Da Dispositivo
                        </button>
                    </div>
                </div>

                <!-- Exercise Audio Selector -->
                <div id="spectrogramExercisesPanel" style="display: none;">
                    <label style="display: block; font-weight: 600; color: #2d5f4f; margin-bottom: 8px; font-size: 14px;">Seleziona esercizio:</label>
                    <select id="spectrogramExerciseSelector" style="width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #e0e0e0; font-size: 14px;" onchange="onSpectrogramExerciseSelected(this.value)">
                        <option value="">-- Seleziona un esercizio --</option>
                    </select>
                    <p id="spectrogramNoExercises" style="color: #999; font-style: italic; font-size: 13px; margin-top: 10px; display: none;">
                        Nessun esercizio con audio salvato. Vai in <strong>🔔 Soundscape Exercises</strong> e completa un esercizio con registrazione.
                    </p>
                </div>

                <!-- Marker Audio Selector -->
                <div id="spectrogramMarkersPanel" style="display: none;">
                    <label style="display: block; font-weight: 600; color: #2d5f4f; margin-bottom: 8px; font-size: 14px;">Seleziona marker:</label>
                    <select id="spectrogramMarkerSelector" style="width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #e0e0e0; font-size: 14px;" onchange="onSpectrogramMarkerSelected(this.value)">
                        <option value="">-- Seleziona un marker --</option>
                    </select>
                    <p id="spectrogramNoMarkers" style="color: #999; font-style: italic; font-size: 13px; margin-top: 10px; display: none;">
                        Nessun marker con audio salvato. Vai in <strong>🗺️ Soundscape Map</strong> e aggiungi un marker con audio.
                    </p>
                </div>

                <!-- Device File Uploader -->
                <div id="spectrogramDevicePanel" style="display: none;">
                    <label style="display: block; font-weight: 600; color: #2d5f4f; margin-bottom: 8px; font-size: 14px;">Carica file audio:</label>
                    <input type="file" id="spectrogramDeviceFile" accept="audio/*" style="width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #e0e0e0; font-size: 14px;" onchange="onSpectrogramDeviceFileSelected(this)">
                    <p style="color: #666; font-size: 12px; margin-top: 8px; font-style: italic;">
                        Formati supportati: MP3, WAV, M4A, OGG, WEBM
                    </p>
                </div>
            </div>

            <!-- Spectrogram Visualizer -->
            <div class="card" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 20px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                    <label style="font-weight: 600; color: #00d4ff; font-size: 16px; text-shadow: 0 0 10px rgba(0,212,255,0.5);">
                        📊 Analizzatore Spettro
                    </label>
                    <span id="spectrogramPlaybackStatus" style="font-size: 12px; color: #888; background: rgba(255,255,255,0.1); padding: 6px 12px; border-radius: 12px;">
                        In attesa...
                    </span>
                </div>
                <canvas id="spectrogramPlaybackCanvas" width="800" height="300" style="width: 100%; height: 200px; border-radius: 8px; background: #0a0a15; box-shadow: inset 0 2px 10px rgba(0,0,0,0.5); margin-bottom: 15px;"></canvas>

                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="font-size: 11px; color: #666;">
                        <span style="color: #00d4ff;">20 Hz - 10 kHz</span>
                    </div>
                    <div id="spectrogramFrequencyPeak" style="font-size: 11px; color: #00d4ff;">
                        Peak: -- Hz
                    </div>
                </div>
            </div>

            <!-- Playback Controls -->
            <div class="card" style="margin-bottom: 20px;">
                <h4 style="color: #2d5f4f; margin-bottom: 15px;">🎮 Controlli Riproduzione</h4>

                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button id="spectrogramPlayBtn" onclick="playSpectrogramAudio()" class="btn" style="flex: 1; background: #4a9d7f; color: white; font-weight: 600;" disabled>
                        ▶️ Play
                    </button>
                    <button id="spectrogramPauseBtn" onclick="pauseSpectrogramAudio()" class="btn" style="flex: 1; background: #f4a261; color: white; font-weight: 600;" disabled>
                        ⏸️ Pause
                    </button>
                    <button id="spectrogramStopBtn" onclick="stopSpectrogramAudio()" class="btn" style="flex: 1; background: #d9534f; color: white; font-weight: 600;" disabled>
                        ⏹️ Stop
                    </button>
                </div>

                <!-- Progress Bar -->
                <div style="margin-bottom: 10px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span id="spectrogramCurrentTime" style="font-size: 12px; color: #666;">00:00</span>
                        <span id="spectrogramDuration" style="font-size: 12px; color: #666;">00:00</span>
                    </div>
                    <div style="width: 100%; height: 6px; background: #e0e0e0; border-radius: 3px; overflow: hidden;">
                        <div id="spectrogramProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4a9d7f 0%, #00d4ff 100%); transition: width 0.1s linear;"></div>
                    </div>
                </div>

                <!-- Volume Control -->
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 14px; color: #2d5f4f;">🔊</span>
                    <input type="range" id="spectrogramVolume" min="0" max="100" value="70" style="flex: 1;" onchange="updateSpectrogramVolume(this.value)">
                    <span id="spectrogramVolumeValue" style="font-size: 12px; color: #666; min-width: 35px;">70%</span>
                </div>
            </div>

            <!-- Audio Info -->
            <div id="spectrogramAudioInfo" class="card" style="display: none; background: #f8f9f5; margin-bottom: 20px;">
                <h4 style="color: #2d5f4f; margin-bottom: 10px;">ℹ️ Informazioni Audio</h4>
                <div id="spectrogramAudioInfoContent" style="font-size: 13px; color: #666; line-height: 1.6;">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <!-- Guida: Come leggere lo Spettrogramma -->
            <div class="card" style="background: linear-gradient(135deg, #f8f9f5 0%, #e8f5f1 100%); margin-bottom: 20px; border-left: 4px solid #2d5f4f;">
                <h3 style="color: #2d5f4f; margin-bottom: 15px; font-size: 18px;">📚 Come Leggere lo Spettrogramma</h3>

                <div style="margin-bottom: 20px;">
                    <h4 style="color: #4a9d7f; margin-bottom: 10px; font-size: 16px;">🎯 Cos'è uno Spettrogramma?</h4>
                    <p style="color: #666; font-size: 14px; line-height: 1.6; margin: 0;">
                        Lo spettrogramma è una rappresentazione visiva del contenuto in frequenza di un segnale audio nel tempo.
                        Mostra quali frequenze sono presenti in ogni momento della registrazione e con quale intensità.
                    </p>
                </div>

                <div style="margin-bottom: 20px;">
                    <h4 style="color: #4a9d7f; margin-bottom: 10px; font-size: 16px;">📊 Come si legge?</h4>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 12px;">
                        <ul style="color: #666; font-size: 14px; line-height: 1.8; margin: 0; padding-left: 20px;">
                            <li><strong>Asse Orizzontale (Tempo):</strong> L'audio scorre da destra a sinistra nel tempo</li>
                            <li><strong>Asse Verticale (Frequenza):</strong> Le frequenze basse (20 Hz) stanno in basso, le alte (10 kHz) in alto</li>
                            <li><strong>Colori (Intensità):</strong>
                                <span style="display: inline-block; width: 12px; height: 12px; background: #0000ff; border-radius: 2px; margin: 0 4px;"></span> Blu = Silenzio,
                                <span style="display: inline-block; width: 12px; height: 12px; background: #00ffff; border-radius: 2px; margin: 0 4px;"></span> Ciano = Debole,
                                <span style="display: inline-block; width: 12px; height: 12px; background: #00ff00; border-radius: 2px; margin: 0 4px;"></span> Verde = Medio,
                                <span style="display: inline-block; width: 12px; height: 12px; background: #ffff00; border-radius: 2px; margin: 0 4px;"></span> Giallo = Forte,
                                <span style="display: inline-block; width: 12px; height: 12px; background: #ff0000; border-radius: 2px; margin: 0 4px;"></span> Rosso = Molto Forte
                            </li>
                            <li><strong>Range: 20 Hz - 10 kHz</strong> copre la maggior parte dei suoni udibili umani</li>
                        </ul>
                    </div>
                </div>

                <div style="margin-bottom: 20px;">
                    <h4 style="color: #4a9d7f; margin-bottom: 10px; font-size: 16px;">🔍 Spettri Caratteristici</h4>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px;">
                        <!-- Voce Umana -->
                        <div style="background: white; padding: 12px; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 24px; margin-right: 8px;">🗣️</span>
                                <strong style="color: #2d5f4f;">Voce Umana</strong>
                            </div>
                            <p style="color: #666; font-size: 13px; margin: 0; line-height: 1.5;">
                                <strong>200-3000 Hz</strong> - Bande orizzontali concentrate tra 200-300 Hz (voce maschile) o 300-500 Hz (voce femminile).
                                Formanti visibili come righe orizzontali multiple. Modulazione continua.
                            </p>
                        </div>

                        <!-- Traffico Urbano -->
                        <div style="background: white; padding: 12px; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 24px; margin-right: 8px;">🚗</span>
                                <strong style="color: #2d5f4f;">Traffico Urbano</strong>
                            </div>
                            <p style="color: #666; font-size: 13px; margin: 0; line-height: 1.5;">
                                <strong>50-1000 Hz</strong> - Energia concentrata nelle basse frequenze (motori).
                                Pattern continuo irregolare. Picchi occasionali 2-4 kHz (clacson, freni).
                            </p>
                        </div>

                        <!-- Uccelli -->
                        <div style="background: white; padding: 12px; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 24px; margin-right: 8px;">🐦</span>
                                <strong style="color: #2d5f4f;">Canto Uccelli</strong>
                            </div>
                            <p style="color: #666; font-size: 13px; margin: 0; line-height: 1.5;">
                                <strong>2000-8000 Hz</strong> - Linee curve e ondulate nelle alte frequenze.
                                Pattern ripetitivi con pause. Molto definiti e puliti, separati dal rumore di fondo.
                            </p>
                        </div>

                        <!-- Acqua -->
                        <div style="background: white; padding: 12px; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 24px; margin-right: 8px;">🌊</span>
                                <strong style="color: #2d5f4f;">Acqua/Onde</strong>
                            </div>
                            <p style="color: #666; font-size: 13px; margin: 0; line-height: 1.5;">
                                <strong>200-6000 Hz</strong> - Rumore bianco distribuito uniformemente.
                                Pattern continuo senza picchi definiti. Intensità variabile ciclica (onde).
                            </p>
                        </div>

                        <!-- Strumenti Musicali -->
                        <div style="background: white; padding: 12px; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 24px; margin-right: 8px;">🎸</span>
                                <strong style="color: #2d5f4f;">Strumenti Musicali</strong>
                            </div>
                            <p style="color: #666; font-size: 13px; margin: 0; line-height: 1.5;">
                                <strong>Variabile</strong> - Righe orizzontali parallele (armonici).
                                Nota fondamentale + multipli (2x, 3x, 4x frequenza). Pattern regolare e stabile.
                            </p>
                        </div>

                        <!-- Vento -->
                        <div style="background: white; padding: 12px; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 24px; margin-right: 8px;">💨</span>
                                <strong style="color: #2d5f4f;">Vento</strong>
                            </div>
                            <p style="color: #666; font-size: 13px; margin: 0; line-height: 1.5;">
                                <strong>50-2000 Hz</strong> - Rumore a banda larga nelle basse frequenze.
                                Pattern molto irregolare e turbolento. Intensità fluttuante, senza forma definita.
                            </p>
                        </div>

                        <!-- Fischio -->
                        <div style="background: white; padding: 12px; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 24px; margin-right: 8px;">🎵</span>
                                <strong style="color: #2d5f4f;">Fischio/Tono Puro</strong>
                            </div>
                            <p style="color: #666; font-size: 13px; margin: 0; line-height: 1.5;">
                                <strong>Frequenza specifica</strong> - Linea orizzontale singola molto netta.
                                Colore intenso (rosso/giallo). Frequenza costante o glissando (linea obliqua).
                            </p>
                        </div>

                        <!-- Industria -->
                        <div style="background: white; padding: 12px; border-radius: 8px; border: 2px solid #e0e0e0;">
                            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 24px; margin-right: 8px;">🏭</span>
                                <strong style="color: #2d5f4f;">Rumore Industriale</strong>
                            </div>
                            <p style="color: #666; font-size: 13px; margin: 0; line-height: 1.5;">
                                <strong>100-4000 Hz</strong> - Pattern molto denso con picchi a frequenze specifiche (macchinari).
                                Componente continua + impulsi periodici. Armonici dei motori visibili.
                            </p>
                        </div>
                    </div>
                </div>

                <div style="background: #fffbe6; padding: 15px; border-radius: 8px; border-left: 4px solid #f4a261;">
                    <p style="color: #2d5f4f; font-weight: 600; margin-bottom: 8px;">💡 Suggerimento per l'analisi</p>
                    <p style="color: #666; font-size: 13px; margin: 0; line-height: 1.6;">
                        Osserva il <strong>Peak Frequency</strong> visualizzato in alto a destra: ti indica quale frequenza è dominante in ogni momento.
                        Confronta questa informazione con i pattern visivi per identificare le sorgenti sonore nel tuo soundscape!
                    </p>
                </div>
            </div>

            <!-- Footer -->
            <div class="section-footer">
                <div class="footer-buttons">
                    <a href="#" onclick="shareApp('whatsapp'); return false;" class="footer-btn whatsapp">
                        📱 Condividi su WhatsApp
                    </a>
                    <a href="#" onclick="shareApp('facebook'); return false;" class="footer-btn facebook">
                        📘 Condividi su Facebook
                    </a>
                    <a href="https://www.paypal.com/paypalme/francescomariano" class="footer-btn paypal" target="_blank">
                        💰 Sostieni con Donazione
                    </a>
                    <a href="mailto:soundscapestudiopro@gmail.com?subject=Feedback%20Soundscape%20Studio" class="footer-btn feedback">
                        ✉️ Invia Feedback
                    </a>
                </div>
                <div class="footer-credits">
                    <p><strong>Ideato e sviluppato da Francesco Mariano</strong></p>
                    <p>Gruppo Apuano Sperimentale</p>
                </div>
            </div>
        </div>


    </div>

    <!-- Modal per Dettagli Marker -->
    <div class="modal" id="markerDetailsModal">
        <div class="modal-content" style="max-width: 600px;">
            <button class="modal-close" onclick="closeMarkerDetailsModal()">×</button>
            <div id="markerDetailsContent"></div>
        </div>
    </div>

    <!-- Modal per Esercizi -->
    <div class="modal" id="exerciseModal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeExerciseModal()">×</button>
            <div id="exerciseDetails"></div>
        </div>
    </div>

    <!-- Modal per Completamento Esercizio -->
    <div class="modal" id="completeExerciseModal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeCompleteExerciseModal()">×</button>
            <div id="completeExerciseContent">
                <h2 style="color: #2d5f4f; margin-bottom: 20px;">📋 Completa il tuo Esercizio</h2>

                <!-- Riassunto Esercizio -->
                <div id="exerciseSummary" style="background: #f0f7f4; padding: 20px; border-radius: 12px; margin-bottom: 30px; border-left: 4px solid #2d5f4f;">
                    <!-- Verrà popolato dinamicamente -->
                </div>

                <form id="exerciseCompletionForm" onsubmit="return saveExerciseCompletion(event)">

                    <!-- Sezione 1: Info Base -->
                    <div style="background: white; padding: 25px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #2d5f4f; margin-bottom: 20px;">📍 Informazioni Base</h3>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">📅 Data</label>
                                <input type="date" id="exerciseDate" required style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">⏰ Ora di inizio</label>
                                <input type="time" id="exerciseTime" required style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                            </div>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">📍 Nome del luogo (opzionale)</label>
                            <input type="text" id="exerciseLocation" placeholder="es. Parco della Musica, Roma" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                            <div id="geoStatus" style="margin-top: 8px; padding: 8px; background: #f0f7f4; border-radius: 6px; font-size: 13px; color: #2d5f4f;">
                                📍 Rilevamento GPS automatico in corso...
                            </div>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">⏱️ Durata effettiva</label>
                            <input type="text" id="exerciseDuration" placeholder="es. 15 minuti" required style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                        </div>
                    </div>

                    <!-- Sezione 2: Contesto Ambientale -->
                    <div style="background: white; padding: 25px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #2d5f4f; margin-bottom: 20px;">🌤️ Contesto Ambientale</h3>

                        <div style="margin-bottom: 20px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">Descrivi l'ambiente circostante</label>
                            <textarea id="environmentDescription" rows="3" placeholder="Descrivi l'ambiente, i suoni predominanti, l'atmosfera generale..." required style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; resize: vertical;"></textarea>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">☀️ Condizioni meteo</label>
                                <select id="weatherConditions" required style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                                    <option value="">Seleziona...</option>
                                    <option value="soleggiato">☀️ Soleggiato</option>
                                    <option value="nuvoloso">☁️ Nuvoloso</option>
                                    <option value="piovoso">🌧️ Piovoso</option>
                                    <option value="ventoso">💨 Ventoso</option>
                                    <option value="nebbioso">🌫️ Nebbioso</option>
                                    <option value="neve">❄️ Neve</option>
                                </select>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">🔊 Livello di rumore</label>
                                <select id="noiseLevel" required style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                                    <option value="">Seleziona...</option>
                                    <option value="molto-silenzioso">🔇 Molto silenzioso</option>
                                    <option value="silenzioso">🔉 Silenzioso</option>
                                    <option value="moderato">🔊 Moderato</option>
                                    <option value="rumoroso">📢 Rumoroso</option>
                                    <option value="molto-rumoroso">📣 Molto rumoroso</option>
                                </select>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">👥 Eri da solo?</label>
                                <select id="alone" required style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                                    <option value="">Seleziona...</option>
                                    <option value="si">Sì, da solo</option>
                                    <option value="no">No, in compagnia</option>
                                </select>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">🚶 Eri fermo o ti spostavi?</label>
                                <select id="movement" required style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                                    <option value="">Seleziona...</option>
                                    <option value="fermo">Fermo</option>
                                    <option value="movimento">In movimento</option>
                                    <option value="entrambi">Entrambi</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Sezione 3: Strumenti e Registrazione -->
                    <div style="background: white; padding: 25px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #2d5f4f; margin-bottom: 20px;">🎙️ Strumenti e Registrazione</h3>

                        <div style="margin-bottom: 20px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">Che strumenti hai usato per registrare?</label>
                            <input type="text" id="recordingTools" placeholder="es. Zoom H5, microfono binaurale, smartphone..." style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 12px; color: #2d5f4f;">🎙️ Registrazione Audio</label>

                            <!-- Integrated Recorder -->
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 12px; border: 2px solid #e0e0e0;">
                                <p style="font-size: 13px; color: #666; margin-bottom: 12px;">Registra direttamente durante l'esercizio:</p>

                                <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
                                    <button type="button" id="startRecordingBtn" onclick="startExerciseRecording()" style="flex: 1; min-width: 120px; padding: 12px; background: #d32f2f; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                        ⏺️ Inizia Registrazione
                                    </button>
                                    <button type="button" id="stopRecordingBtn" onclick="stopExerciseRecording()" disabled style="flex: 1; min-width: 120px; padding: 12px; background: #666; color: white; border: none; border-radius: 6px; cursor: not-allowed; font-weight: 600; font-size: 14px; display: flex; align-items: center; justify-content: center; gap: 6px;">
                                        ⏹️ Stop
                                    </button>
                                </div>

                                <div id="recordingStatus" style="display: none; padding: 10px; background: #ffebee; border-radius: 6px; text-align: center;">
                                    <span style="color: #d32f2f; font-weight: 600;">⏺️ Registrazione in corso...</span>
                                    <span id="recordingTimer" style="margin-left: 10px; font-family: monospace; color: #d32f2f; font-weight: 600;">00:00</span>
                                </div>

                                <div id="recordedAudiosList" style="margin-top: 12px;"></div>
                            </div>

                            <!-- File Upload (alternativa) -->
                            <div style="border-top: 1px dashed #ddd; padding-top: 12px;">
                                <p style="font-size: 13px; color: #666; margin-bottom: 8px;"><strong>Oppure</strong> carica file già esistenti:</p>
                                <input type="file" id="audioUpload" accept="audio/*" multiple style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                                <small style="color: #666; display: block; margin-top: 5px;">Puoi caricare più file audio</small>
                            </div>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">📸 Foto del luogo (opzionale)</label>
                            <input type="file" id="photoUpload" accept="image/*" multiple style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                        </div>

                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">🗺️ Vuoi aggiungere un segnaposto sulla mappa?</label>
                            <select id="addMapMarker" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                                <option value="no">No</option>
                                <option value="si">Sì, aggiungi alla mappa</option>
                            </select>
                        </div>
                    </div>

                    <!-- Sezione 4: Canvas per Disegno -->
                    <div style="background: white; padding: 25px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #2d5f4f; margin-bottom: 20px;">✏️ Disegna la tua analisi sonora</h3>
                        <p style="color: #666; margin-bottom: 15px;">Usa questo spazio per disegnare mappe sonore, direzioni, cerchi di ascolto, etc.</p>

                        <div style="margin-bottom: 15px;">
                            <button type="button" onclick="setDrawingTool('pen')" style="padding: 8px 16px; margin-right: 10px; background: #2d5f4f; color: white; border: none; border-radius: 6px; cursor: pointer;">🖊️ Penna</button>
                            <button type="button" onclick="setDrawingTool('eraser')" style="padding: 8px 16px; margin-right: 10px; background: #666; color: white; border: none; border-radius: 6px; cursor: pointer;">🧹 Gomma</button>
                            <button type="button" onclick="clearCanvas()" style="padding: 8px 16px; margin-right: 10px; background: #d9534f; color: white; border: none; border-radius: 6px; cursor: pointer;">🗑️ Cancella tutto</button>
                            <label style="margin-left: 10px;">
                                Colore: <input type="color" id="drawingColor" value="#2d5f4f" onchange="updateDrawingColor()" style="vertical-align: middle; cursor: pointer;">
                            </label>
                            <label style="margin-left: 10px;">
                                Spessore:
                                <select id="drawingThickness" onchange="updateDrawingThickness()" style="padding: 4px; border-radius: 4px;">
                                    <option value="2">Sottile</option>
                                    <option value="5" selected>Medio</option>
                                    <option value="10">Spesso</option>
                                    <option value="15">Molto spesso</option>
                                </select>
                            </label>
                        </div>

                        <canvas id="drawingCanvas" width="800" height="500" style="width: 100%; max-width: 100%; height: auto; border: 2px solid #e0e0e0; border-radius: 8px; background: white; cursor: crosshair; display: block; box-sizing: border-box; touch-action: none;"></canvas>
                    </div>

                    <!-- Sezione 5: Note e Considerazioni -->
                    <div style="background: white; padding: 25px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #2d5f4f; margin-bottom: 20px;">💭 Considerazioni e Note</h3>

                        <div style="margin-bottom: 20px; width: 100%; max-width: 100%; overflow: hidden; box-sizing: border-box;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">Cosa hai scoperto? Riflessioni personali</label>
                            <div style="width: 100%; max-width: 100%; overflow: hidden; box-sizing: border-box;">
                                <textarea id="personalNotes" placeholder="Descrivi la tua esperienza..." style="width: 100%; height: 120px; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 16px; resize: none; box-sizing: border-box; overflow-y: auto; overflow-x: hidden; font-family: -apple-system, BlinkMacSystemFont, sans-serif;"></textarea>
                            </div>
                        </div>

                        <div style="margin-bottom: 20px; width: 100%; max-width: 100%; overflow: hidden; box-sizing: border-box;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">🏷️ Tag (separa con virgole)</label>
                            <div style="width: 100%; max-width: 100%; overflow: hidden; box-sizing: border-box;">
                                <input type="text" id="exerciseTags" placeholder="es. urbano, natura, mattino" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 16px; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, sans-serif;">
                            </div>
                        </div>

                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2d5f4f;">⭐ Valuta la tua esperienza</label>
                            <div id="ratingStars" style="font-size: 32px; cursor: pointer;">
                                <span onclick="setRating(1)" data-rating="1">☆</span>
                                <span onclick="setRating(2)" data-rating="2">☆</span>
                                <span onclick="setRating(3)" data-rating="3">☆</span>
                                <span onclick="setRating(4)" data-rating="4">☆</span>
                                <span onclick="setRating(5)" data-rating="5">☆</span>
                            </div>
                            <input type="hidden" id="exerciseRating" value="0">
                        </div>
                    </div>

                    <!-- Bottoni Azione -->
                    <div style="display: flex; gap: 15px; justify-content: flex-end; margin-top: 30px;">
                        <button type="button" onclick="closeCompleteExerciseModal()" style="padding: 14px 28px; background: #999; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 15px;">
                            Annulla
                        </button>
                        <button type="submit" style="padding: 14px 28px; background: #2d5f4f; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 15px;">
                            💾 Salva Esercizio
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Modal per Visualizzare Esercizio Completato -->
    <div class="modal" id="viewCompletedExerciseModal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto; overflow-x: hidden; padding: 20px; box-sizing: border-box;">
            <button class="modal-close" onclick="closeViewCompletedModal()">×</button>
            <div id="viewCompletedContent" style="width: 100%; overflow-x: hidden; word-wrap: break-word;">
                <!-- Verrà popolato dinamicamente -->
            </div>
        </div>
    </div>

    <!-- Modal per Reference Guides -->
    <div class="reference-modal" id="referenceModal" onclick="if(event.target === this) closeReferenceModal()">
        <div class="reference-modal-content">
            <span class="reference-modal-close" onclick="closeReferenceModal()">×</span>
            <div id="referenceContent">
                <!-- Verrà popolato dinamicamente -->
            </div>
        </div>
    </div>

    <!-- Load Complete Exercise Database -->
    <script src="exercises-complete.js"></script>

    <script>
        // ==================== INDEXEDDB SETUP ====================
        let db;
        const DB_NAME = 'SoundscapeStudioDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'completedExercises';

        // Inizializza IndexedDB
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => {
                    console.error('Errore apertura database:', request.error);
                    reject(request.error);
                };

                request.onsuccess = () => {
                    db = request.result;
                    console.log('✅ Database IndexedDB aperto con successo');
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    db = event.target.result;

                    // Crea object store se non esiste
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const objectStore = db.createObjectStore(STORE_NAME, {
                            keyPath: 'id',
                            autoIncrement: true
                        });

                        // Crea indici per query più veloci
                        objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                        objectStore.createIndex('exerciseTitle', 'exercise.title', { unique: false });
                        objectStore.createIndex('date', 'date', { unique: false });

                        console.log('✅ Object store creato');
                    }
                };
            });
        }

        // Salva esercizio in IndexedDB con file audio e foto
        async function saveExerciseToIndexedDB(exerciseData) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);

                const request = objectStore.add(exerciseData);

                request.onsuccess = () => {
                    console.log('✅ Esercizio salvato con ID:', request.result);
                    resolve(request.result);
                };

                request.onerror = () => {
                    console.error('❌ Errore salvataggio:', request.error);
                    reject(request.error);
                };
            });
        }

        // Recupera tutti gli esercizi
        async function getAllExercisesFromIndexedDB() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.getAll();

                request.onsuccess = () => {
                    resolve(request.result || []);
                };

                request.onerror = () => {
                    console.error('❌ Errore recupero esercizi:', request.error);
                    reject(request.error);
                };
            });
        }

        // Recupera singolo esercizio per ID
        async function getExerciseFromIndexedDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.get(id);

                request.onsuccess = () => {
                    resolve(request.result);
                };

                request.onerror = () => {
                    console.error('❌ Errore recupero esercizio:', request.error);
                    reject(request.error);
                };
            });
        }

        // Elimina esercizio
        async function deleteExerciseFromIndexedDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.delete(id);

                request.onsuccess = () => {
                    console.log('✅ Esercizio eliminato');
                    resolve();
                };

                request.onerror = () => {
                    console.error('❌ Errore eliminazione:', request.error);
                    reject(request.error);
                };
            });
        }

        // Elimina tutti gli esercizi
        async function clearAllExercisesFromIndexedDB() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.clear();

                request.onsuccess = () => {
                    console.log('✅ Tutti gli esercizi eliminati');
                    resolve();
                };

                request.onerror = () => {
                    console.error('❌ Errore pulizia database:', request.error);
                    reject(request.error);
                };
            });
        }

        // Converte File in Blob per salvare in IndexedDB
        async function fileToBlob(file) {
            return new Promise((resolve, reject) => {
                if (!file) {
                    resolve(null);
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    resolve({
                        data: e.target.result,
                        name: file.name,
                        type: file.type,
                        size: file.size
                    });
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Converte FileList in array di Blob
        async function filesToBlobs(fileList) {
            if (!fileList || fileList.length === 0) return [];

            const promises = Array.from(fileList).map(file => fileToBlob(file));
            return Promise.all(promises);
        }

        // ==================== NAVIGATION ====================
        function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-button').forEach(b => b.classList.remove('active'));

            // Show selected section
            document.getElementById(sectionId).classList.add('active');

            // Attiva il pulsante corrispondente (se chiamato da un click)
            if (typeof event !== 'undefined' && event.target) {
                event.target.classList.add('active');
            } else {
                // Se chiamato programmaticamente, trova il pulsante corrispondente
                const btn = document.querySelector(`[onclick*="showSection('${sectionId}')"]`);
                if (btn) btn.classList.add('active');
            }

            // Initialize toolkit equipment tabs when first opened
            if (sectionId === 'toolkit') {
                setTimeout(() => {
                    if (window.initializeToolkit) {
                        window.initializeToolkit();
                    }
                }, 100);
            }

            // Initialize library when first opened
            if (sectionId === 'library') {
                setTimeout(() => {
                    if (window.initializeLibrary) {
                        window.initializeLibrary();
                    }
                }, 100);
            }

            // Refresh spectrogram audio list when opened
            if (sectionId === 'spectrogram') {
                setTimeout(() => {
                    if (window.loadSpectrogramAudioList) {
                        window.loadSpectrogramAudioList();
                    }
                }, 100);
            }
        }

        // Funzione dedicata per mostrare la sezione mappa
        function showMapSection() {
            // Hide all sections
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-button').forEach(b => b.classList.remove('active'));

            // Show map section
            document.getElementById('map').classList.add('active');
            event.target.classList.add('active');

            // Initialize map after a brief delay to ensure DOM is ready
            setTimeout(() => {
                initializeSoundscapeMap();
            }, 200);
        }

        // ==================== GLOBAL FUNCTION DECLARATIONS ====================
        // These are declared early so onclick handlers can find them

        window.showReferenceModal = function(type) {
            console.log('showReferenceModal called with type:', type);
        };

        window.closeReferenceModal = function() {
            console.log('closeReferenceModal called');
        };

        window.showEquipmentTab = function(category) {
            console.log('showEquipmentTab called with category:', category);
        };

        window.showLibraryTab = function(category) {
            console.log('showLibraryTab called with category:', category);
        };

        window.initializeToolkit = function() {
            console.log('initializeToolkit called');
        };

        window.initializeLibrary = function() {
            console.log('initializeLibrary called');
        };

        // ==================== SPETTROGRAMMA ====================
        // Codice spettrogramma rimosso (sezione HTML rimossa)

        /* SPETTROGRAMMA CODE - COMMENTED OUT
        let audioContext;
        let analyser;
        let dataArray;
        let bufferLength;
        let canvas;
        let canvasCtx;
        let animationId;
        let microphone;
        let audioElement;
        let sourceNode;

        function initSpectrogram() {
            canvas = document.getElementById('spectrogramCanvas');
            canvasCtx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = 300;

            // Initialize audio context
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
        }

        // Start Microphone
        const startMicBtn = document.getElementById('startMicBtn');
        if (startMicBtn) {
        startMicBtn.addEventListener('click', async () => {
            if (!audioContext) initSpectrogram();

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                document.getElementById('startMicBtn').style.display = 'none';
                document.getElementById('stopMicBtn').style.display = 'inline-block';

                drawSpectrogram();
            } catch (err) {
                alert('Errore accesso microfono: ' + err.message);
            }
        });

        // Stop Microphone
        document.getElementById('stopMicBtn').addEventListener('click', () => {
            if (microphone) {
                microphone.disconnect();
                microphone.mediaStream.getTracks().forEach(track => track.stop());
                microphone = null;
            }

            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            document.getElementById('startMicBtn').style.display = 'inline-block';
            document.getElementById('stopMicBtn').style.display = 'none';

            // Clear canvas
            canvasCtx.fillStyle = '#000';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
        });

        // Load Audio File
        document.getElementById('audioFileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (!audioContext) initSpectrogram();

            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

            // Create audio element for playback
            audioElement = new Audio(URL.createObjectURL(file));

            document.getElementById('playAudioBtn').style.display = 'inline-block';
            document.getElementById('pauseAudioBtn').style.display = 'none';
        });

        // Play Audio
        document.getElementById('playAudioBtn').addEventListener('click', () => {
            if (!audioElement) return;

            if (!sourceNode) {
                sourceNode = audioContext.createMediaElementSource(audioElement);
                sourceNode.connect(analyser);
                analyser.connect(audioContext.destination);
            }

            audioElement.play();
            document.getElementById('playAudioBtn').style.display = 'none';
            document.getElementById('pauseAudioBtn').style.display = 'inline-block';

            drawSpectrogram();
        });

        // Pause Audio
        document.getElementById('pauseAudioBtn').addEventListener('click', () => {
            if (audioElement) {
                audioElement.pause();
                document.getElementById('playAudioBtn').style.display = 'inline-block';
                document.getElementById('pauseAudioBtn').style.display = 'none';
            }
        });

        // Draw Spectrogram
        function drawSpectrogram() {
            animationId = requestAnimationFrame(drawSpectrogram);

            analyser.getByteFrequencyData(dataArray);

            // Shift canvas left
            const imageData = canvasCtx.getImageData(1, 0, canvas.width - 1, canvas.height);
            canvasCtx.putImageData(imageData, 0, 0);

            // Draw new column
            for (let i = 0; i < bufferLength; i++) {
                const value = dataArray[i];
                const y = canvas.height - (i / bufferLength) * canvas.height;

                // Color mapping (black -> blue -> green -> yellow -> red)
                let r, g, b;
                if (value < 64) {
                    r = 0; g = 0; b = value * 4;
                } else if (value < 128) {
                    r = 0; g = (value - 64) * 4; b = 255;
                } else if (value < 192) {
                    r = (value - 128) * 4; g = 255; b = 255 - (value - 128) * 4;
                } else {
                    r = 255; g = 255 - (value - 192) * 4; b = 0;
                }

                canvasCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                canvasCtx.fillRect(canvas.width - 1, y, 1, canvas.height / bufferLength);
            }

            // Update info
            const maxIndex = dataArray.indexOf(Math.max(...dataArray));
            const frequency = Math.round((maxIndex / bufferLength) * (audioContext.sampleRate / 2));
            const avgLevel = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const dB = 20 * Math.log10(avgLevel / 255);

            document.getElementById('freqInfo').textContent = `Frequenza dominante: ${frequency} Hz`;
            document.getElementById('dbInfo').textContent = `Livello: ${dB.toFixed(1)} dB`;

            if (audioElement) {
                document.getElementById('timeInfo').textContent = `Tempo: ${audioElement.currentTime.toFixed(2)}s / ${audioElement.duration.toFixed(2)}s`;
            }
        }
        END OF SPETTROGRAMMA CODE */

        // ==================== ESERCIZI ====================
        // Convert fieldRecordingExercises object to flat array
        var exercises = [];
        if (typeof fieldRecordingExercises !== 'undefined') {
            Object.keys(fieldRecordingExercises).forEach(category => {
                fieldRecordingExercises[category].forEach(ex => {
                    exercises.push({
                        category: category,
                        title: ex.title,
                        description: ex.description,
                        prompt: ex.prompt,
                        duration: ex.duration,
                        examples: ex.examples,
                        level: 'Intermedio', // Default level
                        time: ex.duration
                    });
                });
            });
        }

        // State for filtering
        var currentCategoryFilter = 'all';
        var currentLevelFilter = 'all';

        async function loadExercises(filteredExercises = exercises) {
            const grid = document.getElementById('exerciseGrid');
            grid.innerHTML = ''; // Clear existing

            if (filteredExercises.length === 0) {
                grid.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: #666;">
                        <div style="font-size: 48px; margin-bottom: 20px;">🔍</div>
                        <p>Nessun esercizio trovato con questi filtri.</p>
                    </div>
                `;
                return;
            }

            // Ottieni tutti gli esercizi completati
            const completedExercises = await getAllExercisesFromIndexedDB();

            // Crea un Set con i titoli degli esercizi completati per ricerca veloce
            const completedTitles = new Set(
                completedExercises.map(ex => ex.exercise.title)
            );

            filteredExercises.forEach(ex => {
                const card = document.createElement('div');
                card.className = 'exercise-card';
                card.onclick = () => showExerciseDetail(ex);

                const isCompleted = completedTitles.has(ex.title);
                const completedBadge = isCompleted ?
                    `<span style="position: absolute; top: 10px; right: 10px; font-size: 24px; background: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">✅</span>` : '';

                card.innerHTML = `
                    ${completedBadge}
                    <span class="exercise-category cat-${ex.category}">${ex.category.toUpperCase()}</span>
                    <div class="exercise-title">${ex.title}</div>
                    <div class="exercise-meta">
                        📊 ${ex.level} | ⏱️ ${ex.time}
                    </div>
                `;

                grid.appendChild(card);
            });
        }

        function filterExercises(category) {
            currentCategoryFilter = category;
            applyFilters();

            // Update button states
            document.querySelectorAll('[data-filter]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-filter="${category}"]`).classList.add('active');
        }

        function filterByLevel(level) {
            currentLevelFilter = level;
            applyFilters();

            // Update button states
            document.querySelectorAll('[data-level]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-level="${level}"]`).classList.add('active');
        }

        async function applyFilters() {
            let filtered = exercises;

            // Apply category filter
            if (currentCategoryFilter !== 'all') {
                filtered = filtered.filter(ex => ex.category === currentCategoryFilter);
            }

            // Apply level filter
            if (currentLevelFilter !== 'all') {
                filtered = filtered.filter(ex => ex.level === currentLevelFilter);
            }

            await loadExercises(filtered);
        }

        function showExerciseDetail(exercise) {
            const modal = document.getElementById('exerciseModal');
            const details = document.getElementById('exerciseDetails');

            const examplesHTML = exercise.examples && exercise.examples.length > 0 ?
                `<div style="margin-top: 20px;">
                    <h3 style="color: #2d5f4f; margin-bottom: 10px;">💡 Esempi</h3>
                    <ul style="line-height: 2;">
                        ${exercise.examples.map(ex => `<li>${ex}</li>`).join('')}
                    </ul>
                </div>` : '';

            details.innerHTML = `
                <span class="exercise-category cat-${exercise.category}">${exercise.category.replace(/-/g, ' ').toUpperCase()}</span>
                <h2 style="margin: 15px 0; color: #2d5f4f;">${exercise.title}</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    <strong>Durata:</strong> ${exercise.time}
                </p>
                <div style="line-height: 1.8;">
                    <h3 style="color: #2d5f4f; margin-bottom: 10px;">📝 Descrizione</h3>
                    <p>${exercise.description}</p>

                    <h3 style="color: #2d5f4f; margin: 20px 0 10px 0;">🎯 Istruzioni</h3>
                    <p style="background: #f5f5f5; padding: 15px; border-radius: 8px; border-left: 4px solid #2d5f4f;">
                        ${exercise.prompt}
                    </p>

                    ${examplesHTML}
                </div>
                <button onclick="startExerciseCompletion()" style="margin-top: 20px; padding: 12px 24px; background: #2d5f4f; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    Inizia Esercizio
                </button>
            `;

            modal.classList.add('active');
        }

        function closeExerciseModal() {
            document.getElementById('exerciseModal').classList.remove('active');
        }

        // ==================== EXERCISE COMPLETION FUNCTIONS ====================
        var currentExercise = null;
        var drawingCanvas = null;
        var drawingCtx = null;
        var isDrawing = false;
        var currentTool = 'pen';
        var currentColor = '#2d5f4f';
        var currentThickness = 5;

        function startExerciseCompletion() {
            // Salva l'esercizio corrente
            const exerciseTitle = document.querySelector('#exerciseDetails h2').textContent;
            const exerciseCategory = document.querySelector('#exerciseDetails .exercise-category').textContent;
            const exerciseDescription = document.querySelector('#exerciseDetails p:nth-of-type(2)').textContent;
            const exercisePrompt = document.querySelector('#exerciseDetails p[style*="background"]').textContent;

            currentExercise = {
                title: exerciseTitle,
                category: exerciseCategory,
                description: exerciseDescription,
                prompt: exercisePrompt
            };

            // Chiudi il modal degli esercizi
            closeExerciseModal();

            // Popola il riassunto
            document.getElementById('exerciseSummary').innerHTML = `
                <h3 style="color: #2d5f4f; margin-bottom: 10px;">${currentExercise.title}</h3>
                <p style="margin-bottom: 15px;"><strong>Categoria:</strong> ${currentExercise.category}</p>
                <p style="margin-bottom: 15px;"><strong>Descrizione:</strong> ${currentExercise.description}</p>
                <div style="background: white; padding: 15px; border-radius: 8px; border-left: 3px solid #4a9d7f;">
                    <strong>Passaggi chiave:</strong><br>
                    ${currentExercise.prompt}
                </div>
            `;

            // Imposta data e ora correnti
            const now = new Date();
            document.getElementById('exerciseDate').valueAsDate = now;
            document.getElementById('exerciseTime').value = now.toTimeString().slice(0,5);

            // Reset form
            document.getElementById('exerciseCompletionForm').reset();
            document.getElementById('exerciseDate').valueAsDate = now;
            document.getElementById('exerciseTime').value = now.toTimeString().slice(0,5);
            document.getElementById('exerciseRating').value = '0';

            // Reset stelle
            document.querySelectorAll('#ratingStars span').forEach(star => {
                star.textContent = '☆';
            });

            // Apri il modal di completamento
            document.getElementById('completeExerciseModal').classList.add('active');

            // Inizializza il canvas
            setTimeout(() => {
                initDrawingCanvas();
            }, 100);

            // Auto-rileva GPS automaticamente
            autoDetectGeolocation();
        }

        function closeCompleteExerciseModal() {
            document.getElementById('completeExerciseModal').classList.remove('active');
            currentExercise = null;

            // Reset recorded audios
            exerciseRecordedAudios = [];
            displayRecordedAudios();

            // Reset recorder UI
            document.getElementById('startRecordingBtn').disabled = false;
            document.getElementById('startRecordingBtn').style.background = '#d32f2f';
            document.getElementById('startRecordingBtn').style.cursor = 'pointer';
            document.getElementById('stopRecordingBtn').disabled = true;
            document.getElementById('stopRecordingBtn').style.background = '#666';
            document.getElementById('stopRecordingBtn').style.cursor = 'not-allowed';
            document.getElementById('recordingStatus').style.display = 'none';
            document.getElementById('recordingTimer').textContent = '00:00';

            // Stop any active recording
            if (exerciseMediaRecorder && exerciseMediaRecorder.state !== 'inactive') {
                exerciseMediaRecorder.stop();
                clearInterval(exerciseRecordingTimer);
            }
        }

        function initDrawingCanvas() {
            drawingCanvas = document.getElementById('drawingCanvas');
            if (!drawingCanvas) return;

            drawingCtx = drawingCanvas.getContext('2d');
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';

            // Clear canvas
            drawingCtx.fillStyle = 'white';
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);

            // Mouse events
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', stopDrawing);
            drawingCanvas.addEventListener('mouseout', stopDrawing);

            // Touch events for mobile
            drawingCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                drawingCanvas.dispatchEvent(mouseEvent);
            });

            drawingCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                drawingCanvas.dispatchEvent(mouseEvent);
            });

            drawingCanvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                const mouseEvent = new MouseEvent('mouseup', {});
                drawingCanvas.dispatchEvent(mouseEvent);
            });
        }

        function startDrawing(e) {
            isDrawing = true;
            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            drawingCtx.beginPath();
            drawingCtx.moveTo(x, y);
        }

        function draw(e) {
            if (!isDrawing) return;

            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (currentTool === 'pen') {
                drawingCtx.strokeStyle = currentColor;
                drawingCtx.lineWidth = currentThickness;
                drawingCtx.globalCompositeOperation = 'source-over';
            } else if (currentTool === 'eraser') {
                drawingCtx.strokeStyle = 'white';
                drawingCtx.lineWidth = currentThickness * 3;
                drawingCtx.globalCompositeOperation = 'destination-out';
            }

            drawingCtx.lineTo(x, y);
            drawingCtx.stroke();
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function setDrawingTool(tool) {
            currentTool = tool;
        }

        function clearCanvas() {
            if (!drawingCtx || !drawingCanvas) return;
            drawingCtx.fillStyle = 'white';
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        }

        function updateDrawingColor() {
            currentColor = document.getElementById('drawingColor').value;
        }

        function updateDrawingThickness() {
            currentThickness = parseInt(document.getElementById('drawingThickness').value);
        }

        // Auto-rileva GPS all'apertura del modal
        function autoDetectGeolocation() {
            const statusEl = document.getElementById('geoStatus');
            const locationInput = document.getElementById('exerciseLocation');

            if (!navigator.geolocation) {
                console.warn('❌ Geolocation not supported');
                statusEl.innerHTML = '❌ Geolocalizzazione non supportata - usando coordinate di default';
                statusEl.style.background = '#ffe0e0';
                statusEl.style.color = '#d32f2f';
                // Usa centro mappa come fallback IMMEDIATAMENTE
                useFallbackCoordinates();
                return;
            }

            // IMPORTANTE: Imposta fallback SUBITO, poi prova GPS
            // Questo garantisce che ci siano SEMPRE coordinate
            useFallbackCoordinates();
            console.log('📍 Fallback coordinates set immediately');

            statusEl.innerHTML = '🔄 Rilevamento GPS automatico in corso...';
            statusEl.style.background = '#fff9e6';
            statusEl.style.color = '#f57c00';

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude.toFixed(6);
                    const lon = position.coords.longitude.toFixed(6);

                    // Sovrascrivi fallback con GPS reale
                    locationInput.dataset.lat = lat;
                    locationInput.dataset.lon = lon;

                    statusEl.innerHTML = `✅ GPS rilevato: ${lat}, ${lon}`;
                    statusEl.style.background = '#e8f5e9';
                    statusEl.style.color = '#2e7d32';

                    console.log('✅ GPS auto-detected:', lat, lon);
                },
                (error) => {
                    console.warn('⚠️ GPS auto-detection failed:', error);
                    statusEl.innerHTML = '⚠️ GPS non disponibile - usando posizione di default';
                    statusEl.style.background = '#fff3e0';
                    statusEl.style.color = '#e65100';

                    // Fallback già impostato all'inizio
                    console.log('📍 Using fallback coordinates already set');
                },
                {
                    enableHighAccuracy: true,
                    timeout: 5000,  // Ridotto a 5 secondi
                    maximumAge: 0
                }
            );
        }

        // Usa centro mappa attuale come fallback se GPS non disponibile
        function useFallbackCoordinates() {
            const locationInput = document.getElementById('exerciseLocation');

            if (leafletMap) {
                const center = leafletMap.getCenter();
                const lat = center.lat.toFixed(6);
                const lon = center.lng.toFixed(6);

                locationInput.dataset.lat = lat;
                locationInput.dataset.lon = lon;

                console.log('📍 Using map center as fallback:', lat, lon);
            } else {
                // Fallback assoluto: Roma, centro Italia
                locationInput.dataset.lat = '41.902782';
                locationInput.dataset.lon = '12.496366';
                console.log('📍 Using default coordinates (Rome)');
            }
        }

        // Funzione legacy mantenuta per compatibilità (non più usata nell'UI)
        function getGeolocation() {
            autoDetectGeolocation();
        }

        function setRating(rating) {
            document.getElementById('exerciseRating').value = rating;

            // Aggiorna stelle visivamente
            document.querySelectorAll('#ratingStars span').forEach((star, index) => {
                if (index < rating) {
                    star.textContent = '★';
                } else {
                    star.textContent = '☆';
                }
            });
        }

        async function saveExerciseCompletion(event) {
            event.preventDefault();

            // Mostra loading
            const submitBtn = event.target.querySelector('button[type="submit"]');
            const originalText = submitBtn.innerHTML;
            submitBtn.innerHTML = '⏳ Salvataggio in corso...';
            submitBtn.disabled = true;

            try {
                // Converti i file audio e foto in Blob
                const audioFiles = document.getElementById('audioUpload').files;
                const photoFiles = document.getElementById('photoUpload').files;

                // NO LIMITS in free version - all data is unlimited
                // Premium offers export and backup features instead

                const audioBlobs = await filesToBlobs(audioFiles);
                const photoBlobs = await filesToBlobs(photoFiles);

                // Combine recorded audios with uploaded files
                const recordedBlobs = exerciseRecordedAudios.map(audio => audio.blob);
                const allAudioBlobs = [...recordedBlobs, ...audioBlobs];

                // Raccogli tutti i dati inclusi audio e foto
                const completionData = {
                    exercise: currentExercise,
                    date: document.getElementById('exerciseDate').value,
                    time: document.getElementById('exerciseTime').value,
                    location: document.getElementById('exerciseLocation').value,
                    locationCoords: {
                        lat: document.getElementById('exerciseLocation').dataset.lat || null,
                        lon: document.getElementById('exerciseLocation').dataset.lon || null
                    },
                    duration: document.getElementById('exerciseDuration').value,
                    environment: document.getElementById('environmentDescription').value,
                    weather: document.getElementById('weatherConditions').value,
                    noiseLevel: document.getElementById('noiseLevel').value,
                    alone: document.getElementById('alone').value,
                    movement: document.getElementById('movement').value,
                    recordingTools: document.getElementById('recordingTools').value,
                    notes: document.getElementById('personalNotes').value,
                    tags: document.getElementById('exerciseTags').value,
                    rating: document.getElementById('exerciseRating').value,
                    addMapMarker: document.getElementById('addMapMarker').value,
                    drawing: drawingCanvas ? drawingCanvas.toDataURL() : null,
                    audioFiles: allAudioBlobs,  // Array di file audio (registrati + caricati)
                    photoFiles: photoBlobs,  // Array di foto
                    timestamp: new Date().toISOString()
                };

                // Salva in IndexedDB e ottieni l'ID generato
                const exerciseId = await saveExerciseToIndexedDB(completionData);

                // Se richiesto, aggiungi marker alla mappa
                // Le coordinate sono SEMPRE disponibili (GPS auto-rilevato o fallback)
                console.log('🗺️ addMapMarker value:', completionData.addMapMarker);
                console.log('🗺️ locationCoords:', completionData.locationCoords);

                if (completionData.addMapMarker === 'si') {
                    console.log('✅ User requested map marker, adding...');
                    try {
                        // Assicura che ci siano coordinate (fallback se mancanti)
                        if (!completionData.locationCoords.lat) {
                            console.warn('⚠️ No GPS coordinates, using fallback...');
                            completionData.locationCoords.lat = leafletMap ? leafletMap.getCenter().lat.toFixed(6) : '41.902782';
                            completionData.locationCoords.lon = leafletMap ? leafletMap.getCenter().lng.toFixed(6) : '12.496366';
                            console.log('📍 Using fallback coordinates for marker:', completionData.locationCoords);
                        }

                        console.log('📍 Calling addExerciseMarkerToMap with:', {
                            exerciseId,
                            coords: completionData.locationCoords,
                            audioFiles: completionData.audioFiles.length
                        });

                        await addExerciseMarkerToMap(completionData, exerciseId);
                        console.log('✅ Marker aggiunto alla mappa:', completionData.locationCoords);
                    } catch (error) {
                        console.error('❌ Errore aggiunta marker:', error);
                        alert('⚠️ Errore durante l\'aggiunta del marker alla mappa: ' + error.message);
                    }
                } else {
                    console.log('ℹ️ User did NOT request map marker (value: ' + completionData.addMapMarker + ')');
                }

                // Reset recorded audios array for next exercise
                exerciseRecordedAudios = [];

                // Aggiorna counter esercizi completati
                await updateCompletedExercisesCounter();

                // Ricarica gli esercizi per mostrare la spunta verde
                await applyFilters();

                // Reset button state BEFORE closing modal (button reference still valid)
                submitBtn.innerHTML = originalText;
                submitBtn.disabled = false;

                // Chiudi modal
                closeCompleteExerciseModal();

                // Mostra conferma
                alert('✅ Esercizio salvato con successo!\n\n' +
                      `Audio salvati: ${allAudioBlobs.length}\n` +
                      `Foto salvate: ${photoBlobs.length}\n\n` +
                      'Trovi tutti i tuoi esercizi completati nella sezione Dashboard.');

            } catch (error) {
                console.error('Errore salvataggio:', error);
                alert('❌ Errore durante il salvataggio!\n\n' + error.message);
                submitBtn.innerHTML = originalText;
                submitBtn.disabled = false;
            }

            return false;
        }

        async function updateCompletedExercisesCounter() {
            try {
                const savedExercises = await getAllExercisesFromIndexedDB();
                const counters = document.querySelectorAll('[style*="Esercizi completati"]');
                counters.forEach(counter => {
                    counter.textContent = `Esercizi completati: ${savedExercises.length}/96`;
                });

                // Aggiorna anche la lista nella Dashboard
                await loadCompletedExercisesList();
            } catch (error) {
                console.error('Errore aggiornamento counter:', error);
            }
        }

        // ==================== VISUALIZZAZIONE ESERCIZI COMPLETATI ====================

        async function loadCompletedExercisesList() {
            const listContainer = document.getElementById('completedExercisesList');
            if (!listContainer) return;

            try {
                const savedExercises = await getAllExercisesFromIndexedDB();

                if (savedExercises.length === 0) {
                    listContainer.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #999;">
                            <div style="font-size: 48px; margin-bottom: 15px;">📭</div>
                            <p>Non hai ancora completato nessun esercizio.</p>
                            <p style="font-size: 14px; margin-top: 10px;">Inizia un esercizio e documenta la tua esperienza!</p>
                        </div>
                    `;
                    return;
                }

                // Mostra gli ultimi 5 esercizi
                const recentExercises = savedExercises.slice(-5).reverse();

                listContainer.innerHTML = recentExercises.map((ex) => {
                    const date = new Date(ex.timestamp);
                    const dateStr = date.toLocaleDateString('it-IT', { day: '2-digit', month: 'short', year: 'numeric' });
                    const timeStr = ex.time || date.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });

                    // Badge per audio e foto
                    const badges = [];
                    if (ex.audioFiles && ex.audioFiles.length > 0) {
                        badges.push(`🎵 ${ex.audioFiles.length}`);
                    }
                    if (ex.photoFiles && ex.photoFiles.length > 0) {
                        badges.push(`📷 ${ex.photoFiles.length}`);
                    }

                    return `
                        <div onclick="viewCompletedExercise(${ex.id})" style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s; border-left: 4px solid #2d5f4f; box-sizing: border-box; max-width: 100%; overflow: hidden;" onmouseover="this.style.background='#f0f7f4'" onmouseout="this.style.background='#f9f9f9'">
                            <div style="display: flex; justify-content: space-between; align-items: start; gap: 10px;">
                                <div style="flex: 1; min-width: 0;">
                                    <h4 style="margin: 0 0 8px 0; color: #2d5f4f; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${ex.exercise.title}</h4>
                                    <div style="font-size: 13px; color: #666; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                        <span>📅 ${dateStr}</span> •
                                        <span>⏰ ${timeStr}</span> •
                                        <span>📍 ${ex.location}</span>
                                    </div>
                                    ${badges.length > 0 ? `<div style="margin-top: 5px; font-size: 12px; color: #4a9d7f;">${badges.join(' • ')}</div>` : ''}
                                    ${ex.rating > 0 ? `<div style="margin-top: 5px; color: #f39c12;">${'★'.repeat(parseInt(ex.rating))}</div>` : ''}
                                </div>
                                <div style="font-size: 24px;">👁️</div>
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                console.error('Errore caricamento lista:', error);
                listContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #d9534f;">
                        <div style="font-size: 48px; margin-bottom: 15px;">❌</div>
                        <p>Errore caricamento esercizi</p>
                    </div>
                `;
            }
        }

        async function showAllCompletedExercises() {
            try {
                const savedExercises = await getAllExercisesFromIndexedDB();

                if (savedExercises.length === 0) {
                    alert('Non hai ancora completato nessun esercizio!');
                return;
            }

            const modal = document.getElementById('viewCompletedExerciseModal');
            const content = document.getElementById('viewCompletedContent');

            content.innerHTML = `
                <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                    <h2 style="color: #2d5f4f; margin: 0;">📋 Tutti gli Esercizi Completati (${savedExercises.length})</h2>
                    <button onclick="closeViewCompletedModal()" style="padding: 10px 20px; background: #2d5f4f; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; white-space: nowrap;">
                        ← Torna alla Dashboard
                    </button>
                </div>

                <div style="margin-bottom: 20px; margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="exportCompleteBackup()" style="padding: 10px 20px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                        💾 Backup Completo ⭐
                    </button>
                    <button onclick="importCompleteBackup()" style="padding: 10px 20px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                        📂 Ripristina Backup ⭐
                    </button>
                    <button onclick="exportAllExercises()" style="padding: 10px 20px; background: #4a9d7f; color: white; border: none; border-radius: 6px; cursor: pointer;">
                        📥 Esporta Esercizi (JSON)
                    </button>
                    <button onclick="clearAllExercises()" style="padding: 10px 20px; background: #d9534f; color: white; border: none; border-radius: 6px; cursor: pointer;">
                        🗑️ Elimina Tutto
                    </button>
                </div>

                <div style="max-height: 500px; overflow-y: auto; overflow-x: hidden; width: 100%;">
                    ${savedExercises.map((ex) => {
                        const date = new Date(ex.timestamp);
                        const dateStr = date.toLocaleDateString('it-IT', { day: '2-digit', month: 'long', year: 'numeric' });
                        const timeStr = ex.time || date.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });

                        // Badge per audio e foto
                        const badges = [];
                        if (ex.audioFiles && ex.audioFiles.length > 0) {
                            badges.push(`🎵 ${ex.audioFiles.length} audio`);
                        }
                        if (ex.photoFiles && ex.photoFiles.length > 0) {
                            badges.push(`📷 ${ex.photoFiles.length} foto`);
                        }

                        return `
                            <div onclick="viewCompletedExercise(${ex.id})" style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 15px; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.1); transition: all 0.2s; box-sizing: border-box; max-width: 100%; overflow: hidden;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)'" onmouseout="this.style.transform=''; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.1)'">
                                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                    <div style="flex: 1;">
                                        <span style="display: inline-block; background: #2d5f4f; color: white; padding: 4px 10px; border-radius: 4px; font-size: 11px; margin-bottom: 8px;">${ex.exercise.category}</span>
                                        <h3 style="margin: 5px 0; color: #2d5f4f;">${ex.exercise.title}</h3>
                                    </div>
                                    ${ex.rating > 0 ? `<div style="font-size: 20px; color: #f39c12;">${'★'.repeat(parseInt(ex.rating))}</div>` : ''}
                                </div>
                                <div style="font-size: 14px; color: #666; line-height: 1.8;">
                                    <div><strong>📅 Data:</strong> ${dateStr} alle ${timeStr}</div>
                                    <div><strong>📍 Luogo:</strong> ${ex.location}</div>
                                    <div><strong>⏱️ Durata:</strong> ${ex.duration}</div>
                                    <div><strong>☀️ Meteo:</strong> ${ex.weather}</div>
                                </div>
                                ${badges.length > 0 ? `<div style="margin-top: 10px; padding: 8px; background: #f0f7f4; border-radius: 6px; font-size: 13px; color: #2d5f4f; font-weight: 600;">${badges.join(' • ')}</div>` : ''}
                                ${ex.tags ? `<div style="margin-top: 10px;">${ex.tags.split(',').map(tag => `<span style="background: #e0f2f7; color: #2d5f4f; padding: 3px 8px; border-radius: 4px; font-size: 12px; margin-right: 5px;">${tag.trim()}</span>`).join('')}</div>` : ''}
                                <div style="margin-top: 10px; text-align: right; color: #4a9d7f; font-weight: 600;">Clicca per vedere dettagli →</div>
                            </div>
                        `;
                    }).reverse().join('')}
                </div>
            `;

                modal.classList.add('active');
            } catch (error) {
                console.error('Errore visualizzazione esercizi:', error);
                alert('❌ Errore durante il caricamento degli esercizi!');
            }
        }

        async function viewCompletedExercise(id) {
            try {
                const ex = await getExerciseFromIndexedDB(id);

                if (!ex) {
                    alert('❌ Esercizio non trovato!');
                    return;
                }

                const modal = document.getElementById('viewCompletedExerciseModal');
                const content = document.getElementById('viewCompletedContent');

                const date = new Date(ex.timestamp);
                const dateStr = date.toLocaleDateString('it-IT', { day: '2-digit', month: 'long', year: 'numeric' });
                const timeStr = ex.time || date.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });

                // HTML per audio files
                var audioHTML = '';
                if (ex.audioFiles && ex.audioFiles.length > 0) {
                    // Convert audio blobs to URLs
                    const audioURLs = ex.audioFiles.map((audioBlob, idx) => {
                        // Create object URL from blob
                        const url = URL.createObjectURL(audioBlob);
                        return {
                            url: url,
                            name: `Audio ${idx + 1}`,
                            type: audioBlob.type || 'audio/webm'
                        };
                    });

                    audioHTML = `
                        <div style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <h3 style="color: #2d5f4f; margin-bottom: 15px;">🎵 Registrazioni Audio (${ex.audioFiles.length})</h3>
                            ${audioURLs.map((audio, idx) => `
                                <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                                    <div style="margin-bottom: 10px; font-weight: 600; color: #2d5f4f;">
                                        ${audio.name}
                                    </div>
                                    <audio controls style="width: 100%; margin-bottom: 10px;">
                                        <source src="${audio.url}" type="${audio.type}">
                                        Il tuo browser non supporta l'audio HTML5.
                                    </audio>
                                    <button onclick="downloadAudio(${ex.id}, ${idx})" style="padding: 6px 12px; background: #4a9d7f; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">
                                        📥 Scarica Audio
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                // HTML per photo files
                var photoHTML = '';
                if (ex.photoFiles && ex.photoFiles.length > 0) {
                    // Convert photo blobs to URLs
                    const photoURLs = ex.photoFiles.map((photoBlob, idx) => {
                        // Create object URL from blob
                        const url = URL.createObjectURL(photoBlob);
                        return {
                            url: url,
                            name: `Foto ${idx + 1}`
                        };
                    });

                    photoHTML = `
                        <div style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 100%; overflow: hidden; box-sizing: border-box;">
                            <h3 style="color: #2d5f4f; margin-bottom: 15px;">📷 Foto del Luogo (${ex.photoFiles.length})</h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(min(150px, 100%), 1fr)); gap: 15px; width: 100%;">
                                ${photoURLs.map((photo, idx) => `
                                    <div style="background: #f9f9f9; padding: 10px; border-radius: 8px; box-sizing: border-box; max-width: 100%;">
                                        <img src="${photo.url}"
                                             onclick="viewFullImage('${photo.url.replace(/'/g, "\\'")}', '${photo.name.replace(/'/g, "\\'")}')"
                                             style="width: 100%; height: 150px; object-fit: cover; border-radius: 6px; cursor: pointer; margin-bottom: 8px; max-width: 100%;"
                                             alt="${photo.name}">
                                        <button onclick="downloadPhoto(${ex.id}, ${idx})" style="width: 100%; padding: 6px; background: #4a9d7f; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; box-sizing: border-box;">
                                            📤 Salva/Condividi
                                        </button>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                content.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <button onclick="showAllCompletedExercises()" style="padding: 8px 16px; background: #999; color: white; border: none; border-radius: 6px; cursor: pointer; margin-bottom: 15px;">
                            ← Torna alla lista
                        </button>
                        <button onclick="exportExerciseToWord(${ex.id})" style="padding: 8px 16px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 6px; cursor: pointer; margin-left: 10px; font-weight: 600;">
                            📝 Esporta Word ${!isPremium ? '⭐' : ''}
                        </button>
                        <button onclick="deleteExercise(${ex.id})" style="padding: 8px 16px; background: #d9534f; color: white; border: none; border-radius: 6px; cursor: pointer; margin-left: 10px;">
                            🗑️ Elimina questo esercizio
                        </button>
                    </div>

                    <h2 style="color: #2d5f4f; margin-bottom: 10px;">${ex.exercise.title}</h2>
                    <span style="display: inline-block; background: #2d5f4f; color: white; padding: 6px 12px; border-radius: 6px; font-size: 13px; margin-bottom: 20px;">${ex.exercise.category}</span>

                    ${ex.rating > 0 ? `<div style="font-size: 32px; color: #f39c12; margin-bottom: 20px;">${'★'.repeat(parseInt(ex.rating))}</div>` : ''}

                    ${audioHTML}
                    ${photoHTML}

                    <!-- Info Base -->
                    <div style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #2d5f4f; margin-bottom: 15px;">📍 Informazioni Base</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 14px; line-height: 2;">
                            <div><strong>📅 Data:</strong> ${dateStr}</div>
                            <div><strong>⏰ Ora:</strong> ${timeStr}</div>
                            <div><strong>📍 Luogo:</strong> ${ex.location}</div>
                            <div><strong>⏱️ Durata:</strong> ${ex.duration}</div>
                        </div>
                    </div>

                    <!-- Contesto Ambientale -->
                    <div style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #2d5f4f; margin-bottom: 15px;">🌤️ Contesto Ambientale</h3>
                        <div style="margin-bottom: 15px;">
                            <strong>Descrizione ambiente:</strong>
                            <p style="background: #f9f9f9; padding: 12px; border-radius: 6px; margin-top: 5px;">${ex.environment}</p>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; font-size: 14px;">
                            <div><strong>☀️ Meteo:</strong> ${ex.weather}</div>
                            <div><strong>🔊 Rumore:</strong> ${ex.noiseLevel}</div>
                            <div><strong>👥 Solo:</strong> ${ex.alone}</div>
                            <div><strong>🚶 Movimento:</strong> ${ex.movement}</div>
                        </div>
                    </div>

                    <!-- Strumenti -->
                    ${ex.recordingTools ? `
                    <div style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #2d5f4f; margin-bottom: 15px;">🎙️ Strumenti Utilizzati</h3>
                        <p>${ex.recordingTools}</p>
                    </div>
                    ` : ''}

                    <!-- Disegno -->
                    ${ex.drawing ? `
                    <div style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #2d5f4f; margin-bottom: 15px;">✏️ Analisi Sonora Disegnata</h3>
                        <img src="${ex.drawing}" onclick="viewFullImage('${ex.drawing.replace(/'/g, "\\'")}', 'Analisi Sonora')" style="max-width: 100%; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                        <button onclick="downloadDrawing(${ex.id})" style="margin-top: 10px; padding: 8px 16px; background: #4a9d7f; color: white; border: none; border-radius: 6px; cursor: pointer;">
                            📤 Salva/Condividi Immagine
                        </button>
                    </div>
                    ` : ''}

                    <!-- Note e Considerazioni -->
                    <div style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="color: #2d5f4f; margin-bottom: 15px;">💭 Considerazioni e Note</h3>
                        <p style="background: #f9f9f9; padding: 15px; border-radius: 6px; line-height: 1.8; white-space: pre-wrap;">${ex.notes}</p>
                        ${ex.tags ? `
                        <div style="margin-top: 15px;">
                            <strong>🏷️ Tag:</strong><br>
                            ${ex.tags.split(',').map(tag => `<span style="background: #e0f2f7; color: #2d5f4f; padding: 5px 12px; border-radius: 4px; font-size: 13px; margin-right: 8px; margin-top: 8px; display: inline-block;">${tag.trim()}</span>`).join('')}
                        </div>
                        ` : ''}
                    </div>
                `;

                modal.classList.add('active');
            } catch (error) {
                console.error('Errore visualizzazione esercizio:', error);
                alert('❌ Errore durante il caricamento dell\'esercizio!');
            }
        }

        function closeViewCompletedModal() {
            document.getElementById('viewCompletedExerciseModal').classList.remove('active');
        }

        async function deleteExercise(id) {
            if (!confirm('Sei sicuro di voler eliminare questo esercizio? Questa azione non può essere annullata.')) {
                return;
            }

            try {
                await deleteExerciseFromIndexedDB(id);
                alert('✅ Esercizio eliminato con successo!');
                await updateCompletedExercisesCounter();
                closeViewCompletedModal();
                // Ricarica la lista esercizi se siamo nella vista completa
                showAllCompletedExercises();
                // Rimuovi spunta verde dalla lista esercizi
                await applyFilters();
            } catch (error) {
                console.error('Errore eliminazione:', error);
                alert('❌ Errore durante l\'eliminazione dell\'esercizio!');
            }
        }

        async function clearAllExercises() {
            if (!confirm('⚠️ ATTENZIONE!\n\nSei sicuro di voler eliminare TUTTI gli esercizi completati?\n\nQuesta azione è IRREVERSIBILE e cancellerà tutti i tuoi dati salvati (audio, foto, disegni, note).')) {
                return;
            }

            if (!confirm('Confermi di voler procedere? Tutti i tuoi esercizi, disegni, audio e foto saranno persi per sempre.')) {
                return;
            }

            try {
                await clearAllExercisesFromIndexedDB();
                alert('✅ Tutti gli esercizi sono stati eliminati.');
                await updateCompletedExercisesCounter();
                closeViewCompletedModal();
                // Ricarica la dashboard
                await loadCompletedExercisesList();
                // Rimuovi tutte le spunte verdi dalla lista esercizi
                await applyFilters();
            } catch (error) {
                console.error('Errore cancellazione:', error);
                alert('❌ Errore durante la cancellazione degli esercizi!');
            }
        }

        function exportAllExercises() {
            const savedExercises = JSON.parse(localStorage.getItem('completedExercises') || '[]');

            if (savedExercises.length === 0) {
                alert('Non ci sono esercizi da esportare!');
                return;
            }

            const dataStr = JSON.stringify(savedExercises, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `soundscape-exercises-backup-${new Date().toISOString().slice(0,10)}.json`;
            link.click();

            URL.revokeObjectURL(url);

            alert('✅ Esportazione completata! Il file è stato scaricato.');
        }

        // Helper function per scaricare audio
        async function downloadAudio(exerciseId, audioIndex) {
            // Premium check
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nIl download dei singoli audio è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per scaricare i tuoi file audio!');
                showUpgradeModal();
                return;
            }

            try {
                const ex = await getExerciseFromIndexedDB(exerciseId);
                if (!ex || !ex.audioFiles || !ex.audioFiles[audioIndex]) {
                    alert('❌ Audio non trovato!');
                    return;
                }

                const audioBlob = ex.audioFiles[audioIndex];

                // Download audio using Filesystem + Share on iOS
                try {
                    // audioBlob is already a Blob (no need to fetch)
                    const blob = audioBlob;
                    const fileName = `audio-${audioIndex + 1}.webm`;

                    // On iOS with Capacitor, use Filesystem + Share
                    if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Share && window.Capacitor.Plugins.Filesystem) {
                        const Filesystem = window.Capacitor.Plugins.Filesystem;
                        const Share = window.Capacitor.Plugins.Share;

                        // Convert blob to base64
                        const reader = new FileReader();
                        const base64Data = await new Promise((resolve, reject) => {
                            reader.onloadend = () => {
                                const base64 = reader.result.split(',')[1];
                                resolve(base64);
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(blob);
                        });

                        // Write to temporary file
                        const result = await Filesystem.writeFile({
                            path: fileName,
                            data: base64Data,
                            directory: 'CACHE'
                        });

                        // Share audio
                        await Share.share({
                            title: 'Salva Audio Soundscape',
                            text: fileName,
                            url: result.uri,
                            dialogTitle: 'Salva audio'
                        });
                    } else {
                        // Web fallback
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = fileName;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        setTimeout(() => URL.revokeObjectURL(url), 100);
                        alert('✅ Audio scaricato!');
                    }
                    return;
                } catch (error) {
                    console.error('Errore download audio:', error);
                    alert('❌ Errore durante il download dell\'audio: ' + error.message);
                    return;
                }

                // Fallback for web (not needed anymore)
                const link = document.createElement('a');
                link.href = audio.data;
                link.download = audio.name || `audio-${audioIndex + 1}.m4a`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                alert('✅ Audio scaricato!');
            } catch (error) {
                console.error('Errore download audio:', error);
                alert('❌ Errore durante il download dell\'audio!');
            }
        }

        // Helper function per scaricare foto
        async function downloadPhoto(exerciseId, photoIndex) {
            // Premium check
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nIl download delle singole foto è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per scaricare le tue foto!');
                showUpgradeModal();
                return;
            }

            try {
                const ex = await getExerciseFromIndexedDB(exerciseId);
                if (!ex || !ex.photoFiles || !ex.photoFiles[photoIndex]) {
                    alert('❌ Foto non trovata!');
                    return;
                }

                const photo = ex.photoFiles[photoIndex];

                // Check if running on native (Capacitor) with Media plugin
                if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Media) {
                    try {
                        const { Media } = window.Capacitor.Plugins;

                        // Save to photo library
                        await Media.savePhoto({
                            path: photo.data
                        });

                        alert('✅ Foto salvata nella Libreria Foto!');
                        return;
                    } catch (mediaError) {
                        console.error('Media error:', mediaError);
                        alert('❌ Errore salvataggio foto: ' + mediaError.message);
                        return;
                    }
                }

                // Fallback for web
                const response = await fetch(photo.data);
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);

                const link = document.createElement('a');
                link.href = url;
                link.download = photo.name || `foto-${photoIndex + 1}.jpg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                setTimeout(() => URL.revokeObjectURL(url), 100);
                alert('✅ Foto scaricata!');
            } catch (error) {
                console.error('Errore download foto:', error);
                alert('❌ Errore: ' + error.message);
            }
        }

        // Helper function per visualizzare immagine a schermo intero
        function viewFullImage(dataUrl, imageName) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                cursor: pointer;
            `;

            const img = document.createElement('img');
            img.src = dataUrl;
            img.style.cssText = `
                max-width: 95%;
                max-height: 95%;
                object-fit: contain;
                border-radius: 8px;
            `;

            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '✕ Chiudi';
            closeBtn.style.cssText = `
                position: absolute;
                top: 20px;
                right: 20px;
                padding: 10px 20px;
                background: white;
                color: black;
                border: none;
                border-radius: 6px;
                font-size: 16px;
                cursor: pointer;
                z-index: 10001;
            `;

            closeBtn.onclick = (e) => {
                e.stopPropagation();
                document.body.removeChild(modal);
            };

            modal.onclick = () => {
                document.body.removeChild(modal);
            };

            modal.appendChild(img);
            modal.appendChild(closeBtn);
            document.body.appendChild(modal);
        }

        // Download disegno
        async function downloadDrawing(exerciseId) {
            // Premium check
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nIl download dei disegni è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per scaricare i tuoi disegni!');
                showUpgradeModal();
                return;
            }

            try {
                const ex = await getExerciseFromIndexedDB(exerciseId);

                if (!ex || !ex.drawing) {
                    alert('❌ Disegno non trovato!');
                    return;
                }

                // Check if running on native (Capacitor) and Share plugin is available
                if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Share) {
                    // Use Capacitor Share API for native platforms
                    try {
                        await window.Capacitor.Plugins.Share.share({
                            title: 'Salva Disegno',
                            text: `Soundscape Studio - ${ex.exercise.title}`,
                            url: ex.drawing,
                            dialogTitle: 'Salva o Condividi Disegno'
                        });
                        return; // Success, exit function
                    } catch (shareError) {
                        console.error('Errore plugin Share:', shareError);
                        // Fall through to download method
                    }
                }

                // Fallback for web or if share fails
                {
                    // Fallback for web: download link
                    const response = await fetch(ex.drawing);
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);

                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `soundscape-drawing-${ex.exercise.title.replace(/[^a-z0-9]/gi, '-')}.png`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    alert('✅ Immagine scaricata!');
                }
            } catch (error) {
                console.error('Errore condivisione/download disegno:', error);
                alert('❌ Errore: ' + error.message);
            }
        }

        // Initialize on load
        window.addEventListener('load', async () => {
            // Inizializza IndexedDB
            try {
                await initDB();
                console.log('✅ Database inizializzato');
            } catch (error) {
                console.error('❌ Errore inizializzazione database:', error);
                alert('⚠️ Errore inizializzazione database!\n\nL\'app potrebbe non funzionare correttamente.');
            }

            // Carica interfaccia
            loadExercises();
            generateExampleImages();
            await updateCompletedExercisesCounter();
        });

        // ==================== EXAMPLE IMAGES GENERATION ====================
        function generateExampleImages() {
            // Check if example canvases exist
            if (!document.getElementById('exampleCanvas0')) {
                console.log('Example canvases not found, skipping generation');
                return;
            }

            // 0: Rainbow Gradient
            const canvas0 = document.getElementById('exampleCanvas0');
            if (!canvas0) return;
            const ctx0 = canvas0.getContext('2d');
            const gradient0 = ctx0.createLinearGradient(0, 0, 150, 0);
            gradient0.addColorStop(0, '#ff0000');
            gradient0.addColorStop(0.17, '#ff7f00');
            gradient0.addColorStop(0.33, '#ffff00');
            gradient0.addColorStop(0.5, '#00ff00');
            gradient0.addColorStop(0.67, '#0000ff');
            gradient0.addColorStop(0.83, '#4b0082');
            gradient0.addColorStop(1, '#9400d3');
            ctx0.fillStyle = gradient0;
            ctx0.fillRect(0, 0, 150, 150);

            // 1: Checkerboard
            const ctx1 = document.getElementById('exampleCanvas1').getContext('2d');
            const squareSize = 15;
            for (let y = 0; y < 150; y += squareSize) {
                for (let x = 0; x < 150; x += squareSize) {
                    ctx1.fillStyle = ((x / squareSize) + (y / squareSize)) % 2 === 0 ? '#000' : '#fff';
                    ctx1.fillRect(x, y, squareSize, squareSize);
                }
            }

            // 2: Geometric Spiral
            const ctx2 = document.getElementById('exampleCanvas2').getContext('2d');
            ctx2.fillStyle = '#f0f0f0';
            ctx2.fillRect(0, 0, 150, 150);
            ctx2.strokeStyle = '#2d5f4f';
            ctx2.lineWidth = 2;
            ctx2.beginPath();
            const centerX = 75, centerY = 75;
            let angle = 0;
            let radius = 0;
            ctx2.moveTo(centerX, centerY);
            while (radius < 70) {
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                ctx2.lineTo(x, y);
                angle += 0.1;
                radius += 0.3;
            }
            ctx2.stroke();

            // 3: Vertical Lines
            const ctx3 = document.getElementById('exampleCanvas3').getContext('2d');
            ctx3.fillStyle = '#fff';
            ctx3.fillRect(0, 0, 150, 150);
            for (let x = 0; x < 150; x += 10) {
                const brightness = Math.floor((x / 150) * 255);
                ctx3.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                ctx3.fillRect(x, 0, 10, 150);
            }

            // 4: Abstract Art (Random Circles)
            const ctx4 = document.getElementById('exampleCanvas4').getContext('2d');
            ctx4.fillStyle = '#1a1a1a';
            ctx4.fillRect(0, 0, 150, 150);
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * 150;
                const y = Math.random() * 150;
                const r = Math.random() * 30 + 10;
                const hue = Math.random() * 360;
                ctx4.fillStyle = `hsla(${hue}, 80%, 60%, 0.5)`;
                ctx4.beginPath();
                ctx4.arc(x, y, r, 0, Math.PI * 2);
                ctx4.fill();
            }

            // 5: Sine Wave
            const ctx5 = document.getElementById('exampleCanvas5').getContext('2d');
            ctx5.fillStyle = '#fff';
            ctx5.fillRect(0, 0, 150, 150);
            ctx5.strokeStyle = '#2d5f4f';
            ctx5.lineWidth = 3;
            ctx5.beginPath();
            for (let x = 0; x < 150; x++) {
                const y = 75 + Math.sin(x / 10) * 40;
                if (x === 0) ctx5.moveTo(x, y);
                else ctx5.lineTo(x, y);
            }
            ctx5.stroke();

            // Add more waves with different frequencies
            ctx5.strokeStyle = '#8ba888';
            ctx5.lineWidth = 2;
            ctx5.beginPath();
            for (let x = 0; x < 150; x++) {
                const y = 75 + Math.sin(x / 5) * 20;
                if (x === 0) ctx5.moveTo(x, y);
                else ctx5.lineTo(x, y);
            }
            ctx5.stroke();

            // 6: Circular Pattern (Mandala-like)
            const ctx6 = document.getElementById('exampleCanvas6').getContext('2d');
            ctx6.fillStyle = '#fff';
            ctx6.fillRect(0, 0, 150, 150);
            const cx = 75, cy = 75;
            for (let r = 10; r < 70; r += 10) {
                const hue = (r / 70) * 360;
                ctx6.strokeStyle = `hsl(${hue}, 70%, 50%)`;
                ctx6.lineWidth = 3;
                ctx6.beginPath();
                ctx6.arc(cx, cy, r, 0, Math.PI * 2);
                ctx6.stroke();
            }

            // 7: QR-like Pattern
            const ctx7 = document.getElementById('exampleCanvas7').getContext('2d');
            ctx7.fillStyle = '#fff';
            ctx7.fillRect(0, 0, 150, 150);
            ctx7.fillStyle = '#000';
            const blockSize = 10;
            for (let y = 0; y < 150; y += blockSize) {
                for (let x = 0; x < 150; x += blockSize) {
                    if (Math.random() > 0.5) {
                        ctx7.fillRect(x, y, blockSize, blockSize);
                    }
                }
            }

            // 8: Sunset Gradient
            const ctx8 = document.getElementById('exampleCanvas8').getContext('2d');
            const gradient8 = ctx8.createLinearGradient(0, 0, 0, 150);
            gradient8.addColorStop(0, '#ff6b35');
            gradient8.addColorStop(0.3, '#f7931e');
            gradient8.addColorStop(0.5, '#fdc830');
            gradient8.addColorStop(0.7, '#f37335');
            gradient8.addColorStop(1, '#4a148c');
            ctx8.fillStyle = gradient8;
            ctx8.fillRect(0, 0, 150, 150);

            // 9: Noise Texture
            const ctx9 = document.getElementById('exampleCanvas9').getContext('2d');
            const imageData = ctx9.createImageData(150, 150);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const noise = Math.random() * 255;
                imageData.data[i] = noise;     // R
                imageData.data[i + 1] = noise; // G
                imageData.data[i + 2] = noise; // B
                imageData.data[i + 3] = 255;   // A
            }
            ctx9.putImageData(imageData, 0, 0);
        }

        function loadExampleImage(index) {
            const exampleCanvas = document.getElementById(`exampleCanvas${index}`);

            // Load the example into the main image canvas
            imgCanvas = document.getElementById('imageCanvas');
            imgCtx = imgCanvas.getContext('2d');

            // Set canvas size to match example
            const size = 400; // Larger for better quality
            imgCanvas.width = size;
            imgCanvas.height = size;
            imageWidth = size;
            imageHeight = size;

            // Regenerate the image at higher resolution
            regenerateExampleImage(index, imgCtx, size);

            // Get image data
            imgData = imgCtx.getImageData(0, 0, size, size);

            // Show canvas and controls
            document.getElementById('imageCanvasContainer').style.display = 'block';
            document.getElementById('sonificationControls').style.display = 'block';

            // Update scan line height
            document.getElementById('scanLine').style.height = size + 'px';
        }

        // Load example image and navigate to Image Sonification section
        function loadExampleImageAndNavigate(index) {
            // Load the image first
            loadExampleImage(index);

            // Navigate to imagesonification section
            showSection('imagesonification');
        }

        function regenerateExampleImage(index, ctx, size) {
            switch(index) {
                case 0: // Rainbow
                    const gradient0 = ctx.createLinearGradient(0, 0, size, 0);
                    gradient0.addColorStop(0, '#ff0000');
                    gradient0.addColorStop(0.17, '#ff7f00');
                    gradient0.addColorStop(0.33, '#ffff00');
                    gradient0.addColorStop(0.5, '#00ff00');
                    gradient0.addColorStop(0.67, '#0000ff');
                    gradient0.addColorStop(0.83, '#4b0082');
                    gradient0.addColorStop(1, '#9400d3');
                    ctx.fillStyle = gradient0;
                    ctx.fillRect(0, 0, size, size);
                    break;

                case 1: // Checkerboard
                    const squareSize = Math.floor(size / 10);
                    for (let y = 0; y < size; y += squareSize) {
                        for (let x = 0; x < size; x += squareSize) {
                            ctx.fillStyle = ((x / squareSize) + (y / squareSize)) % 2 === 0 ? '#000' : '#fff';
                            ctx.fillRect(x, y, squareSize, squareSize);
                        }
                    }
                    break;

                case 2: // Spiral
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillRect(0, 0, size, size);
                    ctx.strokeStyle = '#2d5f4f';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    const centerX = size / 2, centerY = size / 2;
                    let angle = 0, radius = 0;
                    ctx.moveTo(centerX, centerY);
                    while (radius < size / 2 - 20) {
                        const x = centerX + radius * Math.cos(angle);
                        const y = centerY + radius * Math.sin(angle);
                        ctx.lineTo(x, y);
                        angle += 0.1;
                        radius += 0.8;
                    }
                    ctx.stroke();
                    break;

                case 3: // Vertical Lines
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, size, size);
                    for (let x = 0; x < size; x += size / 15) {
                        const brightness = Math.floor((x / size) * 255);
                        ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                        ctx.fillRect(x, 0, size / 15, size);
                    }
                    break;

                case 4: // Abstract Art
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(0, 0, size, size);
                    for (let i = 0; i < 50; i++) {
                        const x = Math.random() * size;
                        const y = Math.random() * size;
                        const r = Math.random() * 80 + 20;
                        const hue = Math.random() * 360;
                        ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.5)`;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;

                case 5: // Sine Wave
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, size, size);
                    ctx.strokeStyle = '#2d5f4f';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    for (let x = 0; x < size; x++) {
                        const y = size / 2 + Math.sin(x / 30) * (size / 4);
                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    ctx.strokeStyle = '#8ba888';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for (let x = 0; x < size; x++) {
                        const y = size / 2 + Math.sin(x / 15) * (size / 8);
                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    break;

                case 6: // Circular Pattern
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, size, size);
                    const cx = size / 2, cy = size / 2;
                    for (let r = 20; r < size / 2 - 20; r += 20) {
                        const hue = (r / (size / 2)) * 360;
                        ctx.strokeStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.arc(cx, cy, r, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    break;

                case 7: // QR-like
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, size, size);
                    ctx.fillStyle = '#000';
                    const blockSize = Math.floor(size / 15);
                    for (let y = 0; y < size; y += blockSize) {
                        for (let x = 0; x < size; x += blockSize) {
                            if (Math.random() > 0.5) {
                                ctx.fillRect(x, y, blockSize, blockSize);
                            }
                        }
                    }
                    break;

                case 8: // Sunset
                    const gradient8 = ctx.createLinearGradient(0, 0, 0, size);
                    gradient8.addColorStop(0, '#ff6b35');
                    gradient8.addColorStop(0.3, '#f7931e');
                    gradient8.addColorStop(0.5, '#fdc830');
                    gradient8.addColorStop(0.7, '#f37335');
                    gradient8.addColorStop(1, '#4a148c');
                    ctx.fillStyle = gradient8;
                    ctx.fillRect(0, 0, size, size);
                    break;

                case 9: // Noise
                    const imageData = ctx.createImageData(size, size);
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        const noise = Math.random() * 255;
                        imageData.data[i] = noise;
                        imageData.data[i + 1] = noise;
                        imageData.data[i + 2] = noise;
                        imageData.data[i + 3] = 255;
                    }
                    ctx.putImageData(imageData, 0, 0);
                    break;
            }
        }

        // ==================== IMAGE SONIFICATION ====================
        let imgCanvas, imgCtx, imgData;
        let sonificationContext, sonificationOscillators = [];
        let sonificationInterval, isPaused = false, currentPosition = 0;
        let imageWidth, imageHeight;
        let masterCompressor, masterReverb, reverbGain;

        // Tone.js Samplers for high-quality instruments
        let toneSynths = {};
        let toneInitialized = false;

        // Initialize Tone.js instruments
        async function initializeToneSynths() {
            if (toneInitialized) return;

            console.log('🎹 Initializing Tone.js instruments...');

            // Start Tone.js audio context
            await Tone.start();
            console.log('✅ Tone.start() completed, context state:', Tone.context.state);

            // Create simple synths first (more reliable)
            toneSynths.piano = new Tone.PolySynth(Tone.Synth).toDestination();
            toneSynths.piano.set({
                oscillator: { type: "sine" },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 }
            });

            toneSynths['synth-pad'] = new Tone.PolySynth(Tone.Synth).toDestination();
            toneSynths['synth-pad'].set({
                oscillator: { type: "sawtooth" },
                envelope: { attack: 0.3, decay: 0.4, sustain: 0.7, release: 2.0 }
            });

            toneSynths.bass = new Tone.PolySynth(Tone.Synth).toDestination();
            toneSynths.bass.set({
                oscillator: { type: "square" },
                envelope: { attack: 0.01, decay: 0.3, sustain: 0.6, release: 0.8 }
            });

            toneSynths.bells = new Tone.PolySynth(Tone.FMSynth).toDestination();
            toneSynths.bells.set({
                harmonicity: 8,
                modulationIndex: 2,
                envelope: { attack: 0.001, decay: 2, sustain: 0.1, release: 2 }
            });

            toneSynths.pluck = new Tone.PolySynth(Tone.Synth).toDestination();
            toneSynths.pluck.set({
                oscillator: { type: "triangle" },
                envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.2 }
            });

            // Set LOUD volume for all synths
            Object.values(toneSynths).forEach(synth => {
                synth.volume.value = 0; // 0 dB = full volume
            });

            toneInitialized = true;
            console.log('✅ Tone.js instruments ready!');

            // Test sound
            console.log('🔊 Testing piano with C4...');
            toneSynths.piano.triggerAttackRelease("C4", "8n");
            console.log('✅ Test note triggered');
        }

        // Load Image
        const imageInput = document.getElementById('imageInput');
        if (imageInput) {
            imageInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    // Setup canvas
                    imgCanvas = document.getElementById('imageCanvas');
                    imgCtx = imgCanvas.getContext('2d');

                    // Resize image to reasonable size (max 800px width)
                    const maxWidth = 800;
                    let width = img.width;
                    let height = img.height;

                    if (width > maxWidth) {
                        const ratio = maxWidth / width;
                        width = maxWidth;
                        height = height * ratio;
                    }

                    imgCanvas.width = width;
                    imgCanvas.height = height;
                    imageWidth = width;
                    imageHeight = height;

                    // Draw image
                    imgCtx.drawImage(img, 0, 0, width, height);
                    imgData = imgCtx.getImageData(0, 0, width, height);

                    // Show canvas and controls
                    document.getElementById('imageCanvasContainer').style.display = 'block';
                    document.getElementById('sonificationControls').style.display = 'block';

                    // Update scan line height
                    document.getElementById('scanLine').style.height = height + 'px';
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            });
        }

        // Clear Image
        const clearImageBtn = document.getElementById('clearImageBtn');
        if (clearImageBtn) {
            clearImageBtn.addEventListener('click', function() {
            document.getElementById('imageCanvasContainer').style.display = 'none';
            document.getElementById('sonificationControls').style.display = 'none';
            document.getElementById('imageInput').value = '';
            stopSonification();
            });
        }

        // Speed Slider
        const scanSpeed = document.getElementById('scanSpeed');
        if (scanSpeed) {
            scanSpeed.addEventListener('input', function(e) {
                document.getElementById('speedValue').textContent = parseFloat(e.target.value).toFixed(1) + 'x';
            });
        }

        // Filter Cutoff Slider
        const filterCutoff = document.getElementById('filterCutoff');
        if (filterCutoff) {
            filterCutoff.addEventListener('input', function(e) {
                document.getElementById('filterValue').textContent = e.target.value + ' Hz';
            });
        }

        // Resonance Slider
        const resonance = document.getElementById('resonance');
        if (resonance) {
            resonance.addEventListener('input', function(e) {
                document.getElementById('resonanceValue').textContent = parseFloat(e.target.value).toFixed(1);
            });
        }

        // Attack Slider
        const attackTime = document.getElementById('attackTime');
        if (attackTime) {
            attackTime.addEventListener('input', function(e) {
                document.getElementById('attackValue').textContent = parseFloat(e.target.value).toFixed(3) + 's';
            });
        }

        // Release Slider
        const releaseTime = document.getElementById('releaseTime');
        if (releaseTime) {
            releaseTime.addEventListener('input', function(e) {
                document.getElementById('releaseValue').textContent = parseFloat(e.target.value).toFixed(2) + 's';
            });
        }

        // Musical Scales Toggle
        const useMusicalScales = document.getElementById('useMusicalScales');
        if (useMusicalScales) {
            useMusicalScales.addEventListener('change', function(e) {
                const scaleControls = document.getElementById('scaleControls');
                if (scaleControls) {
                    scaleControls.style.display = e.target.checked ? 'grid' : 'none';
                }
            });
        }

        // Musical Scales Definitions (in semitones from root)
        const musicalScales = {
            // Major modes
            major: [0, 2, 4, 5, 7, 9, 11],
            lydian: [0, 2, 4, 6, 7, 9, 11],
            mixolydian: [0, 2, 4, 5, 7, 9, 10],

            // Minor modes
            minor: [0, 2, 3, 5, 7, 8, 10],
            dorian: [0, 2, 3, 5, 7, 9, 10],
            phrygian: [0, 1, 3, 5, 7, 8, 10],
            locrian: [0, 1, 3, 5, 6, 8, 10],
            harmonic_minor: [0, 2, 3, 5, 7, 8, 11],
            melodic_minor: [0, 2, 3, 5, 7, 9, 11],

            // Pentatonic
            pentatonic_major: [0, 2, 4, 7, 9],
            pentatonic_minor: [0, 3, 5, 7, 10],

            // Blues & Jazz
            blues: [0, 3, 5, 6, 7, 10],
            bebop_major: [0, 2, 4, 5, 7, 8, 9, 11],
            bebop_minor: [0, 2, 3, 5, 7, 8, 9, 10],

            // Mediorientali/Arabe
            arabic: [0, 1, 4, 5, 7, 8, 11],          // Maqam Hijaz
            persian: [0, 1, 4, 5, 6, 8, 11],         // Dastgah
            hijaz: [0, 1, 4, 5, 7, 8, 10],           // Hijaz

            // Indiane (Raga)
            raga_bhairav: [0, 1, 4, 5, 7, 8, 11],   // Alba
            raga_todi: [0, 1, 3, 6, 7, 8, 11],       // Mezzogiorno
            raga_yaman: [0, 2, 4, 6, 7, 9, 11],     // Sera

            // Giapponesi
            japanese_in: [0, 1, 5, 7, 8],            // In (misteriosa)
            japanese_yo: [0, 2, 5, 7, 9],            // Yo (allegra)
            japanese_hirajoshi: [0, 2, 3, 7, 8],     // Hirajōshi

            // Africane
            african_1: [0, 2, 3, 5, 7, 9, 10],       // Africana comune
            african_2: [0, 3, 5, 7, 10],             // Pentatonica africana

            // Esotiche/Moderne
            whole_tone: [0, 2, 4, 6, 8, 10],         // Debussy
            diminished: [0, 2, 3, 5, 6, 8, 9, 11],   // Jazz
            augmented: [0, 3, 4, 7, 8, 11],
            spanish: [0, 1, 3, 4, 5, 6, 8, 10],      // Flamenco
            gypsy: [0, 2, 3, 6, 7, 8, 11],

            // Altre
            chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
            whole_half: [0, 2, 3, 5, 6, 8, 9, 11]
        };

        // Function to quantize frequency to nearest note in scale
        function quantizeToScale(frequency, scaleName, keyOffset, octaveRange) {
            const scale = musicalScales[scaleName];
            if (!scale) return frequency;

            // Convert frequency to MIDI note number
            const midiNote = 12 * Math.log2(frequency / 440) + 69;

            // Get the scale notes across all octaves
            const baseOctave = Math.floor(midiNote / 12) - Math.floor(octaveRange / 2);
            const scaleNotes = [];

            for (let oct = 0; oct < octaveRange + 1; oct++) {
                for (let i = 0; i < scale.length; i++) {
                    const note = (baseOctave + oct) * 12 + scale[i] + parseInt(keyOffset);
                    scaleNotes.push(note);
                }
            }

            // Find closest scale note
            let closestNote = scaleNotes[0];
            let minDistance = Math.abs(midiNote - closestNote);

            for (let i = 1; i < scaleNotes.length; i++) {
                const distance = Math.abs(midiNote - scaleNotes[i]);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestNote = scaleNotes[i];
                }
            }

            // Convert back to frequency
            return 440 * Math.pow(2, (closestNote - 69) / 12);
        }

        // Play Sonification
        const playSonificationBtn = document.getElementById('playSonificationBtn');
        if (playSonificationBtn) {
            playSonificationBtn.addEventListener('click', function() {
                startSonification();
            });
        }

        // Stop Sonification
        const stopSonificationBtn = document.getElementById('stopSonificationBtn');
        if (stopSonificationBtn) {
            stopSonificationBtn.addEventListener('click', function() {
                stopSonification();
            });
        }

        // Pause Sonification
        const pauseSonificationBtn = document.getElementById('pauseSonificationBtn');
        if (pauseSonificationBtn) {
            pauseSonificationBtn.addEventListener('click', function() {
                pauseSonification();
            });
        }

        // Resume Sonification
        const resumeSonificationBtn = document.getElementById('resumeSonificationBtn');
        if (resumeSonificationBtn) {
            resumeSonificationBtn.addEventListener('click', function() {
                resumeSonification();
            });
        }

        async function startSonification() {
            if (!imgData) {
                alert('Carica prima un\'immagine!');
                return;
            }

            try {
                // Initialize Tone.js instruments first
                await initializeToneSynths();
                console.log('✅ Tone.js initialized successfully');
            } catch (error) {
                console.error('❌ Error initializing Tone.js:', error);
            }

            // Initialize Audio Context
            if (!sonificationContext) {
                sonificationContext = new (window.AudioContext || window.webkitAudioContext)();

                // Create master compressor for better dynamics
                masterCompressor = sonificationContext.createDynamicsCompressor();
                masterCompressor.threshold.value = -24;
                masterCompressor.knee.value = 30;
                masterCompressor.ratio.value = 12;
                masterCompressor.attack.value = 0.003;
                masterCompressor.release.value = 0.25;

                // Create reverb using ConvolverNode
                masterReverb = sonificationContext.createConvolver();
                reverbGain = sonificationContext.createGain();
                reverbGain.gain.value = 0.15; // Mix leggero di reverb

                // Generate impulse response for reverb
                const reverbLength = sonificationContext.sampleRate * 2; // 2 secondi
                const impulse = sonificationContext.createBuffer(2, reverbLength, sonificationContext.sampleRate);
                const impulseL = impulse.getChannelData(0);
                const impulseR = impulse.getChannelData(1);

                for (let i = 0; i < reverbLength; i++) {
                    const decay = Math.pow(1 - i / reverbLength, 2);
                    impulseL[i] = (Math.random() * 2 - 1) * decay;
                    impulseR[i] = (Math.random() * 2 - 1) * decay;
                }
                masterReverb.buffer = impulse;

                // Connect reverb chain: reverb -> reverbGain -> compressor -> destination
                masterReverb.connect(reverbGain);
                reverbGain.connect(masterCompressor);
                masterCompressor.connect(sonificationContext.destination);
            }

            // Reset position
            currentPosition = 0;

            // Update UI
            document.getElementById('playSonificationBtn').style.display = 'none';
            document.getElementById('stopSonificationBtn').style.display = 'inline-block';
            document.getElementById('pauseSonificationBtn').style.display = 'inline-block';
            document.getElementById('resumeSonificationBtn').style.display = 'none';
            document.getElementById('scanLine').style.display = 'block';

            // Get parameters
            const scanMode = document.getElementById('scanMode').value;
            const speed = parseFloat(document.getElementById('scanSpeed').value);
            const mappingMode = document.getElementById('mappingMode').value;

            // Start scanning
            isPaused = false;
            scanImage(scanMode, speed, mappingMode);
        }

        function stopSonification() {
            // Stop interval
            if (sonificationInterval) {
                clearInterval(sonificationInterval);
                sonificationInterval = null;
            }

            // Stop all oscillators
            sonificationOscillators.forEach(osc => {
                try {
                    osc.stop();
                } catch (e) {}
            });
            sonificationOscillators = [];

            // Stop all Tone.js synths
            if (toneInitialized) {
                Object.values(toneSynths).forEach(synth => {
                    synth.releaseAll();
                });
            }

            // Reset UI
            document.getElementById('playSonificationBtn').style.display = 'inline-block';
            document.getElementById('stopSonificationBtn').style.display = 'none';
            document.getElementById('pauseSonificationBtn').style.display = 'none';
            document.getElementById('resumeSonificationBtn').style.display = 'none';
            document.getElementById('scanLine').style.display = 'none';
            document.getElementById('sonificationProgress').style.width = '0%';
            document.getElementById('progressText').textContent = '0%';

            currentPosition = 0;
            isPaused = false;
        }

        function pauseSonification() {
            isPaused = true;
            if (sonificationInterval) {
                clearInterval(sonificationInterval);
                sonificationInterval = null;
            }

            sonificationOscillators.forEach(osc => {
                try {
                    osc.stop();
                } catch (e) {}
            });
            sonificationOscillators = [];

            // Stop all Tone.js synths
            if (toneInitialized) {
                Object.values(toneSynths).forEach(synth => {
                    synth.releaseAll();
                });
            }

            document.getElementById('pauseSonificationBtn').style.display = 'none';
            document.getElementById('resumeSonificationBtn').style.display = 'inline-block';
        }

        function resumeSonification() {
            isPaused = false;
            const scanMode = document.getElementById('scanMode').value;
            const speed = parseFloat(document.getElementById('scanSpeed').value);
            const mappingMode = document.getElementById('mappingMode').value;

            document.getElementById('pauseSonificationBtn').style.display = 'inline-block';
            document.getElementById('resumeSonificationBtn').style.display = 'none';

            scanImage(scanMode, speed, mappingMode);
        }

        function scanImage(scanMode, speed, mappingMode) {
            const baseInterval = 20; // ms per column/row
            const interval = baseInterval / speed;

            sonificationInterval = setInterval(() => {
                if (isPaused) return;

                if (scanMode === 'horizontal') {
                    if (currentPosition >= imageWidth) {
                        stopSonification();
                        return;
                    }

                    // Get column data
                    const columnData = getColumnData(currentPosition);

                    // Sonify column
                    sonifyData(columnData, currentPosition / imageWidth, mappingMode);

                    // Update scan line
                    const scanLine = document.getElementById('scanLine');
                    scanLine.style.left = currentPosition + 'px';

                    // Update progress
                    const progress = (currentPosition / imageWidth) * 100;
                    document.getElementById('sonificationProgress').style.width = progress + '%';
                    document.getElementById('progressText').textContent = Math.round(progress) + '%';

                    currentPosition++;

                } else if (scanMode === 'vertical') {
                    if (currentPosition >= imageHeight) {
                        stopSonification();
                        return;
                    }

                    // Get row data
                    const rowData = getRowData(currentPosition);

                    // Sonify row
                    sonifyData(rowData, currentPosition / imageHeight, mappingMode);

                    // Update scan line (rotate for vertical)
                    const scanLine = document.getElementById('scanLine');
                    scanLine.style.width = imageWidth + 'px';
                    scanLine.style.height = '2px';
                    scanLine.style.top = currentPosition + 'px';
                    scanLine.style.left = '0px';

                    // Update progress
                    const progress = (currentPosition / imageHeight) * 100;
                    document.getElementById('sonificationProgress').style.width = progress + '%';
                    document.getElementById('progressText').textContent = Math.round(progress) + '%';

                    currentPosition++;
                }

            }, interval);
        }

        function getColumnData(x) {
            const data = [];
            for (let y = 0; y < imageHeight; y++) {
                const index = (y * imageWidth + x) * 4;
                const r = imgData.data[index];
                const g = imgData.data[index + 1];
                const b = imgData.data[index + 2];
                data.push({ r, g, b, y });
            }
            return data;
        }

        function getRowData(y) {
            const data = [];
            for (let x = 0; x < imageWidth; x++) {
                const index = (y * imageWidth + x) * 4;
                const r = imgData.data[index];
                const g = imgData.data[index + 1];
                const b = imgData.data[index + 2];
                data.push({ r, g, b, x });
            }
            return data;
        }

        function sonifyData(pixelData, progress, mappingMode) {
            // Stop previous oscillators
            sonificationOscillators.forEach(osc => {
                try {
                    osc.stop();
                } catch (e) {}
            });
            sonificationOscillators = [];

            // Get all parameters
            const freqRangeSelect = document.getElementById('freqRange').value;
            const synthesisType = document.getElementById('synthesisType').value;
            const filterCutoff = parseFloat(document.getElementById('filterCutoff').value);
            const resonance = parseFloat(document.getElementById('resonance').value);
            const attackTime = parseFloat(document.getElementById('attackTime').value);
            const releaseTime = parseFloat(document.getElementById('releaseTime').value);

            // Musical scales parameters
            const useScales = document.getElementById('useMusicalScales').checked;
            const scaleName = document.getElementById('musicalScale').value;
            const keyOffset = document.getElementById('musicalKey').value;
            const octaveRange = parseInt(document.getElementById('octaveRange').value);

            let minFreq, maxFreq;
            switch(freqRangeSelect) {
                case 'low': minFreq = 50; maxFreq = 200; break;
                case 'mid': minFreq = 200; maxFreq = 1000; break;
                case 'high': minFreq = 1000; maxFreq = 4000; break;
                case 'full': minFreq = 50; maxFreq = 4000; break;
                default: minFreq = 200; maxFreq = 1000;
            }

            const now = sonificationContext.currentTime;
            const duration = attackTime + releaseTime;

            if (mappingMode === 'brightness') {
                // Brightness mode: average brightness → single frequency
                let totalBrightness = 0;
                pixelData.forEach(pixel => {
                    const brightness = (pixel.r + pixel.g + pixel.b) / 3;
                    totalBrightness += brightness;
                });
                const avgBrightness = totalBrightness / pixelData.length;
                const normalizedBrightness = avgBrightness / 255;
                let frequency = minFreq + (normalizedBrightness * (maxFreq - minFreq));

                // Apply musical scale quantization if enabled
                if (useScales) {
                    frequency = quantizeToScale(frequency, scaleName, keyOffset, octaveRange);
                }

                createSynthVoice(frequency, normalizedBrightness, 0, synthesisType, filterCutoff, resonance, attackTime, releaseTime, now, duration);

            } else if (mappingMode === 'color') {
                // Color mode: RGB → 3 separate voices
                let totalR = 0, totalG = 0, totalB = 0;
                pixelData.forEach(pixel => {
                    totalR += pixel.r;
                    totalG += pixel.g;
                    totalB += pixel.b;
                });

                const avgR = totalR / pixelData.length / 255;
                const avgG = totalG / pixelData.length / 255;
                const avgB = totalB / pixelData.length / 255;

                let freqR = minFreq + (avgR * (maxFreq - minFreq));
                let freqG = minFreq + (avgG * (maxFreq - minFreq));
                let freqB = minFreq + (avgB * (maxFreq - minFreq));

                // Apply musical scale quantization if enabled
                if (useScales) {
                    freqR = quantizeToScale(freqR, scaleName, keyOffset, octaveRange);
                    freqG = quantizeToScale(freqG, scaleName, keyOffset, octaveRange);
                    freqB = quantizeToScale(freqB, scaleName, keyOffset, octaveRange);
                }

                // Create separate voices for R, G, B
                createSynthVoice(freqR, avgR, -0.3, synthesisType, filterCutoff, resonance, attackTime, releaseTime, now, duration);
                createSynthVoice(freqG, avgG, 0, synthesisType, filterCutoff, resonance, attackTime, releaseTime, now, duration);
                createSynthVoice(freqB, avgB, 0.3, synthesisType, filterCutoff, resonance, attackTime, releaseTime, now, duration);

            } else if (mappingMode === 'position') {
                // Position mode: vertical position → frequency, horizontal → pan
                let totalBrightness = 0;
                let weightedPosition = 0;

                pixelData.forEach(pixel => {
                    const brightness = (pixel.r + pixel.g + pixel.b) / 3;
                    totalBrightness += brightness;
                    const pos = pixel.y !== undefined ? pixel.y : pixel.x;
                    weightedPosition += pos * brightness;
                });

                const avgBrightness = totalBrightness / pixelData.length;
                const avgPosition = weightedPosition / totalBrightness;
                const maxPos = pixelData[0].y !== undefined ? imageHeight : imageWidth;
                const normalizedPos = avgPosition / maxPos;
                let frequency = minFreq + (normalizedPos * (maxFreq - minFreq));
                const panValue = (progress * 2) - 1; // -1 to 1

                // Apply musical scale quantization if enabled
                if (useScales) {
                    frequency = quantizeToScale(frequency, scaleName, keyOffset, octaveRange);
                }

                createSynthVoice(frequency, avgBrightness / 255, panValue, synthesisType, filterCutoff, resonance, attackTime, releaseTime, now, duration);
            }
        }

        function createSynthVoice(frequency, intensity, pan, synthesisType, filterCutoff, resonance, attackTime, releaseTime, now, duration) {
            // Check if using Tone.js sampled instruments
            const toneSynthTypes = ['piano', 'synth-pad', 'bass', 'bells', 'pluck'];
            if (toneSynthTypes.includes(synthesisType)) {
                // Tone.js should already be initialized in startSonification
                if (!toneInitialized) {
                    console.warn('⚠️ Tone.js not initialized yet');
                    return;
                }

                // Convert frequency to note name
                const midiNote = 12 * Math.log2(frequency / 440) + 69;
                const noteName = Tone.Frequency(Math.round(midiNote), "midi").toNote();

                // Calculate velocity from intensity (0-1)
                const velocity = Math.max(0.1, Math.min(1, intensity * 1.5));

                // Schedule note with Tone.js
                const synth = toneSynths[synthesisType];
                if (synth) {
                    // Trigger note immediately with duration
                    // Tone.js uses seconds for duration, so we use duration directly
                    synth.triggerAttackRelease(noteName, duration, "+0", velocity);
                    console.log(`🎵 Playing ${noteName} on ${synthesisType} (velocity: ${velocity.toFixed(2)})`);
                } else {
                    console.error(`❌ Synth not found: ${synthesisType}`);
                }

                return; // Exit early, Tone.js handles everything
            }

            // Web Audio API synthesis (original code)
            const gainValue = intensity * 0.2; // Ridotto per headroom del compressore

            // Migliora attack e release per evitare click
            const improvedAttack = Math.max(attackTime, 0.01); // Minimo 10ms
            const improvedRelease = Math.max(releaseTime, 0.05); // Minimo 50ms

            if (synthesisType === 'pure') {
                // Pure sine wave
                const osc = sonificationContext.createOscillator();
                const filter = sonificationContext.createBiquadFilter();
                const gain = sonificationContext.createGain();
                const panner = sonificationContext.createStereoPanner();
                const dryGain = sonificationContext.createGain();
                const wetGain = sonificationContext.createGain();

                osc.type = 'sine';
                osc.frequency.value = frequency;

                // Filter
                filter.type = 'lowpass';
                filter.frequency.value = filterCutoff;
                filter.Q.value = resonance;

                // Envelope migliorato
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(gainValue, now + improvedAttack);
                gain.gain.setValueAtTime(gainValue, now + duration - improvedRelease);
                gain.gain.linearRampToValueAtTime(0, now + duration);

                panner.pan.value = pan;

                // Dry/Wet mix: 80% dry, 20% wet
                dryGain.gain.value = 0.8;
                wetGain.gain.value = 0.2;

                // Routing: osc -> filter -> gain -> panner -> [dry->compressor, wet->reverb]
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(panner);

                panner.connect(dryGain);
                panner.connect(wetGain);

                dryGain.connect(masterCompressor);
                wetGain.connect(masterReverb);

                osc.start(now);
                osc.stop(now + duration);
                sonificationOscillators.push(osc);

            } else if (synthesisType === 'harmonic') {
                // Additive synthesis with harmonics (migliorato)
                const harmonics = [1, 2, 3, 4, 5, 6];
                const harmAmps = [1.0, 0.6, 0.4, 0.25, 0.15, 0.1];

                harmonics.forEach((harmonic, i) => {
                    const osc = sonificationContext.createOscillator();
                    const filter = sonificationContext.createBiquadFilter();
                    const gain = sonificationContext.createGain();
                    const panner = sonificationContext.createStereoPanner();
                    const dryGain = sonificationContext.createGain();
                    const wetGain = sonificationContext.createGain();

                    osc.type = 'sine';
                    osc.frequency.value = frequency * harmonic;

                    // Filter
                    filter.type = 'lowpass';
                    filter.frequency.value = filterCutoff;
                    filter.Q.value = resonance;

                    // Envelope migliorato per ogni armonica
                    const harmGain = gainValue * harmAmps[i];
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(harmGain, now + improvedAttack);
                    gain.gain.setValueAtTime(harmGain, now + duration - improvedRelease);
                    gain.gain.linearRampToValueAtTime(0, now + duration);

                    panner.pan.value = pan + (Math.random() * 0.1 - 0.05); // Leggero stereo spread

                    // Dry/Wet mix
                    dryGain.gain.value = 0.8;
                    wetGain.gain.value = 0.2;

                    // Routing
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(panner);

                    panner.connect(dryGain);
                    panner.connect(wetGain);

                    dryGain.connect(masterCompressor);
                    wetGain.connect(masterReverb);

                    osc.start(now);
                    osc.stop(now + duration);
                    sonificationOscillators.push(osc);
                });

            } else if (synthesisType === 'filtered') {
                // Sawtooth with lowpass filter
                const osc = sonificationContext.createOscillator();
                const filter = sonificationContext.createBiquadFilter();
                const gain = sonificationContext.createGain();
                const panner = sonificationContext.createStereoPanner();
                const dryGain = sonificationContext.createGain();
                const wetGain = sonificationContext.createGain();

                osc.type = 'sawtooth';
                osc.frequency.value = frequency;

                filter.type = 'lowpass';
                filter.frequency.value = filterCutoff;
                filter.Q.value = resonance;

                // Envelope migliorato
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(gainValue, now + improvedAttack);
                gain.gain.setValueAtTime(gainValue, now + duration - improvedRelease);
                gain.gain.linearRampToValueAtTime(0, now + duration);

                panner.pan.value = pan;

                // Dry/Wet mix
                dryGain.gain.value = 0.8;
                wetGain.gain.value = 0.2;

                // Routing
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(panner);

                panner.connect(dryGain);
                panner.connect(wetGain);

                dryGain.connect(masterCompressor);
                wetGain.connect(masterReverb);

                osc.start(now);
                osc.stop(now + duration);
                sonificationOscillators.push(osc);

            } else if (synthesisType === 'rich') {
                // Multi-harmonic rich sound
                const harmonics = [1, 1.5, 2, 2.5, 3, 4, 5, 6];
                const harmAmps = [1.0, 0.6, 0.5, 0.3, 0.25, 0.2, 0.15, 0.1];

                harmonics.forEach((harmonic, i) => {
                    const osc = sonificationContext.createOscillator();
                    const filter = sonificationContext.createBiquadFilter();
                    const gain = sonificationContext.createGain();
                    const panner = sonificationContext.createStereoPanner();
                    const dryGain = sonificationContext.createGain();
                    const wetGain = sonificationContext.createGain();

                    osc.type = i % 2 === 0 ? 'sine' : 'triangle';
                    osc.frequency.value = frequency * harmonic;

                    // Filter
                    filter.type = 'lowpass';
                    filter.frequency.value = filterCutoff;
                    filter.Q.value = resonance;

                    // Envelope migliorato
                    const harmGain = gainValue * harmAmps[i] * 0.4;
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(harmGain, now + improvedAttack);
                    gain.gain.setValueAtTime(harmGain, now + duration - improvedRelease);
                    gain.gain.linearRampToValueAtTime(0, now + duration);

                    panner.pan.value = pan + (Math.random() * 0.2 - 0.1);

                    // Dry/Wet mix
                    dryGain.gain.value = 0.75;
                    wetGain.gain.value = 0.25;

                    // Routing
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(panner);

                    panner.connect(dryGain);
                    panner.connect(wetGain);

                    dryGain.connect(masterCompressor);
                    wetGain.connect(masterReverb);

                    osc.start(now);
                    osc.stop(now + duration);
                    sonificationOscillators.push(osc);
                });

            } else if (synthesisType === 'granular') {
                // Granular synthesis simulation
                const grains = 5;
                const grainDuration = duration / 3;

                for (let g = 0; g < grains; g++) {
                    const osc = sonificationContext.createOscillator();
                    const filter = sonificationContext.createBiquadFilter();
                    const gain = sonificationContext.createGain();
                    const panner = sonificationContext.createStereoPanner();
                    const dryGain = sonificationContext.createGain();
                    const wetGain = sonificationContext.createGain();

                    const freqVariation = frequency * (0.98 + Math.random() * 0.04);
                    osc.type = 'sine';
                    osc.frequency.value = freqVariation;

                    // Filter
                    filter.type = 'lowpass';
                    filter.frequency.value = filterCutoff;
                    filter.Q.value = resonance;

                    const startTime = now + (g * duration / grains);
                    const grainGain = gainValue * 0.25;

                    // Envelope con attack/release migliorato
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(grainGain, startTime + Math.max(grainDuration * 0.3, 0.01));
                    gain.gain.linearRampToValueAtTime(0, startTime + grainDuration);

                    panner.pan.value = pan + (Math.random() * 0.4 - 0.2);

                    // Dry/Wet mix
                    dryGain.gain.value = 0.7;
                    wetGain.gain.value = 0.3;

                    // Routing
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(panner);

                    panner.connect(dryGain);
                    panner.connect(wetGain);

                    dryGain.connect(masterCompressor);
                    wetGain.connect(masterReverb);

                    osc.start(startTime);
                    osc.stop(startTime + grainDuration);
                    sonificationOscillators.push(osc);
                }

            } else if (synthesisType === 'noise') {
                // Filtered noise
                const bufferSize = sonificationContext.sampleRate * duration;
                const buffer = sonificationContext.createBuffer(1, bufferSize, sonificationContext.sampleRate);
                const data = buffer.getChannelData(0);

                // Generate noise
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = sonificationContext.createBufferSource();
                const filter = sonificationContext.createBiquadFilter();
                const gain = sonificationContext.createGain();
                const panner = sonificationContext.createStereoPanner();
                const dryGain = sonificationContext.createGain();
                const wetGain = sonificationContext.createGain();

                noise.buffer = buffer;

                filter.type = 'bandpass';
                filter.frequency.value = frequency;
                filter.Q.value = 10;

                // Envelope migliorato
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(gainValue * 0.4, now + improvedAttack);
                gain.gain.setValueAtTime(gainValue * 0.4, now + duration - improvedRelease);
                gain.gain.linearRampToValueAtTime(0, now + duration);

                panner.pan.value = pan;

                // Dry/Wet mix
                dryGain.gain.value = 0.6;
                wetGain.gain.value = 0.4;

                // Routing
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(panner);

                panner.connect(dryGain);
                panner.connect(wetGain);

                dryGain.connect(masterCompressor);
                wetGain.connect(masterReverb);

                noise.start(now);
                sonificationOscillators.push(noise);
            }
        }

        // ========================================
        // SOUNDSCAPE MAP - LEAFLET.JS IMPLEMENTATION
        // ========================================

        var leafletMap = null;
        var mapMarkers = [];
        var soundscapeData = [];
        var currentAudioBlob = null;
        var mediaRecorder = null;
        var recordingChunks = [];
        var recordingTimer = null;
        var recordingSeconds = 0;
        var pendingMarkerCoords = null;

        // Spectrum Analyzer variables
        var spectrumAudioContext = null;
        var spectrumAnalyser = null;
        var spectrumDataArray = null;
        var spectrumAnimationId = null;
        var spectrumCanvas = null;
        var spectrumCtx = null;
        var spectrumImageData = null; // For scrolling effect
        var spectrumMediaElementSource = null; // Track media element source to avoid recreating
        var spectrumStreamSource = null; // MediaStreamSource for recording (needs disconnect)
        var audioPreviewSource = null; // MediaElementSource for preview player (created once)

        // Exercise recorder variables
        var exerciseMediaRecorder = null;
        var exerciseRecordingChunks = [];
        var exerciseRecordingTimer = null;
        var exerciseRecordingSeconds = 0;
        var exerciseRecordedAudios = []; // Array of {blob, timestamp, name}
        var tempMarker = null;

        // Category icons mapping
        const categoryIcons = {
            traffic: '🚗',
            market: '🛒',
            voices: '👥',
            industrial: '🏭',
            railway: '🚂',
            coastal: '🌊',
            forest: '🌲',
            park: '🌳',
            construction: '🚧',
            airport: '✈️',
            other: '📌'
        };

        const categoryColors = {
            traffic: '#e74c3c',
            market: '#f39c12',
            voices: '#3498db',
            industrial: '#95a5a6',
            railway: '#9b59b6',
            coastal: '#1abc9c',
            forest: '#27ae60',
            park: '#2ecc71',
            construction: '#e67e22',
            airport: '#34495e',
            other: '#7f8c8d'
        };

        // Initialize map when section becomes visible
        function initializeSoundscapeMap() {
            console.log('🗺️ Initializing Soundscape Map...');

            if (leafletMap) {
                // Map already exists, refresh and reload markers
                console.log('Map exists, refreshing and reloading markers...');
                leafletMap.invalidateSize();

                // Remove all existing markers from map
                mapMarkers.forEach(m => {
                    if (m.marker) {
                        leafletMap.removeLayer(m.marker);
                    }
                });
                mapMarkers = [];

                // Reload markers from localStorage
                loadSoundscapeData();
                updateMarkersList();
                return;
            }

            // Create map centered on Italy
            try {
                leafletMap = L.map('leafletMap').setView([43.7696, 11.2558], 6);

                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors',
                    maxZoom: 19
                }).addTo(leafletMap);

                // Add click event to add markers
                leafletMap.on('click', function(e) {
                    // Save coordinates for marker placement
                    pendingMarkerCoords = e.latlng;

                    // Show temporary marker at click location
                    if (tempMarker) {
                        leafletMap.removeLayer(tempMarker);
                    }

                    tempMarker = L.marker([e.latlng.lat, e.latlng.lng], {
                        icon: L.divIcon({
                            html: '<div style="font-size: 28px;">📍</div>',
                            className: 'custom-marker',
                            iconSize: [30, 30],
                            iconAnchor: [15, 30]
                        })
                    }).addTo(leafletMap);

                    // Scroll to form
                    document.getElementById('markerCategory').scrollIntoView({ behavior: 'smooth', block: 'center' });
                });

                // Load saved markers
                loadSoundscapeData();

                console.log('✅ Map initialized');
            } catch (error) {
                console.error('❌ Error initializing map:', error);
                alert('Errore inizializzazione mappa: ' + error.message);
            }
        }

        // Recording controls
        document.getElementById('startRecording').addEventListener('click', async function() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                mediaRecorder = new MediaRecorder(stream);
                recordingChunks = [];
                recordingSeconds = 0;

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        recordingChunks.push(e.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    // Use compatible audio format for iOS
                    const mimeType = mediaRecorder.mimeType || 'audio/mp4';
                    currentAudioBlob = new Blob(recordingChunks, { type: mimeType });
                    showAudioPreview(currentAudioBlob);

                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());

                    // Show recording completed message
                    showToast('✅ Registrazione completata!', 'success');

                    // Save marker if coordinates are set
                    if (pendingMarkerCoords) {
                        saveMarker();
                    }
                };

                mediaRecorder.start();

                // Start spectrum visualization
                startSpectrumVisualization(stream);

                // Update UI
                document.getElementById('startRecording').style.display = 'none';
                document.getElementById('stopRecording').style.display = 'block';
                document.getElementById('recordingTime').style.display = 'block';

                // Start timer
                recordingTimer = setInterval(() => {
                    recordingSeconds++;
                    const mins = Math.floor(recordingSeconds / 60);
                    const secs = recordingSeconds % 60;
                    document.getElementById('recordingTime').textContent =
                        `⏱️ ${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                }, 1000);

            } catch (error) {
                console.error('Error accessing microphone:', error);
                alert('❌ Impossibile accedere al microfono. Verifica i permessi del browser.');
            }
        });

        document.getElementById('stopRecording').addEventListener('click', function() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                clearInterval(recordingTimer);

                // Stop spectrum visualization
                stopSpectrumVisualization();

                // Reset UI
                document.getElementById('startRecording').style.display = 'block';
                document.getElementById('stopRecording').style.display = 'none';
                document.getElementById('recordingTime').style.display = 'none';
            }
        });

        // File upload
        document.getElementById('audioFileUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                currentAudioBlob = file;
                showAudioPreview(file);

                // Save marker if coordinates are set
                if (pendingMarkerCoords) {
                    saveMarker();
                }
            }
        });

        // Show audio preview
        function showAudioPreview(audioBlob) {
            const preview = document.getElementById('audioPreview');
            const player = document.getElementById('audioPreviewPlayer');

            // Revoke previous URL to prevent memory leaks
            if (player.src && player.src.startsWith('blob:')) {
                URL.revokeObjectURL(player.src);
            }

            // Update player source
            const url = URL.createObjectURL(audioBlob);
            player.src = url;
            preview.style.display = 'block';

            // Use native HTML5 controls for playback
            // NO spectrum analyzer for preview player (avoiding conflicts)
            // Spectrum is active only during recording and marker playback
        }

        // ==================== SPECTRUM ANALYZER ====================

        function initSpectrumAnalyzer() {
            spectrumCanvas = document.getElementById('spectrumCanvas');
            if (!spectrumCanvas) return;

            spectrumCtx = spectrumCanvas.getContext('2d');
            spectrumAudioContext = new (window.AudioContext || window.webkitAudioContext)();
            spectrumAnalyser = spectrumAudioContext.createAnalyser();
            spectrumAnalyser.fftSize = 2048;
            spectrumAnalyser.smoothingTimeConstant = 0.8;
            spectrumDataArray = new Uint8Array(spectrumAnalyser.frequencyBinCount);
        }

        // Heat map color scheme (Blue -> Cyan -> Green -> Yellow -> Red)
        function getSpectrumColor(normalized) {
            let r, g, b;

            if (normalized < 0.1) {
                r = 0; g = 0; b = Math.floor(normalized * 500);
            } else if (normalized < 0.3) {
                const t = (normalized - 0.1) / 0.2;
                r = 0; g = Math.floor(t * 100); b = Math.floor(100 + t * 155);
            } else if (normalized < 0.5) {
                const t = (normalized - 0.3) / 0.2;
                r = 0; g = Math.floor(100 + t * 155); b = Math.floor(255 - t * 100);
            } else if (normalized < 0.7) {
                const t = (normalized - 0.5) / 0.2;
                r = Math.floor(t * 255); g = 255; b = 0;
            } else {
                const t = (normalized - 0.7) / 0.3;
                r = 255; g = Math.floor(255 - t * 255); b = 0;
            }

            return `rgb(${r}, ${g}, ${b})`;
        }

        function startSpectrumVisualization(stream) {
            // ALWAYS reinitialize to ensure clean state
            console.log('🎯 Reinitializing spectrum analyzer for new recording...');

            // Disconnect and cleanup previous source if exists
            if (spectrumStreamSource) {
                try {
                    spectrumStreamSource.disconnect();
                    console.log('🔌 Disconnected previous stream source');
                } catch (e) {
                    console.warn('Could not disconnect previous source:', e);
                }
                spectrumStreamSource = null;
            }

            // Close previous AudioContext if exists
            if (spectrumAudioContext) {
                try {
                    spectrumAudioContext.close();
                    console.log('🔒 Closed previous AudioContext');
                } catch (e) {
                    console.warn('Could not close previous AudioContext:', e);
                }
            }

            // Reinitialize analyzer (creates new AudioContext)
            initSpectrumAnalyzer();
            console.log('✅ Spectrum analyzer reinitialized');

            // Connect stream to NEW analyser
            spectrumStreamSource = spectrumAudioContext.createMediaStreamSource(stream);
            spectrumStreamSource.connect(spectrumAnalyser);
            console.log('🔌 Connected new stream source to analyzer');

            // Update status
            document.getElementById('spectrumStatus').textContent = '🔴 Analizzando...';
            document.getElementById('spectrumStatus').style.color = '#00ff00';
            document.getElementById('spectrumStatus').style.background = 'rgba(0,255,0,0.2)';

            // Start animation
            drawSpectrum();
        }

        function stopSpectrumVisualization() {
            if (spectrumAnimationId) {
                cancelAnimationFrame(spectrumAnimationId);
                spectrumAnimationId = null;
            }

            // Disconnect stream source
            if (spectrumStreamSource) {
                try {
                    spectrumStreamSource.disconnect();
                    spectrumStreamSource = null;
                    console.log('🔌 Stream source disconnected');
                } catch (e) {
                    console.warn('Could not disconnect stream source:', e);
                }
            }

            // Update status
            document.getElementById('spectrumStatus').textContent = 'In attesa...';
            document.getElementById('spectrumStatus').style.color = '#888';
            document.getElementById('spectrumStatus').style.background = 'rgba(255,255,255,0.1)';

            // Clear canvas and reset imageData
            if (spectrumCtx && spectrumCanvas) {
                spectrumCtx.fillStyle = '#0a0a15';
                spectrumCtx.fillRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
                spectrumImageData = null;
            }
        }

        function drawSpectrum() {
            spectrumAnimationId = requestAnimationFrame(drawSpectrum);

            if (!spectrumAnalyser || !spectrumDataArray || !spectrumCtx) return;

            // Get frequency data
            spectrumAnalyser.getByteFrequencyData(spectrumDataArray);

            const width = spectrumCanvas.width;
            const height = spectrumCanvas.height;

            // Scroll existing image to the left
            if (spectrumImageData) {
                spectrumCtx.putImageData(spectrumImageData, -1, 0);
            } else {
                // First frame: clear canvas
                spectrumCtx.fillStyle = '#0a0a15';
                spectrumCtx.fillRect(0, 0, width, height);
            }

            // Calculate frequency range: 20 Hz to 10 kHz
            const sampleRate = spectrumAudioContext.sampleRate || 48000;
            const nyquist = sampleRate / 2;
            const binCount = spectrumDataArray.length;
            const hzPerBin = nyquist / binCount;

            // Find bin indices for 20 Hz and 10000 Hz
            const startBin = Math.floor(20 / hzPerBin);
            const endBin = Math.floor(10000 / hzPerBin);
            const usefulBins = endBin - startBin;

            // Draw new column on the right edge
            const sliceWidth = 1;
            const frequencyBands = height;

            for (let i = 0; i < frequencyBands; i++) {
                // Linear scale
                const binIndex = Math.max(startBin, Math.min(endBin - 1,
                    startBin + Math.floor((frequencyBands - i - 1) * usefulBins / frequencyBands)));

                const value = spectrumDataArray[binIndex] || 0;
                const normalized = value / 255;

                const color = getSpectrumColor(normalized);

                spectrumCtx.fillStyle = color;
                spectrumCtx.fillRect(width - sliceWidth, i, sliceWidth, 1);
            }

            // Save current state for next frame
            spectrumImageData = spectrumCtx.getImageData(0, 0, width, height);

            // Draw subtle grid lines
            spectrumCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            spectrumCtx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                const y = (height / 4) * i;
                spectrumCtx.beginPath();
                spectrumCtx.moveTo(0, y);
                spectrumCtx.lineTo(width, y);
                spectrumCtx.stroke();
            }
        }

        // ==================== EXERCISE RECORDER FUNCTIONS ====================

        async function startExerciseRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                exerciseMediaRecorder = new MediaRecorder(stream);
                exerciseRecordingChunks = [];
                exerciseRecordingSeconds = 0;

                exerciseMediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        exerciseRecordingChunks.push(e.data);
                    }
                };

                exerciseMediaRecorder.onstop = () => {
                    // Use compatible audio format for iOS
                    const mimeType = exerciseMediaRecorder.mimeType || 'audio/mp4';
                    const audioBlob = new Blob(exerciseRecordingChunks, { type: mimeType });

                    // Add to recorded audios array
                    const timestamp = new Date().toISOString();
                    const name = `Registrazione ${exerciseRecordedAudios.length + 1}`;
                    exerciseRecordedAudios.push({ blob: audioBlob, timestamp, name });

                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());

                    // Update UI
                    displayRecordedAudios();
                };

                exerciseMediaRecorder.start();

                // Update UI
                document.getElementById('startRecordingBtn').disabled = true;
                document.getElementById('startRecordingBtn').style.background = '#999';
                document.getElementById('startRecordingBtn').style.cursor = 'not-allowed';

                document.getElementById('stopRecordingBtn').disabled = false;
                document.getElementById('stopRecordingBtn').style.background = '#2d5f4f';
                document.getElementById('stopRecordingBtn').style.cursor = 'pointer';

                document.getElementById('recordingStatus').style.display = 'block';

                // Start timer
                exerciseRecordingTimer = setInterval(() => {
                    exerciseRecordingSeconds++;
                    const mins = Math.floor(exerciseRecordingSeconds / 60);
                    const secs = exerciseRecordingSeconds % 60;
                    document.getElementById('recordingTimer').textContent =
                        `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                }, 1000);

            } catch (error) {
                console.error('Error accessing microphone:', error);
                alert('❌ Impossibile accedere al microfono.\n\nVerifica i permessi del browser.');
            }
        }

        function stopExerciseRecording() {
            if (exerciseMediaRecorder && exerciseMediaRecorder.state !== 'inactive') {
                exerciseMediaRecorder.stop();
                clearInterval(exerciseRecordingTimer);

                // Reset UI
                document.getElementById('startRecordingBtn').disabled = false;
                document.getElementById('startRecordingBtn').style.background = '#d32f2f';
                document.getElementById('startRecordingBtn').style.cursor = 'pointer';

                document.getElementById('stopRecordingBtn').disabled = true;
                document.getElementById('stopRecordingBtn').style.background = '#666';
                document.getElementById('stopRecordingBtn').style.cursor = 'not-allowed';

                document.getElementById('recordingStatus').style.display = 'none';
                document.getElementById('recordingTimer').textContent = '00:00';
            }
        }

        function displayRecordedAudios() {
            const container = document.getElementById('recordedAudiosList');

            if (exerciseRecordedAudios.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = '<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #ddd;">';
            html += '<p style="font-size: 13px; font-weight: 600; color: #2d5f4f; margin-bottom: 8px;">📼 Registrazioni salvate:</p>';

            exerciseRecordedAudios.forEach((audio, index) => {
                const url = URL.createObjectURL(audio.blob);
                html += `
                    <div style="background: white; padding: 10px; border-radius: 6px; margin-bottom: 8px; border: 1px solid #e0e0e0;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                            <span style="font-weight: 600; font-size: 13px;">${audio.name}</span>
                            <button onclick="deleteRecordedAudio(${index})" style="background: #f44336; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                🗑️ Elimina
                            </button>
                        </div>
                        <audio controls style="width: 100%; height: 32px;" src="${url}"></audio>
                    </div>
                `;
            });

            html += '</div>';
            container.innerHTML = html;
        }

        function deleteRecordedAudio(index) {
            if (confirm('Vuoi eliminare questa registrazione?')) {
                exerciseRecordedAudios.splice(index, 1);
                displayRecordedAudios();
            }
        }

        // ==================== END EXERCISE RECORDER FUNCTIONS ====================

        // Save marker to map and storage
        // Aggiungi marker da esercizio completato
        async function addExerciseMarkerToMap(exerciseData, exerciseId) {
            console.log('🎯 addExerciseMarkerToMap called with:', {
                exerciseId,
                hasCoords: !!exerciseData.locationCoords,
                lat: exerciseData.locationCoords?.lat,
                lon: exerciseData.locationCoords?.lon,
                audioFiles: exerciseData.audioFiles?.length || 0
            });

            if (!exerciseData.locationCoords || !exerciseData.locationCoords.lat) {
                console.error('❌ Coordinate non disponibili per il marker');
                alert('❌ Impossibile creare marker: coordinate GPS non disponibili');
                return;
            }

            // IMPORTANTE: Carica soundscapeData da localStorage prima di controllare il limite
            // Questo perché quando salviamo da Esercizi, soundscapeData potrebbe essere vuoto
            const saved = localStorage.getItem('soundscapeMarkers');
            if (saved) {
                try {
                    soundscapeData = JSON.parse(saved);
                    console.log('📂 Loaded existing markers from localStorage:', soundscapeData.length);
                } catch (error) {
                    console.error('Error loading markers from localStorage:', error);
                }
            }

            console.log('✅ Coordinates OK, checking marker limit...');
            console.log('Current markers count:', soundscapeData.length);
            console.log('isPremium:', isPremium);

            // FREE VERSION: Check marker limit (20 markers max)
            if (!isPremium && soundscapeData.length >= FREE_LIMITS.markers) {
                console.warn('⚠️ Marker limit reached');
                alert(`⚠️ Versione Gratuita: Massimo ${FREE_LIMITS.markers} markers sulla mappa\n\n🌟 Passa a Premium per markers illimitati e backup sicuro!`);
                showUpgradeModal();
                return;
            }

            console.log('✅ Marker limit OK, creating marker...');

            // Determina categoria basata sul tipo di esercizio
            const category = 'park'; // Default: parco urbano (soundscape exercise)

            // Create marker data
            const markerData = {
                id: Date.now(),
                lat: parseFloat(exerciseData.locationCoords.lat),
                lng: parseFloat(exerciseData.locationCoords.lon),
                category: category,
                notes: `📝 ${exerciseData.exercise.title}\n\n${exerciseData.notes || 'Nessuna nota'}`,
                timestamp: exerciseData.timestamp,
                hasAudio: exerciseData.audioFiles && exerciseData.audioFiles.length > 0,
                exerciseTitle: exerciseData.exercise.title,
                exerciseId: exerciseId  // ID dell'esercizio completo in IndexedDB
            };

            // Save audio to IndexedDB if present
            if (exerciseData.audioFiles && exerciseData.audioFiles.length > 0) {
                // Usa il primo file audio per il marker
                // exerciseData.audioFiles contiene già Blob diretti (non URLs)
                const audioBlob = exerciseData.audioFiles[0];
                await saveAudioToIndexedDB(markerData.id, audioBlob);
                console.log('✅ Audio saved to IndexedDB for marker:', markerData.id);
            }

            // Add marker to map (solo se la mappa è inizializzata)
            console.log('🗺️ leafletMap exists:', !!leafletMap);

            if (leafletMap) {
                console.log('✅ Adding marker to Leaflet map at:', markerData.lat, markerData.lng);

                const icon = L.divIcon({
                    html: `<div style="font-size: 28px;">${categoryIcons[category]}</div>`,
                    className: 'custom-marker',
                    iconSize: [30, 30],
                    iconAnchor: [15, 30]
                });

                const marker = L.marker([markerData.lat, markerData.lng], { icon: icon }).addTo(leafletMap);

                // Create popup content
                const popupContent = createPopupContent(markerData);
                marker.bindPopup(popupContent, { maxWidth: 280, minWidth: 200 });

                mapMarkers.push({ marker: marker, data: markerData });
                console.log('✅ Marker added to mapMarkers array. Total markers:', mapMarkers.length);
            } else {
                console.warn('⚠️ leafletMap not initialized, marker will be saved but not displayed');
            }

            soundscapeData.push(markerData);
            console.log('✅ Marker added to soundscapeData. Total data:', soundscapeData.length);

            // Save to localStorage
            saveSoundscapeData();

            // Update markers list (se siamo nella sezione map)
            if (document.getElementById('map').classList.contains('active')) {
                updateMarkersList();
            }

            // Update premium UI banner with new marker count
            if (typeof updatePremiumUI === 'function') {
                updatePremiumUI();
            }

            console.log('✅ Marker aggiunto alla mappa per esercizio:', exerciseData.exercise.title);
        }

        // Detect GPS location for map marker
        function detectMapGPSLocation() {
            if (!navigator.geolocation) {
                alert('❌ La geolocalizzazione non è supportata dal tuo dispositivo');
                return;
            }

            // Show loading state
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '🔄 Rilevamento in corso...';
            btn.disabled = true;

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;

                    // Remove old temp marker if exists
                    if (tempMarker) {
                        leafletMap.removeLayer(tempMarker);
                    }

                    // Create new marker at current location
                    tempMarker = L.marker([lat, lng], {
                        icon: L.divIcon({
                            html: '<div style="font-size: 28px;">📍</div>',
                            className: 'custom-marker',
                            iconSize: [30, 30],
                            iconAnchor: [15, 30]
                        })
                    }).addTo(leafletMap);

                    // Set pending coordinates
                    pendingMarkerCoords = { lat, lng };

                    // Center map on current location
                    leafletMap.setView([lat, lng], 15);

                    // Scroll to form
                    document.getElementById('markerCategory').scrollIntoView({ behavior: 'smooth', block: 'center' });

                    // Restore button
                    btn.innerHTML = originalText;
                    btn.disabled = false;

                    alert('✅ Posizione rilevata! Ora compila i dettagli del marker qui sotto.');
                },
                (error) => {
                    console.error('Errore geolocalizzazione:', error);
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    alert('❌ Impossibile rilevare la posizione. Controlla le impostazioni GPS e riprova.');
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        async function saveMarker() {
            if (!pendingMarkerCoords) {
                alert('❌ Clicca prima sulla mappa per posizionare un marker!');
                return;
            }

            // FREE VERSION: Check marker limit (20 markers max)
            if (!isPremium && soundscapeData.length >= FREE_LIMITS.markers) {
                alert(`⚠️ Versione Gratuita: Massimo ${FREE_LIMITS.markers} markers sulla mappa\n\n🌟 Passa a Premium per markers illimitati e backup sicuro!`);
                showUpgradeModal();
                return;
            }

            const category = document.getElementById('markerCategory').value;
            const notes = document.getElementById('markerNotes').value.trim();

            // Create marker data
            const markerData = {
                id: Date.now(),
                lat: pendingMarkerCoords.lat,
                lng: pendingMarkerCoords.lng,
                category: category,
                notes: notes || categoryIcons[category] || '',
                timestamp: new Date().toISOString(),
                hasAudio: currentAudioBlob !== null
            };

            // Save audio to IndexedDB if present
            if (currentAudioBlob) {
                await saveAudioToIndexedDB(markerData.id, currentAudioBlob);
            }

            // Remove temporary marker
            if (tempMarker) {
                leafletMap.removeLayer(tempMarker);
                tempMarker = null;
            }

            // Add marker to map
            const icon = L.divIcon({
                html: `<div style="font-size: 28px;">${categoryIcons[category]}</div>`,
                className: 'custom-marker',
                iconSize: [30, 30],
                iconAnchor: [15, 30]
            });

            const marker = L.marker([markerData.lat, markerData.lng], { icon: icon }).addTo(leafletMap);

            // Create popup content
            const popupContent = createPopupContent(markerData);
            marker.bindPopup(popupContent, { maxWidth: 280, minWidth: 200 });

            mapMarkers.push({ marker: marker, data: markerData });
            soundscapeData.push(markerData);

            // Save to localStorage
            saveSoundscapeData();

            // Update markers list
            updateMarkersList();

            // Update premium UI banner with new marker count
            if (typeof updatePremiumUI === 'function') {
                updatePremiumUI();
            }

            // Reset form
            document.getElementById('markerNotes').value = '';
            document.getElementById('audioPreview').style.display = 'none';
            currentAudioBlob = null;
            pendingMarkerCoords = null;

            alert('✅ Marker salvato con successo!');
        }

        // Show toast notification
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 16px 24px;
                border-radius: 8px;
                font-weight: 600;
                font-size: 16px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: slideDown 0.3s ease-out;
            `;

            // Add animation keyframes if not already added
            if (!document.getElementById('toastAnimationStyles')) {
                const style = document.createElement('style');
                style.id = 'toastAnimationStyles';
                style.textContent = `
                    @keyframes slideDown {
                        from {
                            transform: translateX(-50%) translateY(-100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(-50%) translateY(0);
                            opacity: 1;
                        }
                    }
                    @keyframes slideUp {
                        from {
                            transform: translateX(-50%) translateY(0);
                            opacity: 1;
                        }
                        to {
                            transform: translateX(-50%) translateY(-100%);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(toast);

            // Remove toast after 3 seconds
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease-out';
                setTimeout(() => {
                    if (toast.parentNode) {
                        document.body.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // Create popup content for marker
        function createPopupContent(markerData) {
            const categoryName = document.querySelector(`#markerCategory option[value="${markerData.category}"]`).textContent;

            let html = `
                <div style="min-width: 200px; max-width: 280px; box-sizing: border-box;">
                    <h4 style="margin: 0 0 10px 0; color: ${categoryColors[markerData.category]}; word-wrap: break-word;">
                        ${categoryIcons[markerData.category]} ${categoryName}
                    </h4>
                    <p style="margin: 0 0 10px 0; font-size: 14px; color: #666;">
                        ${markerData.notes}
                    </p>
                    <p style="margin: 0; font-size: 12px; color: #999;">
                        📅 ${new Date(markerData.timestamp).toLocaleString('it-IT')}
                    </p>
            `;

            if (markerData.hasAudio) {
                html += `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">
                        <div style="display: flex; gap: 8px;">
                            <button onclick="playMarkerAudio(${markerData.id})"
                                    style="flex: 1; padding: 8px; background: #2d5f4f; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 12px;">
                                ▶️ Play
                            </button>
                            <button onclick="stopMarkerAudio()"
                                    style="flex: 1; padding: 8px; background: #d9534f; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 12px;">
                                ⏹️ Stop
                            </button>
                        </div>
                    </div>
                `;
            }

            // Se c'è exerciseId, aggiungi bottone per aprire esercizio completo
            if (markerData.exerciseId) {
                html += `
                    <div style="margin-top: 8px;">
                        <button onclick="openExerciseFromMap(${markerData.exerciseId})"
                                style="width: 100%; padding: 8px; background: #4a9d7f; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                            📄 Vedi Esercizio Completo
                        </button>
                    </div>
                `;
            }

            html += `
                    <div style="margin-top: 8px;">
                        <button onclick="deleteMarker(${markerData.id})"
                                style="width: 100%; padding: 6px; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                            🗑️ Elimina
                        </button>
                    </div>
                </div>
            `;

            return html;
        }

        // Apri esercizio completo dalla mappa
        window.openExerciseFromMap = async function(exerciseId) {
            try {
                // Chiudi eventuali popup aperti
                if (leafletMap) {
                    leafletMap.closePopup();
                }

                // Vai alla sezione dashboard
                showSection('dashboard');

                // Apri il modal con l'esercizio completo
                await viewCompletedExercise(exerciseId);

                console.log('✅ Esercizio aperto:', exerciseId);
            } catch (error) {
                console.error('Errore apertura esercizio:', error);
                alert('❌ Errore durante l\'apertura dell\'esercizio!');
            }
        };

        // Play audio from marker
        // Global variable to track currently playing audio
        let currentlyPlayingAudio = null;

        window.playMarkerAudio = async function(markerId) {
            try {
                // Stop any currently playing audio
                if (currentlyPlayingAudio) {
                    currentlyPlayingAudio.pause();
                    currentlyPlayingAudio.currentTime = 0;
                    currentlyPlayingAudio = null;
                }

                const audioBlob = await getAudioFromIndexedDB(markerId);
                if (audioBlob) {
                    // Convert blob to base64 data URL for iOS compatibility
                    const reader = new FileReader();
                    reader.onloadend = function() {
                        const audio = new Audio(reader.result);
                        currentlyPlayingAudio = audio;

                        audio.onerror = (e) => {
                            console.error('Audio playback error:', e);
                            alert('❌ Impossibile riprodurre questo formato audio.');
                            currentlyPlayingAudio = null;
                        };

                        // Reset when audio ends
                        audio.onended = () => {
                            currentlyPlayingAudio = null;
                            console.log('✅ Audio playback finished');
                        };

                        // Play audio directly (no spectrum analyzer to avoid createMediaElementSource conflicts)
                        audio.play().catch(err => {
                            console.error('Play error:', err);
                            alert('❌ Errore riproduzione: ' + err.message);
                            currentlyPlayingAudio = null;
                        });
                    };
                    reader.readAsDataURL(audioBlob);
                } else {
                    alert('❌ Audio non trovato');
                }
            } catch (error) {
                console.error('Error playing audio:', error);
                alert('❌ Errore: ' + error.message);
            }
        };

        window.stopMarkerAudio = function() {
            if (currentlyPlayingAudio) {
                currentlyPlayingAudio.pause();
                currentlyPlayingAudio.currentTime = 0;
                currentlyPlayingAudio = null;
                console.log('⏹️ Audio playback stopped');
            }
            // No alert needed - silent stop
        };

        // Delete marker
        window.deleteMarker = function(markerId) {
            if (!confirm('Sei sicuro di voler eliminare questo marker?')) return;

            // Remove from map
            const markerIndex = mapMarkers.findIndex(m => m.data.id === markerId);
            if (markerIndex !== -1) {
                leafletMap.removeLayer(mapMarkers[markerIndex].marker);
                mapMarkers.splice(markerIndex, 1);
            }

            // Remove from data
            const dataIndex = soundscapeData.findIndex(m => m.id === markerId);
            if (dataIndex !== -1) {
                soundscapeData.splice(dataIndex, 1);
            }

            // Remove audio from IndexedDB
            deleteAudioFromIndexedDB(markerId);

            // Save to localStorage
            saveSoundscapeData();

            // Update list
            updateMarkersList();

            alert('✅ Marker eliminato');
        };

        // Delete all markers
        window.deleteAllMarkers = async function() {
            if (soundscapeData.length === 0) {
                alert('ℹ️ Nessun marker da eliminare');
                return;
            }

            if (!confirm(`⚠️ Sei sicuro di voler eliminare TUTTI i ${soundscapeData.length} markers?\n\nQuesta azione non può essere annullata!`)) {
                return;
            }

            // Second confirmation for safety
            if (!confirm('⚠️ ULTIMO AVVISO: Questo eliminerà permanentemente tutti i tuoi markers e registrazioni audio!\n\nClicca OK per confermare l\'eliminazione.')) {
                return;
            }

            // Remove all markers from map
            mapMarkers.forEach(m => {
                leafletMap.removeLayer(m.marker);
            });

            // Delete all audio from IndexedDB
            for (const markerData of soundscapeData) {
                await deleteAudioFromIndexedDB(markerData.id);
            }

            // Clear arrays
            mapMarkers = [];
            soundscapeData = [];

            // Clear localStorage
            saveSoundscapeData();

            // Update list
            updateMarkersList();

            // Update premium UI
            if (typeof updatePremiumUI === 'function') {
                updatePremiumUI();
            }

            alert('✅ Tutti i markers sono stati eliminati con successo');
        };

        // Update markers list
        function updateMarkersList() {
            const listDiv = document.getElementById('markersList');

            if (soundscapeData.length === 0) {
                listDiv.innerHTML = '<p style="color: #999; font-style: italic;">Nessun marker salvato</p>';
                return;
            }

            let html = '';
            soundscapeData.forEach(marker => {
                const categoryName = document.querySelector(`#markerCategory option[value="${marker.category}"]`).textContent;
                html += `
                    <div style="padding: 10px; margin-bottom: 8px; background: #f8f9f5; border-radius: 6px; border-left: 3px solid ${categoryColors[marker.category]}; cursor: pointer;"
                         onclick="showMarkerDetails(${marker.id});">
                        <div style="font-weight: 600; color: #2d5f4f; margin-bottom: 4px;">
                            ${categoryIcons[marker.category]} ${marker.notes.substring(0, 30)}${marker.notes.length > 30 ? '...' : ''}
                        </div>
                        <div style="font-size: 12px; color: #999;">
                            ${categoryName}${marker.hasAudio ? ' • 🔊 Audio' : ''}
                        </div>
                    </div>
                `;
            });

            listDiv.innerHTML = html;
        }

        // Show marker details modal
        window.showMarkerDetails = async function(markerId) {
            const marker = soundscapeData.find(m => m.id === markerId);
            if (!marker) {
                alert('❌ Marker non trovato');
                return;
            }

            const categoryName = document.querySelector(`#markerCategory option[value="${marker.category}"]`).textContent;
            const hasAudio = await getAudioFromIndexedDB(markerId);

            const detailsContent = document.getElementById('markerDetailsContent');
            detailsContent.innerHTML = `
                <h2 style="color: #2d5f4f; margin-bottom: 20px;">📍 Dettagli Marker</h2>

                <div style="background: #f0f7f4; padding: 20px; border-radius: 12px; margin-bottom: 20px; border-left: 4px solid ${categoryColors[marker.category]};">
                    <div style="font-size: 32px; text-align: center; margin-bottom: 10px;">
                        ${categoryIcons[marker.category]}
                    </div>
                    <h3 style="color: #2d5f4f; text-align: center; margin-bottom: 5px;">${categoryName}</h3>
                    <p style="color: #666; text-align: center; font-size: 14px; margin: 0;">
                        ${new Date(marker.timestamp).toLocaleString('it-IT')}
                    </p>
                </div>

                <div style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <h4 style="color: #2d5f4f; margin-bottom: 10px;">📝 Note</h4>
                    <p style="color: #333; line-height: 1.6; margin: 0; white-space: pre-wrap;">${marker.notes || 'Nessuna nota'}</p>
                </div>

                <div style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <h4 style="color: #2d5f4f; margin-bottom: 10px;">🌍 Coordinate</h4>
                    <p style="color: #333; margin: 5px 0;"><strong>Latitudine:</strong> ${marker.lat.toFixed(6)}</p>
                    <p style="color: #333; margin: 5px 0;"><strong>Longitudine:</strong> ${marker.lng.toFixed(6)}</p>
                    <button onclick="goToMarkerOnMap(${marker.lat}, ${marker.lng});"
                            style="margin-top: 10px; width: 100%; padding: 12px; background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                        🗺️ Vai alla Posizione sulla Mappa
                    </button>
                </div>

                ${hasAudio ? `
                <div style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <h4 style="color: #2d5f4f; margin-bottom: 10px;">🔊 Registrazione Audio</h4>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="playMarkerAudio(${markerId})"
                                style="flex: 1; padding: 12px; background: linear-gradient(135deg, #2d5f4f 0%, #1e3f33 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                            ▶️ Play
                        </button>
                        <button onclick="stopMarkerAudio()"
                                style="flex: 1; padding: 12px; background: linear-gradient(135deg, #d9534f 0%, #c9302c 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                            ⏹️ Stop
                        </button>
                    </div>
                </div>
                ` : ''}

                <div style="display: flex; gap: 10px;">
                    <button onclick="deleteSingleMarker(${markerId})"
                            style="flex: 1; padding: 12px; background: #d9534f; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                        🗑️ Elimina Marker
                    </button>
                    <button onclick="closeMarkerDetailsModal()"
                            style="flex: 1; padding: 12px; background: #6c757d; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                        ✖️ Chiudi
                    </button>
                </div>
            `;

            document.getElementById('markerDetailsModal').style.display = 'flex';
        };

        // Close marker details modal
        window.closeMarkerDetailsModal = function() {
            document.getElementById('markerDetailsModal').style.display = 'none';
        };

        // Go to marker on map (scroll + open map + zoom)
        window.goToMarkerOnMap = function(lat, lng) {
            // Close the marker details modal
            closeMarkerDetailsModal();

            // Switch to map section
            showMapSection();

            // Scroll to top smoothly
            window.scrollTo({ top: 0, behavior: 'smooth' });

            // Wait for map to initialize, then zoom to marker
            setTimeout(() => {
                if (leafletMap) {
                    leafletMap.setView([lat, lng], 18); // Zoom level 18 for close-up
                }
            }, 500);
        };

        // Delete single marker
        window.deleteSingleMarker = async function(markerId) {
            if (!confirm('Sei sicuro di voler eliminare questo marker?')) {
                return;
            }

            // Remove from soundscapeData array
            const index = soundscapeData.findIndex(m => m.id === markerId);
            if (index > -1) {
                soundscapeData.splice(index, 1);
            }

            // Remove from localStorage
            localStorage.setItem('soundscapeData', JSON.stringify(soundscapeData));

            // Remove audio from IndexedDB
            await deleteAudioFromIndexedDB(markerId);

            // Remove marker from map (correct structure: {marker, data})
            const markerIndex = mapMarkers.findIndex(m => m.data.id === markerId);
            if (markerIndex !== -1) {
                leafletMap.removeLayer(mapMarkers[markerIndex].marker);
                mapMarkers.splice(markerIndex, 1);
            }

            // Update list and close modal
            updateMarkersList();
            closeMarkerDetailsModal();

            alert('✅ Marker eliminato con successo');
        };

        // IndexedDB functions
        function openSoundscapeDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('SoundscapeDB', 1);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('audioFiles')) {
                        db.createObjectStore('audioFiles', { keyPath: 'id' });
                    }
                };
            });
        }

        async function saveAudioToIndexedDB(markerId, audioBlob) {
            try {
                const db = await openSoundscapeDB();
                const transaction = db.transaction(['audioFiles'], 'readwrite');
                const store = transaction.objectStore('audioFiles');

                await store.put({ id: markerId, audio: audioBlob });
                console.log(`✅ Audio saved for marker ${markerId}`);
            } catch (error) {
                console.error('Error saving audio to IndexedDB:', error);
            }
        }

        async function getAudioFromIndexedDB(markerId) {
            try {
                const db = await openSoundscapeDB();
                const transaction = db.transaction(['audioFiles'], 'readonly');
                const store = transaction.objectStore('audioFiles');

                return new Promise((resolve, reject) => {
                    const request = store.get(markerId);
                    request.onsuccess = () => resolve(request.result ? request.result.audio : null);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('Error getting audio from IndexedDB:', error);
                return null;
            }
        }

        async function deleteAudioFromIndexedDB(markerId) {
            try {
                const db = await openSoundscapeDB();
                const transaction = db.transaction(['audioFiles'], 'readwrite');
                const store = transaction.objectStore('audioFiles');

                await store.delete(markerId);
                console.log(`✅ Audio deleted for marker ${markerId}`);
            } catch (error) {
                console.error('Error deleting audio from IndexedDB:', error);
            }
        }

        // LocalStorage functions
        function saveSoundscapeData() {
            try {
                localStorage.setItem('soundscapeMarkers', JSON.stringify(soundscapeData));
                console.log('✅ Markers saved to localStorage');
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function loadSoundscapeData() {
            try {
                const saved = localStorage.getItem('soundscapeMarkers');
                if (saved) {
                    soundscapeData = JSON.parse(saved);

                    // Recreate markers on map
                    soundscapeData.forEach(markerData => {
                        const icon = L.divIcon({
                            html: `<div style="font-size: 28px;">${categoryIcons[markerData.category]}</div>`,
                            className: 'custom-marker',
                            iconSize: [30, 30],
                            iconAnchor: [15, 30]
                        });

                        const marker = L.marker([markerData.lat, markerData.lng], { icon: icon }).addTo(leafletMap);
                        const popupContent = createPopupContent(markerData);
                        marker.bindPopup(popupContent, { maxWidth: 280, minWidth: 200 });

                        mapMarkers.push({ marker: marker, data: markerData });
                    });

                    updateMarkersList();
                    console.log(`✅ Loaded ${soundscapeData.length} markers`);
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
        }

        // ==================== TOOLKIT SECTION ====================

        // Equipment Data
        var equipmentData = {
            recorders: {
                consumer: [
                    {
                        name: 'Zoom H1essential',
                        price: '€80-100',
                        features: ['32-bit float recording standard', 'Compatto e ultraleggero', 'USB-C audio interface', 'Perfetto per principianti'],
                        link: 'https://www.thomann.it/zoom_h1essential.htm'
                    },
                    {
                        name: 'Tascam DR-40X',
                        price: '€140-180',
                        features: ['Dual recording backup', 'USB audio interface', 'XLR/TRS combo inputs', 'Industry standard affidabile'],
                        link: 'https://www.thomann.it/tascam_dr_40x.htm'
                    },
                    {
                        name: 'Zoom H4n Pro',
                        price: '€180-220',
                        features: ['Capsule X/Y ruotabili 120°', '2 input XLR combo', 'Overdubbing multitrack', 'Basso rumore'],
                        link: 'https://www.thomann.it/zoom_h4essential_aph_4e_bundle.htm'
                    },
                    {
                        name: 'Zoom H5',
                        price: '€280-320',
                        features: ['4 tracce simultanee', 'Capsule intercambiabili incluse', 'Phantom power 48V', 'Registrazione fino a 96kHz/24bit'],
                        link: 'https://www.thomann.it/zoom_h5.htm'
                    }
                ],
                professional: [
                    {
                        name: 'Zoom F6',
                        price: '€550-650',
                        features: ['32-bit float 192kHz', 'Dual ADC per ogni canale', 'No gain staging necessario', 'Top qualità/prezzo pro'],
                        link: 'https://www.thomann.it/zoom_f6_case_set.htm',
                        review: 'Il Zoom F6 è il registratore che ha democratizzato il 32-bit float. Il dual ADC system garantisce registrazioni perfette anche in condizioni estreme (concerti, temporali). A questo prezzo, nessun competitor offre questa libertà. Consigliato a tutti i field recordist seri.'
                    },
                    {
                        name: 'Zoom F3',
                        price: '€280-320',
                        features: ['32-bit float 192kHz', 'Ultra-compatto 2 canali', 'Timecode sync', 'Preamp ultra-low noise'],
                        link: 'https://www.thomann.it/zoom_f3.htm',
                        review: 'Il Zoom F3 è una rivoluzione nel field recording compatto. Il 32-bit float elimina completamente il problema del clipping, permettendoti di concentrarti sulla composizione senza preoccuparti dei livelli. Perfetto per chi registra eventi imprevedibili (natura, città). Unico limite: solo 2 canali.'
                    },
                    {
                        name: 'Tascam Portacapture X8',
                        price: '€450-550',
                        features: ['32-bit float/192kHz', '4 capsule intercambiabili', 'Touchscreen intuitivo', 'Audio studio-quality'],
                        link: 'https://www.thomann.it/tascam_portacapture_x8.htm',
                        review: 'Il Portacapture X8 è la scelta perfetta per chi vuole flessibilità. Le 4 capsule intercambiabili (X/Y, A/B, shotgun, ecc.) ti permettono di adattarti a ogni situazione senza portare microfoni esterni. Il touchscreen rende l\'editing sul campo velocissimo. Unico limite: batterie proprietarie.'
                    },
                    {
                        name: 'Sound Devices MixPre-3 II',
                        price: '€650-750',
                        features: ['3 input Kashmir preamps', '32-bit float recording', 'Limitatore trasparente', 'Build quality professionale'],
                        link: 'https://www.thomann.it/sound_devices_mixpre_3_ii.htm',
                        review: 'I preamp Kashmir di Sound Devices sono considerati tra i migliori al mondo. Il MixPre-3 II offre qualità broadcast in un package compatto. Ideale per registrazioni critiche dove la qualità è tutto. Costoso ma vale ogni euro se lavori professionalmente.'
                    },
                    {
                        name: 'Sound Devices MixPre-6 II',
                        price: '€850-1000',
                        features: ['Kashmir preamps leggendari', '32-bit float recording', 'Timecode per sync video', 'Build quality broadcast'],
                        link: 'https://www.thomann.it/sound_devices_mixpre_6_ii.htm',
                        review: 'Sound Devices è sinonimo di broadcast quality. Il MixPre-6 II con i preamp Kashmir offre il suono più trasparente e musicale che puoi ottenere in un field recorder. Timecode, limitatori trasparenti, build indistruttibile. È l\'investimento definitivo se lavori su documentari o produzioni audio professionali.'
                    }
                ]
            },
            microphones: {
                consumer: [
                    {
                        name: 'Rode VideoMic NTG',
                        price: '€220-280',
                        features: ['Shotgun broadcast-quality', 'Batteria ricaricabile USB-C', 'Gain infinito digitale', 'Safety channel -20dB'],
                        link: 'https://www.thomann.it/rode_videomic_ntg.htm'
                    },
                    {
                        name: 'Sennheiser MKE 600',
                        price: '€280-350',
                        features: ['Short shotgun versatile', 'Phantom o batteria', 'Industria-standard', 'Low self-noise'],
                        link: 'https://www.thomann.it/sennheiser_mke_600.htm'
                    },
                    {
                        name: 'Rode NT5 Matched Pair',
                        price: '€350-420',
                        features: ['Small diaphragm condenser', 'Stereo pair matched', 'Cardioide precision', 'Eccellente per ambience'],
                        link: 'https://www.thomann.it/rode_nt5_stativ_bundle.htm'
                    }
                ],
                professional: [
                    {
                        name: 'Sennheiser MKH 416',
                        price: '€850-1100',
                        features: ['Industry-standard shotgun', 'RF condenser (anti-umidità)', 'Broadcast quality', 'Direzionalità top'],
                        link: 'https://www.thomann.it/sennheiser_mkh416p48u3.htm',
                        review: 'Il MKH 416 è il shotgun più usato nel cinema e broadcast mondiale. RF condenser (immune a umidità), direzionalità chirurgica, suono neutro e dettagliato. Dopo 40+ anni è ancora lo standard. Costoso, ma se registri voci o soundscape urbani, non ha rivali. Un acquisto per la vita.'
                    },
                    {
                        name: 'Rode NTG5',
                        price: '€450-550',
                        features: ['Super-leggero 76g', 'RF-bias technology', 'Suono trasparente', 'Best value pro shotgun'],
                        link: 'https://www.thomann.it/rode_ntg5_kit.htm',
                        review: 'Il Rode NTG5 è il miglior rapporto qualità/prezzo tra gli shotgun professionali. Pesa solo 76g (perfetto per aste lunghe), suono cristallino grazie alla RF-bias technology, e costa la metà di un MKH 416. Se il tuo budget non arriva a Sennheiser, il NTG5 è la scelta ovvia.'
                    },
                    {
                        name: 'Audio-Technica AT875R',
                        price: '€150-180',
                        features: ['Short shotgun budget', 'Line/mic switch', 'Batteria AAA', 'Ottimo rapporto qualità/prezzo'],
                        link: 'https://www.thomann.it/audio_technica_at_875_r.htm',
                        review: 'Il microfono "entry-level professional" per eccellenza. Non ha la raffinatezza di un MKH 416, ma a 1/5 del prezzo offre prestazioni sorprendenti. Perfetto per chi vuole iniziare con shotgun professionali senza spendere €1000. Consigliato come backup anche per i pro.'
                    },
                    {
                        name: 'DPA 4060',
                        price: '€700-800',
                        features: ['Omnidirezionale miniatura', 'Self-noise 23dB-A', 'Montaggio discreto', 'SPL 134dB'],
                        link: 'https://www.thomann.it/dpa_4060_oc_c_f03.htm',
                        review: 'I DPA 4060 sono i lavalier preferiti dai field recordist professionisti. Omnidirezionali con risposta in frequenza lineare, si "nascondono" ovunque (alberi, muri, abbigliamento) catturando l\'ambiente naturale senza colorazione. Costosi ma insostituibili per tecniche creative.'
                    },
                    {
                        name: 'Sennheiser MKH 8070',
                        price: '€1400-1700',
                        features: ['Long shotgun premium', 'Self-noise solo 8dB', 'Moisture-resistant', 'Rifiuto laterale 38dB'],
                        link: 'https://www.thomann.it/sennheiser_mkh_8070.htm',
                        review: 'Il MKH 8070 è un long shotgun da €1500+ per una ragione: isolamento laterale incredibile (38dB di reiezione) e rumore proprio di soli 8dB. Usato per wildlife recording a distanza e produzioni cinematografiche. Se devi catturare suoni specifici in ambienti rumorosi, è insuperabile. Ma è un tool specializzato, non versatile.'
                    }
                ]
            },
            windscreens: {
                consumer: [
                    {
                        name: 'Rode DeadCat VMPR',
                        price: '€30-40',
                        features: ['Furry windshield efficace', 'Fit VideoMic Pro/NTG', 'Riduzione vento 20dB', 'Qualità Rode'],
                        link: 'https://www.thomann.it/rode_deadcat_vmpr.htm'
                    },
                    {
                        name: 'Rycote Mini Windjammer',
                        price: '€40-50',
                        features: ['Per recorder portatili', 'Fit Zoom H1n/H4n/H5/H6', 'Pelo high-quality', 'Elastic mount sicuro'],
                        link: 'https://www.thomann.it/rycote_mini_wind_screen_for_zoom_h5.htm'
                    },
                    {
                        name: 'Rode DeadCat GO',
                        price: '€20-30',
                        features: ['Per VideoMic GO/ME', 'Budget-friendly', 'Protezione vento efficace', 'Compatto'],
                        link: 'https://www.thomann.it/rode_deadcat_go.htm'
                    }
                ],
                professional: [
                    {
                        name: 'Rycote Super-Softie',
                        price: '€90-120',
                        features: ['Windshield slip-on premium', 'Per shotgun fino 24cm', 'Riduzione vento fino 30dB', 'Mounting clips inclusi'],
                        link: 'https://www.thomann.it/rycote_super_softie_windshield_18cm.htm'
                    },
                    {
                        name: 'Rode Blimp MKII',
                        price: '€330-400',
                        features: ['Sistema completo windshield', 'Rycote Lyre shock mount', 'Fit shotgun fino 325mm', 'Dead Wombat incluso'],
                        link: 'https://www.thomann.it/rode_blimp_mkii.htm'
                    },
                    {
                        name: 'Rycote Nano-Shield Kit NS4-DB',
                        price: '€400-500',
                        features: ['Sistema professionale completo', 'Lyre suspension mount', 'Windjammer furry incluso', 'Standard broadcast'],
                        link: 'https://www.thomann.it/rycote_nano_shield_kit_ns4_db.htm'
                    }
                ]
            },
            stands: {
                consumer: [
                    {
                        name: 'K&M 210/2 Microphone Stand',
                        price: '€25-35',
                        features: ['Telescopica 900-1600mm', 'Base tripod stabile', 'Boom arm incluso', 'K&M qualità tedesca'],
                        link: 'https://www.thomann.it/km_210_2_mikrofonstativ.htm'
                    },
                    {
                        name: 'K&M 23325 Table Stand',
                        price: '€35-45',
                        features: ['Base ghisa pesante', 'Altezza 217-347mm', 'Perfetto per desk recording', 'Super stabile'],
                        link: 'https://www.thomann.it/km_23325_table_microphone_stand.htm'
                    },
                    {
                        name: 'K&M 23150 Table Stand',
                        price: '€15-25',
                        features: ['Mini stand da tavolo', 'Base compatta portatile', 'Altezza regolabile', 'Perfetto per field recording'],
                        link: 'https://www.thomann.it/km_23150.htm'
                    }
                ],
                professional: [
                    {
                        name: 'K&M 259 Low Tripod Boom',
                        price: '€110-150',
                        features: ['Low-profile per ground micing', 'Boom professionale', 'Altezza 530-995mm', 'Stabile e versatile'],
                        link: 'https://www.thomann.it/km_259_mic_stand.htm'
                    },
                    {
                        name: 'K&M 210/9 Studio Boom',
                        price: '€60-80',
                        features: ['Boom lungo professionale', 'Altezza 900-1605mm', 'Base pesante stabile', 'Industry workhorse'],
                        link: 'https://www.thomann.it/km_210_9_mikrofonstativ.htm'
                    },
                    {
                        name: 'K&M 25400 Speaker Stand',
                        price: '€80-110',
                        features: ['Professionale e compatto', 'Altezza 1.2-1.8m', 'Telescopico robusto', 'Carico max 50kg'],
                        link: 'https://www.thomann.it/km_25400.htm'
                    }
                ]
            },
            storage: [
                {
                    name: 'SanDisk Extreme PRO 128GB',
                    price: '€25-35',
                    features: ['Read 200MB/s Write 90MB/s', 'UHS-I U3 V30', 'Affidabilità comprovata', 'Ottima per 96kHz/24bit'],
                    link: 'https://www.amazon.it/dp/B07H48412Q'
                },
                {
                    name: 'Sony SF-G Tough 128GB',
                    price: '€50-70',
                    features: ['Read 300MB/s Write 299MB/s', 'UHS-II velocissima', 'Waterproof dustproof', 'Top per 32-bit float'],
                    link: 'https://www.amazon.it/dp/B07FDTVCVL'
                },
                {
                    name: 'Lexar Professional 256GB',
                    price: '€40-60',
                    features: ['Read 270MB/s Write 150MB/s', 'UHS-II V90', 'Capacità doppia', 'Rapporto qualità/prezzo'],
                    link: 'https://www.amazon.it/dp/B07MG44FDJ'
                },
                {
                    name: 'Samsung PRO Plus 512GB',
                    price: '€60-80',
                    features: ['Enorme capacità 512GB', 'Read 160MB/s Write 120MB/s', 'UHS-I U3', '10 anni garanzia'],
                    link: 'https://www.amazon.it/dp/B09B1HMJ9Z'
                }
            ],
            bags: [
                {
                    name: 'Thomann Recorder Bag Universal',
                    price: '€20-30',
                    features: ['Protezione imbottita', 'Fit Zoom/Tascam portatili', 'Tasche per accessori', 'Budget-friendly'],
                    link: 'https://www.thomann.it/thomann_recorder_bag_universal.htm'
                },
                {
                    name: 'Orca OR-28 Audio Bag',
                    price: '€130-170',
                    features: ['Per recorder compatti', 'Fit MixPre-3/Zoom F3', 'Padding interno regolabile', 'Harness confortevole'],
                    link: 'https://www.thomann.it/orca_or_28.htm'
                },
                {
                    name: 'Zoom PCF-6 Protective Bag',
                    price: '€90-120',
                    features: ['Specifico per Zoom F6', 'Due compartimenti separati', 'Sistema cinghie versatile', 'Ottima protezione'],
                    link: 'https://www.thomann.it/zoom_pcf_6.htm'
                },
                {
                    name: 'Thomann Case Recorder Large',
                    price: '€40-60',
                    features: ['Hard case protettivo', 'Foam customizzabile', 'Waterproof crushproof', 'Ottimo value'],
                    link: 'https://www.thomann.it/thomann_case_recorder_large.htm'
                }
            ],
            smartphones: [
                {
                    name: 'iPhone 15 Pro / Pro Max',
                    price: '€1200-1500',
                    features: ['4 microfoni studio-quality', 'Spatial Audio recording', 'ProRes video audio 48kHz', 'Apps: FiRe, Ferrite, AudioShare']
                },
                {
                    name: 'iPhone 14 Pro',
                    price: '€900-1200',
                    features: ['Ottimo audio array', 'Dolby Atmos recording', 'Riduzione rumore AI', 'Best value iPhone pro']
                },
                {
                    name: 'Samsung Galaxy S24 Ultra',
                    price: '€1200-1400',
                    features: ['3 microfoni AKG-tuned', 'Audio 360° recording', 'Pro video mode con gain', 'Android flagship']
                }
            ],
            software: [
                {
                    name: 'Reaper',
                    price: '€60 (licenza personale)',
                    features: ['DAW completo leggero', 'Editing multitrack illimitato', 'VST/AU support', 'Cross-platform'],
                    link: 'https://www.reaper.fm/purchase.php'
                },
                {
                    name: 'iZotope RX 10 Standard',
                    price: '€350-450',
                    features: ['Noise reduction AI-powered', 'Spectral repair tools', 'Standard audio restoration', 'Standalone o plugin'],
                    link: 'https://www.pluginboutique.com/product/2-Effects/39-FX-Bundle/9222-RX-10-Standard'
                },
                {
                    name: 'Audacity',
                    price: 'Gratis (open source)',
                    features: ['Editor multitrack gratis', 'Analisi spettrale', 'Effetti base inclusi', 'Community enorme'],
                    link: 'https://www.audacityteam.org/download/'
                },
                {
                    name: 'Wavelab Pro 12',
                    price: '€500-600',
                    features: ['Mastering professionale', 'Analisi avanzata', 'Batch processing', 'Metering broadcast'],
                    link: 'https://www.pluginboutique.com/product/2-Effects/41-Mastering/9856-WaveLab-Pro-12'
                },
                {
                    name: 'Max/MSP',
                    price: '€400 (€8/mese studenti)',
                    features: ['Visual programming audio', 'Strumenti custom', 'Real-time processing', 'Community patches'],
                    link: 'https://cycling74.com/products/max'
                }
            ]
        };

        // Reference content};

        // Reference content
        var referenceContent = {
            'polar-patterns': {
                title: '🎙️ Polar Patterns - Diagrammi Polari',
                content: `
                    <h3 style="color: #2d5f4f;">Cosa sono i Polar Patterns?</h3>
                    <p>I <strong>diagrammi polari</strong> mostrano da quale direzione un microfono capta il suono. Ogni pattern è ottimizzato per situazioni diverse nel field recording.</p>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">
                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                            <h4 style="color: #2d5f4f;">🔴 Omnidirezionale</h4>
                            <div style="width: 80px; height: 80px; border: 3px solid #2d5f4f; border-radius: 50%; margin: 10px auto;"></div>
                            <p><strong>Capta:</strong> 360° tutt'attorno</p>
                            <p><strong>Usa per:</strong> Ambience naturale, spazi architettonici, catturare tutto l'ambiente</p>
                            <p><strong>Evita:</strong> Ambienti rumorosi, quando serve isolamento</p>
                        </div>

                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                            <h4 style="color: #2d5f4f;">❤️ Cardioide</h4>
                            <div style="width: 80px; height: 80px; border: 3px solid #2d5f4f; border-radius: 50% 50% 50% 0; margin: 10px auto; transform: rotate(-135deg);"></div>
                            <p><strong>Capta:</strong> Fronte (90°), rifiuta retro</p>
                            <p><strong>Usa per:</strong> Interviste, voice-over, isolamento sorgente specifica</p>
                            <p><strong>Evita:</strong> Quando serve catturare tutto l'ambiente</p>
                        </div>

                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                            <h4 style="color: #2d5f4f;">🎯 Shotgun (Lobar)</h4>
                            <div style="width: 100px; height: 60px; border: 3px solid #2d5f4f; border-radius: 0 30px 30px 0; margin: 10px auto;"></div>
                            <p><strong>Capta:</strong> Iper-direzionale (30-40°)</p>
                            <p><strong>Usa per:</strong> Soggetti distanti, wildlife, rifiuto massimo laterale</p>
                            <p><strong>Evita:</strong> Spazi chiusi (riflessi), wide ambience</p>
                        </div>

                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                            <h4 style="color: #2d5f4f;">∞ Figure-8 (Bidirezionale)</h4>
                            <div style="width: 40px; height: 80px; border: 3px solid #2d5f4f; border-radius: 50%; margin: 10px auto;"></div>
                            <div style="width: 40px; height: 80px; border: 3px solid #2d5f4f; border-radius: 50%; margin: -90px auto 10px; transform: rotate(0deg);"></div>
                            <p><strong>Capta:</strong> Fronte e retro, rifiuta lati</p>
                            <p><strong>Usa per:</strong> Interviste faccia-a-faccia, MS stereo (Mid side), dialoghi</p>
                            <p><strong>Evita:</strong> Ambienti con rumori laterali</p>
                        </div>
                    </div>

                    <div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin: 20px 0;">
                        <h4 style="color: #2d5f4f;">💡 Tips Pratici</h4>
                        <ul>
                            <li><strong>Omnidirezionale:</strong> Perfetto per catturare "room tone" e ambience completa di uno spazio</li>
                            <li><strong>Cardioide:</strong> Il tuttofare - 80% dei field recording usa questo pattern</li>
                            <li><strong>Shotgun:</strong> Indispensabile per wildlife e situazioni dove non puoi avvicinarti</li>
                            <li><strong>Stereo X/Y:</strong> Due cardioidi a 90° = immagine stereo naturale</li>
                            <li><strong>MS (Mid-Side):</strong> Cardioide + Figure-8 = stereo width regolabile in post!</li>
                        </ul>
                    </div>
                `
            },
            'frequency-chart': {
                title: '📊 Frequency Chart - Guida Frequenze Audio',
                content: `
                    <h3 style="color: #2d5f4f;">Spettro Audio 20Hz - 20kHz</h3>
                    <p>Comprendere le frequenze ti aiuta a <strong>identificare suoni</strong>, <strong>scegliere microfoni</strong> e <strong>applicare EQ corretto</strong>.</p>

                    <div class="frequency-bar">
                        <div class="frequency-section" style="background: #1a237e; flex: 1;">
                            <div>SUB BASS<br>20-60 Hz<br><small>Feel fisico</small></div>
                        </div>
                        <div class="frequency-section" style="background: #283593; flex: 1.5;">
                            <div>BASS<br>60-250 Hz<br><small>Fondamentale basso</small></div>
                        </div>
                        <div class="frequency-section" style="background: #303f9f; flex: 2;">
                            <div>LOW MIDS<br>250-500 Hz<br><small>Warmth, body</small></div>
                        </div>
                        <div class="frequency-section" style="background: #3949ab; flex: 2;">
                            <div>MIDS<br>500Hz-2kHz<br><small>Voce, presenza</small></div>
                        </div>
                        <div class="frequency-section" style="background: #1e88e5; flex: 2;">
                            <div>HIGH MIDS<br>2-4 kHz<br><small>Definizione, clarity</small></div>
                        </div>
                        <div class="frequency-section" style="background: #42a5f5; flex: 1.5;">
                            <div>PRESENCE<br>4-6 kHz<br><small>Intelligibilità</small></div>
                        </div>
                        <div class="frequency-section" style="background: #64b5f6; flex: 2;">
                            <div>TREBLE<br>6-12 kHz<br><small>Brillantezza</small></div>
                        </div>
                        <div class="frequency-section" style="background: #90caf9; flex: 1;">
                            <div>AIR<br>12-20 kHz<br><small>Spazio, aria</small></div>
                        </div>
                    </div>

                    <h4 style="color: #2d5f4f; margin-top: 30px;">Esempi Soundscape per Frequenza</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; border-left: 4px solid #1a237e;">
                            <strong>20-60 Hz (Sub Bass)</strong><br>
                            Tuono distante, traffic pesante, vento forte, terremoto, onde oceaniche grosse
                        </div>
                        <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; border-left: 4px solid #283593;">
                            <strong>60-250 Hz (Bass)</strong><br>
                            Motori, rumble urbano, voce maschile bassa, grancassa, contrabbasso
                        </div>
                        <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; border-left: 4px solid #303f9f;">
                            <strong>250-500 Hz (Low Mids)</strong><br>
                            Voce umana fondamentale, chitarra acustica body, traffic medio, passi su legno
                        </div>
                        <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; border-left: 4px solid #3949ab;">
                            <strong>500Hz-2kHz (Mids)</strong><br>
                            Parlato (intelligibilità), piano, la maggior parte strumenti, porte che sbattono
                        </div>
                        <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; border-left: 4px solid #1e88e5;">
                            <strong>2-4 kHz (High Mids)</strong><br>
                            Dettaglio voce, clash piatti, sibilanti, campanelli, clacson auto
                        </div>
                        <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; border-left: 4px solid #42a5f5;">
                            <strong>4-6 kHz (Presence)</strong><br>
                            Uccellini, fruscii foglie, hi-hat, sibilanti forti, grilli
                        </div>
                        <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; border-left: 4px solid #64b5f6;">
                            <strong>6-12 kHz (Treble)</strong><br>
                            Cinguettii acuti, cicale, wind chimes, shimmer piatti, fruscio vento
                        </div>
                        <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; border-left: 4px solid #90caf9;">
                            <strong>12-20 kHz (Air)</strong><br>
                            Spazialità, riverbero naturale, armonici estremi, "aria" della registrazione
                        </div>
                    </div>

                    <div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin: 20px 0;">
                        <h4 style="color: #2d5f4f;">💡 Come Usare Questa Guida</h4>
                        <ul>
                            <li><strong>Scelta Microfono:</strong> Se registri uccellini (4-12kHz), serve un mic con risposta extended high freq</li>
                            <li><strong>EQ in Post:</strong> Rumble traffic (60-250Hz)? High-pass filter a 80-100Hz</li>
                            <li><strong>Identificazione:</strong> Analizza con spettrogramma per "vedere" dove vive il suono</li>
                            <li><strong>Mixing:</strong> Ogni elemento soundscape occupa uno spazio - evita sovrapposizioni</li>
                        </ul>
                    </div>
                `
            },
            'eq-settings': {
                title: '🎚️ EQ Settings - Equalizzazione per Ambienti',
                content: `
                    <h3 style="color: #2d5f4f;">EQ Strategies per Field Recording</h3>
                    <p>L'equalizzazione ti permette di <strong>pulire rumori indesiderati</strong> e <strong>enfatizzare elementi chiave</strong> del tuo soundscape.</p>

                    <h4 style="color: #2d5f4f; margin-top: 25px;">Preset EQ per Ambiente</h4>

                    <div class="eq-diagram">
                        <h4 style="color: #2d5f4f; margin: 0 0 10px 0;">🌳 Natura / Foresta</h4>
                        <p><strong>Obiettivo:</strong> Preservare dettaglio naturale, rimuovere wind rumble</p>
                        <ul>
                            <li><strong>High-Pass Filter @ 80Hz (-12dB/oct):</strong> Rimuove vento basso e rumble</li>
                            <li><strong>+2dB @ 5-8kHz (shelf):</strong> Esalta uccellini e fruscio foglie</li>
                            <li><strong>-1dB @ 200-400Hz (wide Q):</strong> Riduce mud se presente</li>
                            <li><strong>Tip:</strong> Mantieni dynamic range naturale - non comprimere troppo!</li>
                        </ul>
                    </div>

                    <div class="eq-diagram">
                        <h4 style="color: #2d5f4f; margin: 0 0 10px 0;">🏙️ Urbano / Città</h4>
                        <p><strong>Obiettivo:</strong> Bilanciare traffic rumble con dettagli umani</p>
                        <ul>
                            <li><strong>High-Pass Filter @ 60-100Hz:</strong> Controlla sub bass motori (attenzione a non tagliare troppo!)</li>
                            <li><strong>-3dB @ 150-250Hz (narrow Q):</strong> Taglia resonance traffic fastidiosa</li>
                            <li><strong>+1-2dB @ 2-4kHz:</strong> Porta avanti voci e dettagli umani</li>
                            <li><strong>Tip:</strong> Il rumble urbano è parte del paesaggio - non eliminarlo completamente!</li>
                        </ul>
                    </div>

                    <div class="eq-diagram">
                        <h4 style="color: #2d5f4f; margin: 0 0 10px 0;">🌊 Acqua / Oceano</h4>
                        <p><strong>Obiettivo:</strong> Catturare movimento acqua senza harshness</p>
                        <ul>
                            <li><strong>High-Pass Filter @ 40Hz:</strong> Mantieni sub bass onde grosse</li>
                            <li><strong>+1-2dB @ 8-12kHz (shelf):</strong> Esalta dettaglio spray e schiuma</li>
                            <li><strong>-2dB @ 3-4kHz (se harsh):</strong> Ammorbidisce splash aggressivi</li>
                            <li><strong>Tip:</strong> Onde hanno molto low-end - registra con headroom!</li>
                        </ul>
                    </div>

                    <div class="eq-diagram">
                        <h4 style="color: #2d5f4f; margin: 0 0 10px 0;">🏛️ Interni / Architettura</h4>
                        <p><strong>Obiettivo:</strong> Controllare riverbero, preservare spazialità</p>
                        <ul>
                            <li><strong>High-Pass Filter @ 100Hz:</strong> Rimuove room rumble e HVAC</li>
                            <li><strong>-2-3dB @ 200-500Hz (wide Q):</strong> Riduce boominess dello spazio</li>
                            <li><strong>+1dB @ 10-15kHz:</strong> Recupera air e dimensione</li>
                            <li><strong>Tip:</strong> Usa de-reverb (iZotope RX) se troppo riflessivo</li>
                        </ul>
                    </div>

                    <div class="eq-diagram">
                        <h4 style="color: #2d5f4f; margin: 0 0 10px 0;">🎤 Voce / Intervista</h4>
                        <p><strong>Obiettivo:</strong> Massima intelligibilità e naturalezza</p>
                        <ul>
                            <li><strong>High-Pass Filter @ 80-120Hz:</strong> Elimina proximity effect e plosive</li>
                            <li><strong>+2-3dB @ 3-5kHz (presence peak):</strong> Aumenta chiarezza e intelligibilità</li>
                            <li><strong>-2dB @ 200-300Hz (se voce maschile):</strong> Riduce muddiness</li>
                            <li><strong>De-esser @ 6-8kHz:</strong> Controlla sibilanti (non EQ - dynamics!)</li>
                        </ul>
                    </div>

                    <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #ff9800;">
                        <h4 style="color: #e65100;">⚠️ Regole d'Oro EQ</h4>
                        <ol>
                            <li><strong>Sottrai prima di aggiungere:</strong> Cut elimina problemi, boost introduce artefatti</li>
                            <li><strong>High-pass sempre:</strong> Frequenze sotto 40Hz sono quasi sempre inutili e mangiano headroom</li>
                            <li><strong>Wide Q per musicali, Narrow Q per problemi:</strong> Broad boost suona naturale, narrow cut risolve risonanze</li>
                            <li><strong>A/B costantemente:</strong> Le orecchie si abituano - compara sempre con originale</li>
                            <li><strong>Less is more:</strong> Se hai bisogno di +10dB, probabilmente hai il mic sbagliato o posizionato male</li>
                            <li><strong>Context matters:</strong> EQ per headphones ≠ EQ per speakers ≠ EQ per installazione</li>
                        </ol>
                    </div>

                    <div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin: 20px 0;">
                        <h4 style="color: #2d5f4f;">💡 Tools Consigliati</h4>
                        <ul>
                            <li><strong>FabFilter Pro-Q 3:</strong> EQ chirurgico con analyzer spettrale in tempo reale</li>
                            <li><strong>Voxengo SPAN:</strong> Spectral analyzer gratuito per identificare problemi</li>
                            <li><strong>iZotope Ozone EQ:</strong> AI-assisted EQ matching (copia il tone di riferimento)</li>
                            <li><strong>Waves Renaissance EQ:</strong> Musicale e vintage-sounding per materiale organico</li>
                        </ul>
                    </div>
                `
            },
            'sample-rate': {
                title: '💿 Sample Rate & Bit Depth - Guida Formati Audio',
                content: `
                    <h3 style="color: #2d5f4f;">Sample Rate e Bit Depth Spiegati</h3>
                    <p>Scegliere il formato giusto significa bilanciare <strong>qualità audio</strong>, <strong>dimensione file</strong> e <strong>compatibilità</strong>.</p>

                    <h4 style="color: #2d5f4f; margin-top: 25px;">📊 Sample Rate (Frequenza di Campionamento)</h4>
                    <p>Quanti "snapshot" del segnale audio vengono catturati al secondo. Più alto = più dettaglio frequenze alte.</p>

                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                        <tr style="background: #2d5f4f; color: white;">
                            <th style="padding: 10px; text-align: left;">Sample Rate</th>
                            <th style="padding: 10px; text-align: left;">Freq Max</th>
                            <th style="padding: 10px; text-align: left;">Usa Per</th>
                            <th style="padding: 10px; text-align: left;">Note</th>
                        </tr>
                        <tr style="background: #f5f5f5;">
                            <td style="padding: 10px;"><strong>44.1 kHz</strong></td>
                            <td style="padding: 10px;">22.05 kHz</td>
                            <td style="padding: 10px;">CD, streaming, podcasts</td>
                            <td style="padding: 10px;">Standard consumer. Più che sufficiente per 99% ascolto umano (20Hz-20kHz)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px;"><strong>48 kHz</strong></td>
                            <td style="padding: 10px;">24 kHz</td>
                            <td style="padding: 10px;">Video, TV, film, game audio</td>
                            <td style="padding: 10px;">Standard industria video. Sync perfetto con frame rate</td>
                        </tr>
                        <tr style="background: #f5f5f5;">
                            <td style="padding: 10px;"><strong>96 kHz</strong></td>
                            <td style="padding: 10px;">48 kHz</td>
                            <td style="padding: 10px;">Field recording pro, sound design</td>
                            <td style="padding: 10px;">Ottimo per pitch-shifting/time-stretching. Cattura ultrasonici (utile per rallentare)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px;"><strong>192 kHz</strong></td>
                            <td style="padding: 10px;">96 kHz</td>
                            <td style="padding: 10px;">Extreme sound design, archival</td>
                            <td style="padding: 10px;">File enormi. Solo per manipolazioni estreme o archive masterizzazione</td>
                        </tr>
                    </table>

                    <h4 style="color: #2d5f4f; margin-top: 25px;">🎚️ Bit Depth (Profondità di Bit)</h4>
                    <p>Quanti "livelli" di volume possono essere rappresentati. Più alto = più dynamic range e meno noise floor.</p>

                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                        <tr style="background: #2d5f4f; color: white;">
                            <th style="padding: 10px; text-align: left;">Bit Depth</th>
                            <th style="padding: 10px; text-align: left;">Dynamic Range</th>
                            <th style="padding: 10px; text-align: left;">Usa Per</th>
                            <th style="padding: 10px; text-align: left;">Note</th>
                        </tr>
                        <tr style="background: #f5f5f5;">
                            <td style="padding: 10px;"><strong>16-bit</strong></td>
                            <td style="padding: 10px;">~96 dB</td>
                            <td style="padding: 10px;">CD, delivery finale</td>
                            <td style="padding: 10px;">Mai registrare in 16-bit! Solo per export finale</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px;"><strong>24-bit</strong></td>
                            <td style="padding: 10px;">~144 dB</td>
                            <td style="padding: 10px;">Field recording, studio tracking</td>
                            <td style="padding: 10px;">Standard professionale. Headroom enorme = meno rischio clipping</td>
                        </tr>
                        <tr style="background: #f5f5f5;">
                            <td style="padding: 10px;"><strong>32-bit float</strong></td>
                            <td style="padding: 10px;">~1500 dB (!)</td>
                            <td style="padding: 10px;">Field recording unpredictable</td>
                            <td style="padding: 10px;">🚀 Impossibile clippare! Puoi recuperare tutto in post. Game changer!</td>
                        </tr>
                    </table>

                    <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #2196f3;">
                        <h4 style="color: #1565c0;">🚀 32-bit Float - Perché è Rivoluzionario</h4>
                        <p>I recorder moderni (Sound Devices MixPre, Zoom F6) registrano in <strong>32-bit float</strong>:</p>
                        <ul>
                            <li>✅ <strong>No gain staging:</strong> Non serve impostare livelli prima - puoi farlo tutto in post!</li>
                            <li>✅ <strong>No clipping:</strong> Anche se registri "in the red", l'audio oltre 0dB è recuperabile</li>
                            <li>✅ <strong>Situazioni unpredictable:</strong> Thunderstorm, proteste, wildlife - catturi tutto dal sussurro all'esplosione</li>
                            <li>✅ <strong>Dual ADC:</strong> Registra 2 conversioni simultane (una hot, una safe) - scegli dopo quale usare</li>
                        </ul>
                        <p><strong>Svantaggio:</strong> File 2x più grandi del 24-bit (ma storage è cheap, audio rovinato no!)</p>
                    </div>

                    <h4 style="color: #2d5f4f; margin-top: 25px;">🎯 Raccomandazioni per Soundscape</h4>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; margin: 20px 0;">
                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; border-left: 4px solid #4caf50;">
                            <h4 style="color: #2d5f4f;">✅ Setup Consigliato</h4>
                            <p><strong>Registrazione:</strong></p>
                            <ul>
                                <li>96kHz / 24-bit (o 32-bit float se disponibile)</li>
                                <li>WAV uncompressed</li>
                                <li>Mono o stereo (no MP3 mai!)</li>
                            </ul>
                            <p><strong>Delivery Finale:</strong></p>
                            <ul>
                                <li>48kHz / 24-bit per installazioni</li>
                                <li>44.1kHz / 16-bit per streaming</li>
                            </ul>
                        </div>

                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; border-left: 4px solid #ff9800;">
                            <h4 style="color: #2d5f4f;">⚡ Best Practice</h4>
                            <ul>
                                <li><strong>96kHz se:</strong> Farai pitch/time manipulation, o vuoi catturare ultrasonici (bat calls, insetti)</li>
                                <li><strong>48kHz se:</strong> Per video sync o archiving standard</li>
                                <li><strong>32-bit float se:</strong> Situazioni imprevedibili (thunderstorms, crowds, wildlife)</li>
                                <li><strong>24-bit se:</strong> Setup controllato, gain staging attento</li>
                            </ul>
                        </div>
                    </div>

                    <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #ff9800;">
                        <h4 style="color: #e65100;">⚠️ Miti da Sfatare</h4>
                        <ul>
                            <li>❌ <strong>"192kHz suona meglio":</strong> No. L'orecchio umano arriva a ~20kHz. 192kHz serve solo per extreme processing</li>
                            <li>❌ <strong>"Più alto è meglio sempre":</strong> No. 192kHz = file 4x più grandi, più CPU, più problemi. Usa solo se necessario</li>
                            <li>❌ <strong>"MP3 320kbps è uguale a WAV":</strong> No! Mai registrare in lossy. Sempre WAV o FLAC</li>
                            <li>✅ <strong>"48kHz/24bit è il sweet spot pro":</strong> Sì! Qualità eccellente, file ragionevoli, compatibilità totale</li>
                        </ul>
                    </div>

                    <div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin: 20px 0;">
                        <h4 style="color: #2d5f4f;">💡 File Size Reference (1 minuto stereo)</h4>
                        <ul>
                            <li>44.1kHz / 16-bit: ~10 MB</li>
                            <li>48kHz / 24-bit: ~17 MB</li>
                            <li>96kHz / 24-bit: ~34 MB</li>
                            <li>96kHz / 32-bit float: ~46 MB</li>
                            <li>192kHz / 24-bit: ~69 MB (!)</li>
                        </ul>
                        <p><strong>Tip:</strong> Un field recording day (4 ore @ 96/24) = circa 8GB. Porta HD esterni!</p>
                    </div>
                `
            }
        };

        // Show Reference Modal
        window.showReferenceModal = function(type) {
            var modal = document.getElementById('referenceModal');
            var content = document.getElementById('referenceContent');
            var data = referenceContent[type];

            if (data) {
                content.innerHTML = `
                    <h2 style="color: #2d5f4f; margin-bottom: 20px;">${data.title}</h2>
                    ${data.content}
                `;
                modal.style.display = 'block';
                document.body.style.overflow = 'hidden';
            }
        };

        // Close Reference Modal
        window.closeReferenceModal = function() {
            var modal = document.getElementById('referenceModal');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        };

        // Show Equipment Tab
        window.showEquipmentTab = function(category) {
            // Update active button
            var buttons = document.querySelectorAll('[data-equipment]');
            buttons.forEach(function(btn) {
                btn.classList.remove('active');
            });
            document.querySelector('[data-equipment="' + category + '"]').classList.add('active');

            // Render content
            var contentDiv = document.getElementById('equipment-content');
            var html = '';

            if (category === 'recorders' || category === 'microphones' || category === 'windscreens' || category === 'stands') {
                var data = equipmentData[category];

                html += '<h4 style="color: #2d5f4f; margin: 20px 0 15px 0;">💚 Consumer / Enthusiast</h4>';
                html += '<div class="equipment-grid">';
                data.consumer.forEach(function(item) {
                    html += `
                        <div class="equipment-card">
                            <span class="category-badge">CONSUMER</span>
                            <h4>${item.name}</h4>
                            <div class="price">${item.price}</div>
                            <ul>
                                ${item.features.map(f => '<li>' + f + '</li>').join('')}
                            </ul>
                            ${item.link ? `<a href="${item.link}" target="_blank" rel="noopener" style="display: inline-block; margin-top: 10px; padding: 8px 16px; background: #2d5f4f; color: white; text-decoration: none; border-radius: 6px; font-weight: 600; font-size: 14px;">🛒 Acquista</a>` : ''}
                        </div>
                    `;
                });
                html += '</div>';

                html += '<h4 style="color: #2d5f4f; margin: 30px 0 15px 0;">🔥 Professional</h4>';
                html += '<div class="equipment-grid">';
                data.professional.forEach(function(item) {
                    html += `
                        <div class="equipment-card">
                            <span class="category-badge" style="background: #d32f2f;">PROFESSIONAL</span>
                            <h4>${item.name}</h4>
                            <div class="price">${item.price}</div>
                            ${item.review ? `<div style="background: #fff8f0; padding: 12px; border-left: 3px solid #d32f2f; margin: 10px 0; border-radius: 4px;"><p style="margin: 0; font-size: 13px; color: #555; line-height: 1.6; font-style: italic;">"${item.review}"</p></div>` : ''}
                            <ul>
                                ${item.features.map(f => '<li>' + f + '</li>').join('')}
                            </ul>
                            ${item.link ? `<a href="${item.link}" target="_blank" rel="noopener" style="display: inline-block; margin-top: 10px; padding: 8px 16px; background: #d32f2f; color: white; text-decoration: none; border-radius: 6px; font-weight: 600; font-size: 14px;">🛒 Acquista</a>` : ''}
                        </div>
                    `;
                });
                html += '</div>';

            } else if (category === 'smartphones' || category === 'software' || category === 'storage' || category === 'bags') {
                var data = equipmentData[category];
                html += '<div class="equipment-grid">';
                data.forEach(function(item) {
                    html += `
                        <div class="equipment-card">
                            <h4>${item.name}</h4>
                            <div class="price">${item.price}</div>
                            <ul>
                                ${item.features.map(f => '<li>' + f + '</li>').join('')}
                            </ul>
                            ${item.link ? `<a href="${item.link}" target="_blank" rel="noopener" style="display: inline-block; margin-top: 10px; padding: 8px 16px; background: #2d5f4f; color: white; text-decoration: none; border-radius: 6px; font-weight: 600; font-size: 14px;">${category === 'software' ? '💻 Visita' : '🛒 Acquista'}</a>` : ''}
                        </div>
                    `;
                });
                html += '</div>';
            }

            contentDiv.innerHTML = html;
        };

        // Initialize equipment tab - call this when toolkit section is shown
        var toolkitInitialized = false;

        window.initializeToolkit = function() {
            if (!toolkitInitialized && document.getElementById('equipment-content')) {
                showEquipmentTab('recorders');
                toolkitInitialized = true;
            }
        };

        // ==================== LIBRARY SECTION ====================

        var libraryData = {
            books: [
                {
                    title: 'The Soundscape: Our Sonic Environment and the Tuning of the World',
                    author: 'R. Murray Schafer',
                    category: 'FONDAMENTALE',
                    description: 'Il testo fondamentale che ha definito il campo dell\'acoustic ecology. Schafer introduce concetti chiave come soundmark, keynote sounds, e schizofonia. Lettura obbligatoria per chiunque lavori con soundscape.',
                    link: 'https://www.amazon.com/Soundscape-Our-Sonic-Environment-Tuning/dp/0892814551?tag=soundscapestu-21'
                },
                {
                    title: 'Sonic Experience: A Guide to Everyday Sounds',
                    author: 'Jean-François Augoyard & Henry Torgue',
                    category: 'FONDAMENTALE',
                    description: 'Un compendio di 82 "effetti sonori" che strutturano la nostra esperienza quotidiana del suono. Approccio fenomenologico indispensabile per sound designers e ricercatori.',
                    link: 'https://www.amazon.com/Sonic-Experience-Guide-Everyday-Sounds/dp/0773532447?tag=soundscapestu-21'
                },
                {
                    title: 'The Great Animal Orchestra: Finding the Origins of Music in the Wild',
                    author: 'Bernie Krause',
                    category: 'ECOLOGIA ACUSTICA',
                    description: 'Il pioniere della bioacustica esplora come gli animali hanno creato la "prima orchestra" del pianeta. Include spettrogrammi e analisi di soundscape naturali da tutto il mondo.',
                    link: 'https://www.amazon.com/Great-Animal-Orchestra-Finding-Origins/dp/031608686X?tag=soundscapestu-21'
                },
                {
                    title: 'Listening to Noise and Silence',
                    author: 'Salomé Voegelin',
                    category: 'FILOSOFIA',
                    description: 'Approccio fenomenologico all\'ascolto sonoro. Esplora come ascoltare attivamente trasforma la percezione dello spazio e del tempo.',
                    link: 'https://www.amazon.com/Listening-Noise-Silence-Towards-Philosophy/dp/1441162070?tag=soundscapestu-21'
                },
                {
                    title: 'Ocean of Sound: Aether Talk, Ambient Sound',
                    author: 'David Toop',
                    category: 'STORIA',
                    description: 'Storia culturale della musica ambient e soundscape dal 1889 ad oggi. Connette Debussy, Cage, Brian Eno, e l\'electronic music in una narrativa affascinante.',
                    link: 'https://www.amazon.com/Ocean-Sound-Aether-Talk-Ambient/dp/1852427434?tag=soundscapestu-21'
                },
                {
                    title: 'Handbook for Acoustic Ecology',
                    author: 'Barry Truax',
                    category: 'REFERENCE',
                    description: 'Dizionario definitivo dei termini di acoustic ecology. Disponibile gratuitamente online - risorsa indispensabile per comprendere la terminologia del campo.',
                    link: 'https://www.sfu.ca/sonic-studio-webdav/handbook/index.html'
                },
                {
                    title: 'In The Field: The Art of Field Recording',
                    author: 'Cathy Lane & Angus Carlyle',
                    category: 'PRATICA',
                    description: 'Raccolta di interviste con sound artists contemporanei che usano field recording. Copre aspetti tecnici, etici ed estetici della pratica.',
                    link: 'https://www.amazon.com/Field-Art-Recording/dp/0956855962?tag=soundscapestu-21'
                },
                {
                    title: 'Soundscape Ecology: Principles, Patterns, Methods and Applications',
                    author: 'Almo Farina',
                    category: 'SCIENZA',
                    description: 'Approccio scientifico alla soundscape ecology. Include metodologie quantitative per analizzare paesaggi sonori e biodiversità acustica.',
                    link: 'https://www.amazon.com/Soundscape-Ecology-Principles-Patterns-Applications/dp/9401794588?tag=soundscapestu-21'
                },
                {
                    title: 'Deep Listening: A Composer\'s Sound Practice',
                    author: 'Pauline Oliveros',
                    category: 'PRATICA',
                    description: 'Testo fondamentale sull\'ascolto profondo. Esercizi e filosofia per espandere la consapevolezza sonora attraverso la pratica dell\'ascolto attivo.',
                    link: 'https://www.amazon.com/Deep-Listening-Composers-Sound-Practice/dp/0595343643?tag=soundscapestu-21'
                }
            ],
            videos: [
                {
                    title: 'The Voice of Landscape - Bernie Krause TED Talk',
                    author: 'Bernie Krause',
                    category: 'TED TALK',
                    description: 'Il biologo acustico Bernie Krause presenta 45 anni di registrazioni naturali, mostrando come il soundscape naturale si sta drammaticamente deteriorando.',
                    link: 'https://www.youtube.com/watch?v=uTbp0c68FTY'
                },
                {
                    title: 'Giorgio Nottoli - Soundscape e Paesaggio Sonoro',
                    author: 'Giorgio Nottoli',
                    category: 'DOCUMENTARIO',
                    description: 'Documentario e lecture di Giorgio Nottoli sul concetto di soundscape e paesaggio sonoro. Approfondimento sulla ricerca italiana in acoustic ecology e sound studies.',
                    link: 'https://www.youtube.com/watch?v=MqxfMtw6DmM'
                },
                {
                    title: 'Hildegard Westerkamp - Soundwalking',
                    author: 'Hildegard Westerkamp',
                    category: 'ARTICOLO',
                    description: 'La compositrice canadese spiega la pratica del soundwalking e come ascoltare attentamente trasforma la percezione dell\'ambiente. Testo fondamentale dal suo sito ufficiale.',
                    link: 'https://www.hildegardwesterkamp.ca/writings/writingsby/?post_id=13&title=soundwalking'
                },
                {
                    title: 'Chris Watson - Weather Report (Documentary)',
                    author: 'Chris Watson',
                    category: 'DOCUMENTARIO',
                    description: 'Il maestro field recordist della BBC mostra il suo processo creativo registrando ambienti estremi in tutto il mondo.',
                    link: 'https://www.youtube.com/results?search_query=chris+watson+weather+report'
                },
                {
                    title: 'Francisco López - Blind Listening',
                    author: 'Francisco López',
                    category: 'PERFORMANCE',
                    description: 'Performance di ascolto bendato del sound artist spagnolo. Approccio radicale all\'ascolto acusmatico.',
                    link: 'https://www.youtube.com/results?search_query=francisco+lopez+blind+listening'
                },
                {
                    title: 'Sonic Acts - Field Recording Symposium',
                    author: 'Various Artists',
                    category: 'CONFERENZA',
                    description: 'Lectures e performances dal festival olandese Sonic Acts. Include presentazioni di Jana Winderen, Chris Watson, e altri. Video disponibili su YouTube.',
                    link: 'https://sonicacts.com/'
                },
                {
                    title: 'Gordon Hempton - One Square Inch of Silence',
                    author: 'Gordon Hempton',
                    category: 'DOCUMENTARIO',
                    description: 'L\'acoustic ecologist Gordon Hempton presenta la sua missione di preservare luoghi naturali silenziosi negli USA.',
                    link: 'https://www.youtube.com/results?search_query=gordon+hempton+one+square+inch'
                }
            ],
            audio: [
                {
                    title: 'World Soundscape Project Archive',
                    author: 'Simon Fraser University',
                    category: 'ARCHIVIO',
                    description: 'Archivio storico del progetto fondato da Schafer negli anni \'70. Include registrazioni di Vancouver, Europa, e progetti "Five Village Soundscapes".',
                    link: 'https://www.sfu.ca/~truax/wsp.html'
                },
                {
                    title: 'Freesound',
                    author: 'Community-driven',
                    category: 'DATABASE',
                    description: 'Database collaborativo con oltre 500.000 suoni gratuiti sotto licenze Creative Commons. Ottimo per trovare esempi e materiale per composizioni.',
                    link: 'https://freesound.org/'
                },
                {
                    title: 'Cities and Memory',
                    author: 'Stuart Fowkes',
                    category: 'PROGETTO GLOBALE',
                    description: 'Mappa sonora globale con registrazioni field e rielaborazioni artistiche. Oltre 5000 suoni da 100+ paesi.',
                    link: 'https://citiesandmemory.com/'
                },
                {
                    title: 'Touch Radio',
                    author: 'Touch Records',
                    category: 'PODCAST',
                    description: 'Podcast mensile di field recordings e sound art dalla leggendaria label Touch. Artisti: Chris Watson, BJ Nilsen, Philip Jeck.',
                    link: 'https://www.touchradio.org.uk/'
                },
                {
                    title: 'Locus Sonus Soundmap',
                    author: 'Locus Sonus Research Lab',
                    category: 'LIVE STREAMING',
                    description: 'Mappa mondiale di microfoni live streaming. Ascolta suoni in tempo reale da tutto il mondo.',
                    link: 'https://locusonus.org/soundmap/'
                },
                {
                    title: 'Aporee Maps',
                    author: 'Aporee Community',
                    category: 'MAPPA SONORA',
                    description: 'Piattaforma collaborativa per condividere field recordings geo-localizzati. Oltre 20.000 registrazioni.',
                    link: 'https://aporee.org/maps/'
                },
                {
                    title: 'BBC Sound Effects Library',
                    author: 'BBC',
                    category: 'ARCHIVIO',
                    description: 'Oltre 16.000 effetti sonori BBC disponibili per download personale, educativo e di ricerca. Qualità broadcast.',
                    link: 'https://sound-effects.bbcrewind.co.uk/'
                },
                {
                    title: 'Sounding Nature - Cornell Lab',
                    author: 'Cornell Lab of Ornithology',
                    category: 'NATURA',
                    description: 'Archivio Macaulay Library: 1+ milione di registrazioni di uccelli, mammiferi, insetti. Risorsa scientifica fondamentale.',
                    link: 'https://www.macaulaylibrary.org/'
                }
            ],
            papers: [
                {
                    title: 'The Soundscape of Modernity',
                    author: 'Emily Thompson',
                    category: 'LIBRO',
                    description: 'Libro accademico fondamentale sulla trasformazione del paesaggio sonoro americano 1900-1933. Analisi storica dell\'industrializzazione acustica e nascita della modernità sonora.',
                    link: 'https://mitpress.mit.edu/9780262701068/the-soundscape-of-modernity/'
                },
                {
                    title: 'Acoustic Ecology and the World Soundscape Project',
                    author: 'Barry Truax',
                    category: 'ARTICOLO',
                    description: 'Overview storico del World Soundscape Project e dello sviluppo dell\'acoustic ecology come disciplina. Documenti e metodologie del progetto originale.',
                    link: 'https://www.sfu.ca/~truax/wsp.html'
                },
                {
                    title: 'Soundscape Indices for Environmental Monitoring',
                    author: 'Pijanowski et al.',
                    category: 'PAPER SCIENTIFICO',
                    description: 'Metodologie quantitative per misurare biodiversità attraverso soundscape. Include Acoustic Complexity Index (ACI), Acoustic Diversity Index, e altri indici ecologici.',
                    link: 'https://www.sciencedirect.com/science/article/pii/S1470160X11000562'
                },
                {
                    title: 'Acoustic Ecology - Barry Truax Website',
                    author: 'Barry Truax',
                    category: 'RISORSA WEB',
                    description: 'Sito personale di Barry Truax con articoli, composizioni, e documentazione completa sull\'acoustic ecology e il World Soundscape Project.',
                    link: 'https://www.sfu.ca/~truax/'
                },
                {
                    title: 'Hildegard Westerkamp - Compositions & Writings',
                    author: 'Hildegard Westerkamp',
                    category: 'ARCHIVIO ARTISTA',
                    description: 'Sito ufficiale con composizioni soundscape, articoli teorici, e metodologie di soundwalking. Include "Kits Beach Soundscape" e altri lavori fondamentali.',
                    link: 'https://www.hildegardwesterkamp.ca/'
                }
            ],
            resources: [
                {
                    title: 'Simon Fraser University - Acoustic Ecology',
                    author: 'SFU / Barry Truax',
                    category: 'UNIVERSITÀ',
                    description: 'Centro di ricerca originale fondato da Schafer. Accesso a Handbook for Acoustic Ecology, archivi WSP, e software.',
                    link: 'https://www.sfu.ca/~truax/'
                },
                {
                    title: 'gruenrekorder - Label & Publisher',
                    author: 'gruenrekorder',
                    category: 'LABEL',
                    description: 'Label tedesca specializzata in field recording e soundscape composition. Catalogo con oltre 200 release.',
                    link: 'https://gruenrekorder.de/'
                },
                {
                    title: 'Sound Studies Lab',
                    author: 'Humboldt University Berlin',
                    category: 'RICERCA',
                    description: 'Laboratorio di ricerca interdisciplinare su sound studies, acoustic ecology, e sonic knowledge.',
                    link: 'https://www.soundstudieslab.org/'
                },
                {
                    title: 'Sounding Out! - Blog',
                    author: 'Various Contributors',
                    category: 'BLOG',
                    description: 'Blog accademico su sound studies, cultura sonora, e tecnologie audio. Articoli settimanali.',
                    link: 'https://soundstudiesblog.com/'
                },
                {
                    title: 'Sonic Acts',
                    author: 'Festival / Organization',
                    category: 'FESTIVAL',
                    description: 'Festival olandese di art sonora e cultura digitale. Include conferenze, performances, e pubblicazioni.',
                    link: 'https://sonicacts.com/'
                },
                {
                    title: 'CRiSAP - Creative Research into Sound Arts Practice',
                    author: 'University of Arts London',
                    category: 'UNIVERSITÀ',
                    description: 'Centro di ricerca britannico su sound art e acoustic ecology. Master programs, pubblicazioni e symposium. Ha celebrato 20 anni nel 2024.',
                    link: 'https://www.arts.ac.uk/research/research-centres/creative-research-in-sound-arts-practice-crisap'
                },
                {
                    title: 'Phonography Monthly',
                    author: 'Podcast',
                    category: 'PODCAST',
                    description: 'Podcast mensile con un singolo field recording non editato per ogni episodio. Ascolto contemplativo.',
                    link: 'https://phonography.org/'
                },
                {
                    title: 'Wild Sanctuary - Bernie Krause',
                    author: 'Bernie Krause',
                    category: 'ARCHIVIO',
                    description: 'Archivio personale di Bernie Krause con 5000+ ore di registrazioni naturali da 50 anni di carriera.',
                    link: 'https://www.wildsanctuary.com/'
                }
            ]
        };

        // Show Library Tab
        window.showLibraryTab = function(category) {
            // Update active button
            var buttons = document.querySelectorAll('[data-library]');
            buttons.forEach(function(btn) {
                btn.classList.remove('active');
            });
            document.querySelector('[data-library="' + category + '"]').classList.add('active');

            // Render content
            var contentDiv = document.getElementById('library-content');
            var data = libraryData[category];
            var html = '';

            data.forEach(function(item) {
                html += `
                    <div class="library-item">
                        <span class="library-category">${item.category}</span>
                        <h4>${item.title}</h4>
                        <div class="author">di ${item.author}</div>
                        <div class="description">${item.description}</div>
                        <a href="${item.link}" target="_blank" class="link-btn">
                            🔗 Apri Risorsa →
                        </a>
                    </div>
                `;
            });

            contentDiv.innerHTML = html;
        };

        // Initialize library
        var libraryInitialized = false;

        // Re-implement initializeLibrary with full functionality
        window.initializeLibrary = function() {
            if (!libraryInitialized && document.getElementById('library-content')) {
                showLibraryTab('books');
                libraryInitialized = true;
            }
        };

        // ==================== FREEMIUM SYSTEM ====================

        // Premium Status Management
        // PWA VERSION: Always Premium (all features free)
        let isPremium = true;

        // FREE VERSION LIMITS
        const FREE_LIMITS = {
            markers: 20  // Max 20 markers on map for free version
        };

        // Get current usage stats
        function getCurrentUsage() {
            return {
                markers: soundscapeData ? soundscapeData.length : 0
            };
        }

        // Update UI based on premium status
        function updatePremiumUI() {
            const banner = document.getElementById('premium-banner');
            if (banner) {
                if (!isPremium) {
                    banner.style.display = 'flex';
                } else {
                    banner.style.display = 'none';
                }
            }
        }

        // Show Upgrade Modal
        function showUpgradeModal() {
            const modal = document.getElementById('paywall-modal');
            if (modal) {
                modal.classList.add('active');
                document.body.classList.add('modal-open');
            }
        }

        // Close Upgrade Modal
        function closeUpgradeModal() {
            const modal = document.getElementById('paywall-modal');
            if (modal) {
                modal.classList.remove('active');
                document.body.classList.remove('modal-open');
            }
        }

        // Premium upgrade is handled by RevenueCat (see iap-integration.js)
        // Functions: purchasePremium() and restorePurchases() are available globally

        // ==================== PREMIUM FEATURES ====================

        // Export Exercise to PDF (PREMIUM ONLY)
        async function exportExerciseToPDF(exerciseId) {
            // Check if premium
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nL\'esportazione PDF è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per sbloccare questa funzionalità!');
                showUpgradeModal();
                return;
            }

            try {
                const ex = await getExerciseFromIndexedDB(exerciseId);
                if (!ex) {
                    alert('❌ Esercizio non trovato!');
                    return;
                }

                // Create PDF using jsPDF
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                // Title
                doc.setFontSize(20);
                doc.setTextColor(45, 95, 79);
                doc.text(ex.exercise.title, 20, 20);

                // Category badge
                doc.setFontSize(10);
                doc.setFillColor(45, 95, 79);
                doc.setTextColor(255, 255, 255);
                doc.rect(20, 25, doc.getTextWidth(ex.exercise.category) + 4, 6, 'F');
                doc.text(ex.exercise.category, 22, 29);

                // Reset color
                doc.setTextColor(0, 0, 0);

                // Date and time
                const date = new Date(ex.timestamp);
                const dateStr = date.toLocaleDateString('it-IT', { day: '2-digit', month: 'long', year: 'numeric' });
                const timeStr = ex.time || date.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });

                let y = 40;
                doc.setFontSize(12);
                doc.setFont(undefined, 'bold');
                doc.text('INFORMAZIONI BASE', 20, y);
                y += 7;

                doc.setFont(undefined, 'normal');
                doc.setFontSize(10);
                doc.text(`Data: ${dateStr}`, 20, y);
                y += 5;
                doc.text(`Ora: ${timeStr}`, 20, y);
                y += 5;
                doc.text(`Luogo: ${ex.location}`, 20, y);
                y += 5;
                doc.text(`Durata: ${ex.duration}`, 20, y);
                y += 10;

                // Location coordinates (if available)
                if (ex.locationCoords && (ex.locationCoords.lat || ex.locationCoords.lon)) {
                    doc.text(`Coordinate GPS: ${ex.locationCoords.lat}, ${ex.locationCoords.lon}`, 20, y);
                    y += 5;
                }

                y += 5;

                // Environmental context
                doc.setFontSize(12);
                doc.setFont(undefined, 'bold');
                doc.text('CONTESTO AMBIENTALE', 20, y);
                y += 7;

                doc.setFont(undefined, 'normal');
                doc.setFontSize(10);
                const envLines = doc.splitTextToSize(`Descrizione ambiente: ${ex.environment || 'Non specificato'}`, 170);
                doc.text(envLines, 20, y);
                y += envLines.length * 5 + 5;

                doc.text(`Meteo: ${ex.weather || 'N/A'}`, 20, y);
                y += 5;
                doc.text(`Livello rumore: ${ex.noiseLevel || 'N/A'}`, 20, y);
                y += 5;
                doc.text(`Eri solo/a: ${ex.alone || 'N/A'}`, 20, y);
                y += 5;
                doc.text(`Movimento: ${ex.movement || 'N/A'}`, 20, y);
                y += 10;

                // Recording tools
                if (ex.recordingTools) {
                    doc.setFontSize(12);
                    doc.setFont(undefined, 'bold');
                    doc.text('STRUMENTI UTILIZZATI', 20, y);
                    y += 7;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(10);
                    const tools = doc.splitTextToSize(ex.recordingTools, 170);
                    doc.text(tools, 20, y);
                    y += tools.length * 5 + 5;
                }

                // Notes
                doc.setFontSize(12);
                doc.setFont(undefined, 'bold');
                doc.text('CONSIDERAZIONI E NOTE', 20, y);
                y += 7;
                doc.setFont(undefined, 'normal');
                doc.setFontSize(10);
                const notes = doc.splitTextToSize(ex.notes, 170);
                doc.text(notes, 20, y);
                y += notes.length * 5 + 5;

                // Audio/Photo details with filenames
                if ((ex.audioFiles && ex.audioFiles.length > 0) || (ex.photoFiles && ex.photoFiles.length > 0)) {
                    // Check if we need a new page
                    if (y > 240) {
                        doc.addPage();
                        y = 20;
                    }

                    y += 5;
                    doc.setFontSize(12);
                    doc.setFont(undefined, 'bold');
                    doc.text('ALLEGATI MULTIMEDIALI', 20, y);
                    y += 7;

                    doc.setFontSize(10);
                    doc.setFont(undefined, 'normal');

                    if (ex.audioFiles && ex.audioFiles.length > 0) {
                        doc.setFont(undefined, 'bold');
                        doc.text(`Registrazioni Audio (${ex.audioFiles.length}):`, 20, y);
                        y += 5;
                        doc.setFont(undefined, 'normal');

                        ex.audioFiles.forEach((audio, index) => {
                            const audioName = audio.name || `Audio ${index + 1}`;
                            const audioSize = audio.size ? `(${(audio.size / 1024 / 1024).toFixed(2)} MB)` : '';
                            doc.text(`  • ${audioName} ${audioSize}`, 25, y);
                            y += 5;

                            // Check if we need a new page
                            if (y > 270) {
                                doc.addPage();
                                y = 20;
                            }
                        });
                        y += 3;
                    }

                    if (ex.photoFiles && ex.photoFiles.length > 0) {
                        doc.setFont(undefined, 'bold');
                        doc.text(`Fotografie del Luogo (${ex.photoFiles.length}):`, 20, y);
                        y += 5;
                        doc.setFont(undefined, 'normal');

                        ex.photoFiles.forEach((photo, index) => {
                            const photoName = photo.name || `Foto ${index + 1}`;
                            const photoSize = photo.size ? `(${(photo.size / 1024 / 1024).toFixed(2)} MB)` : '';
                            doc.text(`  • ${photoName} ${photoSize}`, 25, y);
                            y += 5;

                            // Check if we need a new page
                            if (y > 270) {
                                doc.addPage();
                                y = 20;
                            }
                        });
                        y += 3;
                    }
                }

                // Tags
                if (ex.tags) {
                    y += 5;
                    doc.setFontSize(10);
                    doc.setFont(undefined, 'bold');
                    doc.text('Tag:', 20, y);
                    doc.setFont(undefined, 'normal');
                    doc.text(ex.tags, 35, y);
                }

                // Rating
                if (ex.rating > 0) {
                    y += 10;
                    doc.setFontSize(14);
                    doc.setTextColor(243, 156, 18);
                    doc.text('★'.repeat(parseInt(ex.rating)), 20, y);
                }

                // Add completion timestamp at bottom
                y += 10;
                if (y > 260) {
                    doc.addPage();
                    y = 20;
                }
                doc.setFontSize(9);
                doc.setTextColor(100, 100, 100);
                const completionDate = new Date(ex.timestamp);
                const completionStr = completionDate.toLocaleString('it-IT', {
                    day: '2-digit',
                    month: 'long',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                doc.text(`Esercizio completato il: ${completionStr}`, 20, y);

                // Footer
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFontSize(8);
                    doc.setTextColor(150, 150, 150);
                    doc.text('Generato da Soundscape Studio Premium', 20, 285);
                    doc.text(`Pagina ${i} di ${pageCount}`, 170, 285);
                }

                // Save PDF using our helper function (works with proper MIME type)
                const filename = `${ex.exercise.title.replace(/[^a-z0-9]/gi, '-')}_${dateStr.replace(/\s/g, '-')}.pdf`;

                // Get PDF as blob (this preserves the correct MIME type)
                const pdfBlob = doc.output('blob');

                // Use our helper function that already works correctly
                await downloadOrShareFile(pdfBlob, filename, 'Esporta PDF Esercizio');

                if (!window.Capacitor) {
                    alert('✅ PDF esportato con successo!');
                }
            } catch (error) {
                console.error('Errore export PDF:', error);
                alert('❌ Errore durante l\'esportazione del PDF!');
            }
        }

        // Helper function to generate real DOCX using docxtemplater
        async function generateRealDOCX(content) {
            // Minimal DOCX template (base64 encoded - empty Word document)
            const templateBase64 = "UEsDBBQABgAIAAAAIQDfpNJsWgEAACAFAAATAAgCW0NvbnRlbnRfVHlwZXNdLnhtbCCiBAIooAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACslMtOwzAQRfdI/EPkLUrcskAINe2CxxIqUT7AxJPGqmNbnmlp/56J+xBCoRVqN7ESz9x7MvHNaLJubbaCiMa7UgyLgcjAVV4bNy/Fx+wlvxcZknJaWe+gFBtAMRlfX41mmwCYcbfDUjRE4UFKrBpoFRY+gOOd2sdWEd/GuQyqWqg5yNvB4E5W3hE4yqnTEOPRE9RqaSl7XvPjLUkEiyJ73BZ2XqVQIVhTKWJSuXL6l0u+cyi4M9VgYwLeMIaQvQ7dzt8Gu743Hk00GrKpivSqWsaQayu/fFx8er8ojov0UPq6NhVoXy1bnkCBIYLS2ABQa4u0Fn0rfpUcEg1MjAj2fL8LoRXlHEEw/gQTKvBJ/TTq8tC8OBPkVmZU2gVxKEIhWw5KlHIEh9B0F/3kbwJuRZ8gNvTw8m8DqHY84fnhgHrQXP1EbPXOEzuXUf+8LvpVP9xRPQp/AAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==";

            // Convert base64 to binary
            const binaryString = atob(templateBase64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }

            // Load template with PizZip
            const zip = new PizZip(bytes);
            const doc = new window.docxtemplater(zip, {
                paragraphLoop: true,
                linebreaks: true,
            });

            // Set template data
            doc.setData(content);

            // Render the document
            doc.render();

            // Generate blob
            const blob = doc.getZip().generate({
                type: 'blob',
                mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            });

            return blob;
        }

        // Export single exercise to Word (.docx)
        async function exportExerciseToWord(exerciseId) {
            // Check if premium
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nL\'esportazione Word è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per sbloccare questa funzionalità!');
                showUpgradeModal();
                return;
            }

            try {
                const ex = await getExerciseFromIndexedDB(exerciseId);
                if (!ex) {
                    alert('❌ Esercizio non trovato!');
                    return;
                }

                // Date and time
                const date = new Date(ex.timestamp);
                const dateStr = date.toLocaleDateString('it-IT', { day: '2-digit', month: 'long', year: 'numeric' });
                const timeStr = ex.time || date.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });

                // Prepare content for DOCX template
                const audioList = ex.audioFiles && ex.audioFiles.length > 0
                    ? ex.audioFiles.map((audio, i) => `Audio ${i + 1}`).join(', ')
                    : 'Nessuno';

                const photoList = ex.photoFiles && ex.photoFiles.length > 0
                    ? ex.photoFiles.map((photo, i) => `Foto ${i + 1}`).join(', ')
                    : 'Nessuna';

                const content = `
SOUNDSCAPE STUDIO - REPORT ESERCIZIO

Titolo: ${ex.exercise.title}
Categoria: ${ex.exercise.category || 'Esercizio Soundscape'}

INFORMAZIONI BASE
Data: ${dateStr}
Ora: ${timeStr}
Luogo: ${ex.location || 'Non specificato'}
${ex.locationCoords && (ex.locationCoords.lat || ex.locationCoords.lon) ? `Coordinate GPS: ${ex.locationCoords.lat}, ${ex.locationCoords.lon}` : ''}
Durata: ${ex.duration || 'Non specificata'}

CONTESTO AMBIENTALE
Descrizione ambiente: ${ex.environment || 'Non specificato'}
Meteo: ${ex.weather || 'N/A'}
Livello rumore: ${ex.noiseLevel || 'N/A'}
Eri solo/a: ${ex.alone || 'N/A'}
Movimento: ${ex.movement || 'N/A'}

${ex.recordingTools ? `STRUMENTI UTILIZZATI\n${ex.recordingTools}\n\n` : ''}

CONSIDERAZIONI E NOTE
${ex.notes || 'Nessuna nota'}

ALLEGATI MULTIMEDIALI
Registrazioni Audio: ${audioList}
Fotografie: ${photoList}

${ex.tags ? `TAG\n${ex.tags}\n\n` : ''}

${ex.rating > 0 ? `VALUTAZIONE\n${'★'.repeat(parseInt(ex.rating))}\n\n` : ''}

---
Esercizio completato il: ${date.toLocaleString('it-IT')}
Generato da Soundscape Studio Premium
`;

                // Create RTF format (compatible with Pages, Word, TextEdit)
                const rtfContent = `{\\rtf1\\ansi\\deff0
{\\fonttbl{\\f0\\fswiss\\fcharset0 Arial;}}
{\\colortbl;\\red47\\green95\\blue79;}
\\viewkind4\\uc1\\pard\\cf1\\f0\\fs28\\b SOUNDSCAPE STUDIO - REPORT ESERCIZIO\\b0\\fs22\\par
\\par
\\cf0\\b Titolo:\\b0  ${ex.exercise.title.replace(/[\\{}]/g, '')}\\par
\\b Categoria:\\b0  ${(ex.exercise.category || 'Esercizio Soundscape').replace(/[\\{}]/g, '')}\\par
\\par
\\b INFORMAZIONI BASE\\b0\\par
Data: ${dateStr}\\par
Ora: ${timeStr}\\par
Luogo: ${(ex.location || 'Non specificato').replace(/[\\{}]/g, '')}\\par
${ex.locationCoords && (ex.locationCoords.lat || ex.locationCoords.lon) ? `Coordinate GPS: ${ex.locationCoords.lat}, ${ex.locationCoords.lon}\\par` : ''}
Durata: ${(ex.duration || 'Non specificata').replace(/[\\{}]/g, '')}\\par
\\par
\\b CONTESTO AMBIENTALE\\b0\\par
Descrizione ambiente: ${(ex.environment || 'Non specificato').replace(/[\\{}]/g, '')}\\par
Meteo: ${(ex.weather || 'N/A').replace(/[\\{}]/g, '')}\\par
Livello rumore: ${(ex.noiseLevel || 'N/A').replace(/[\\{}]/g, '')}\\par
Eri solo/a: ${(ex.alone || 'N/A').replace(/[\\{}]/g, '')}\\par
Movimento: ${(ex.movement || 'N/A').replace(/[\\{}]/g, '')}\\par
\\par
${ex.recordingTools ? `\\b STRUMENTI UTILIZZATI\\b0\\par${ex.recordingTools.replace(/[\\{}]/g, '')}\\par\\par` : ''}
\\b CONSIDERAZIONI E NOTE\\b0\\par
${(ex.notes || 'Nessuna nota').replace(/[\\{}]/g, '').replace(/\n/g, '\\par ')}\\par
\\par
\\b ALLEGATI MULTIMEDIALI\\b0\\par
Registrazioni Audio: ${audioList.replace(/[\\{}]/g, '')}\\par
Fotografie: ${photoList.replace(/[\\{}]/g, '')}\\par
\\par
${ex.tags ? `\\b TAG\\b0\\par${ex.tags.replace(/[\\{}]/g, '')}\\par\\par` : ''}
${ex.rating > 0 ? `\\b VALUTAZIONE\\b0\\par${'*'.repeat(parseInt(ex.rating))}\\par\\par` : ''}
\\line ---\\par
Esercizio completato il: ${date.toLocaleString('it-IT')}\\par
Generato da Soundscape Studio Premium\\par
}`;

                const blob = new Blob([rtfContent], {
                    type: 'application/rtf'
                });

                const filename = `${ex.exercise.title.replace(/[^a-z0-9]/gi, '-')}_${dateStr.replace(/\s/g, '-')}.rtf`;

                await downloadOrShareFile(blob, filename, 'Esporta Word Esercizio');

                if (!window.Capacitor) {
                    alert('✅ Documento Word esportato con successo!');
                }

            } catch (error) {
                console.error('Errore export Word:', error);
                alert('❌ Errore durante l\'esportazione Word!');
            }
        }

        // Make functions global
        window.exportExerciseToPDF = exportExerciseToPDF;
        window.exportExerciseToWord = exportExerciseToWord;

        // Helper function for TEXT files (JSON, CSV, KML, GeoJSON) - uses UTF8
        async function downloadOrShareTextFile(textContent, filename, title = 'Salva File') {
            try {
                // On iOS with Capacitor
                if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Share && window.Capacitor.Plugins.Filesystem) {
                    const Filesystem = window.Capacitor.Plugins.Filesystem;
                    const Share = window.Capacitor.Plugins.Share;

                    // Write text file with UTF8 encoding
                    const result = await Filesystem.writeFile({
                        path: filename,
                        data: textContent,
                        directory: 'CACHE',
                        encoding: 'utf8'
                    });

                    // Share the file URI (NOT data URL!)
                    await Share.share({
                        title: title,
                        url: result.uri,
                        dialogTitle: title
                    });
                } else {
                    // Web fallback
                    const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                }
            } catch (error) {
                console.error('Text file error:', error);
                alert('❌ Errore: ' + error.message);
            }
        }

        // Helper function for BINARY files (Excel, ZIP, Audio, etc) - uses Base64
        async function downloadOrShareFile(blob, filename, title = 'Salva File') {
            try {
                // On iOS with Capacitor, use Filesystem + Share
                if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Share && window.Capacitor.Plugins.Filesystem) {
                    const Filesystem = window.Capacitor.Plugins.Filesystem;
                    const Share = window.Capacitor.Plugins.Share;

                    // Convert blob to base64
                    const reader = new FileReader();
                    const base64Data = await new Promise((resolve, reject) => {
                        reader.onloadend = () => {
                            const base64 = reader.result.split(',')[1];
                            resolve(base64);
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });

                    // Write to temporary file in Cache
                    const result = await Filesystem.writeFile({
                        path: filename,
                        data: base64Data,
                        directory: 'CACHE'
                    });

                    // Share the file URI (NOT data URL!)
                    await Share.share({
                        title: title,
                        url: result.uri,
                        dialogTitle: title
                    });
                } else {
                    // Web fallback: standard download
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    alert('✅ File pronto per il download!');
                }
            } catch (error) {
                console.error('Download/Share error:', error);
                alert('❌ Errore: ' + error.message);
            }
        }

        // Export Map as GeoJSON (PREMIUM ONLY)
        async function exportMapGeoJSON() {
            // Check if premium
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nL\'esportazione GeoJSON della mappa è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per sbloccare questa funzionalità!');
                showUpgradeModal();
                return;
            }

            if (!soundscapeData || soundscapeData.length === 0) {
                alert('⚠️ Nessun marker da esportare!');
                return;
            }

            try {
                // Create GeoJSON structure
                const geojson = {
                    type: "FeatureCollection",
                    features: soundscapeData.map(marker => ({
                        type: "Feature",
                        properties: {
                            category: marker.category,
                            notes: marker.notes,
                            timestamp: marker.timestamp,
                            hasAudio: marker.hasAudio || false,
                            exerciseTitle: marker.exerciseTitle || null,
                            exerciseId: marker.exerciseId || null
                        },
                        geometry: {
                            type: "Point",
                            coordinates: [marker.lng, marker.lat] // GeoJSON uses [lng, lat] order
                        }
                    }))
                };

                // Export as text file (GeoJSON is JSON text)
                const textContent = JSON.stringify(geojson, null, 2);
                const filename = `soundscape-map-${new Date().toISOString().split('T')[0]}.geojson`;
                await downloadOrShareTextFile(textContent, filename, 'Esporta Mappa GeoJSON');

                if (!window.Capacitor) {
                    alert('✅ Mappa esportata in formato GeoJSON!');
                }
            } catch (error) {
                console.error('Errore export GeoJSON:', error);
                alert('❌ Errore durante l\'esportazione!');
            }
        }

        // Export Map as CSV (PREMIUM ONLY)
        async function exportMapCSV() {
            // Check if premium
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nL\'esportazione CSV della mappa è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per sbloccare questa funzionalità!');
                showUpgradeModal();
                return;
            }

            if (!soundscapeData || soundscapeData.length === 0) {
                alert('⚠️ Nessun marker da esportare!');
                return;
            }

            try {
                // Create CSV header
                let csv = 'ID,Latitude,Longitude,Category,Notes,Timestamp,HasAudio,ExerciseTitle\n';

                // Add data rows
                soundscapeData.forEach(marker => {
                    const notes = (marker.notes || '').replace(/"/g, '""').replace(/\n/g, ' ');
                    const exerciseTitle = (marker.exerciseTitle || '').replace(/"/g, '""');
                    csv += `${marker.id},${marker.lat},${marker.lng},"${marker.category}","${notes}","${marker.timestamp}",${marker.hasAudio || false},"${exerciseTitle}"\n`;
                });

                // Export as text file (CSV is text)
                const filename = `soundscape-map-${new Date().toISOString().split('T')[0]}.csv`;
                await downloadOrShareTextFile(csv, filename, 'Esporta Mappa CSV');

                if (!window.Capacitor) {
                    alert('✅ Mappa esportata in formato CSV!');
                }
            } catch (error) {
                console.error('Errore export CSV:', error);
                alert('❌ Errore durante l\'esportazione!');
            }
        }

        // Make functions global
        window.exportMapGeoJSON = exportMapGeoJSON;
        window.exportMapCSV = exportMapCSV;

        // Toggle Advanced Export section
        function toggleAdvancedExport() {
            const content = document.getElementById('advancedExportContent');
            const arrow = document.getElementById('advancedExportArrow');
            const toggle = document.getElementById('advancedExportToggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(180deg)';
                arrow.textContent = '▲';
                toggle.style.background = '#e9ecef';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
                arrow.textContent = '▼';
                toggle.style.background = '#f8f9fa';
            }
        }
        window.toggleAdvancedExport = toggleAdvancedExport;

        // ==================== BACKUP & RESTORE (PREMIUM ONLY) ====================

        // Export Complete Backup (PREMIUM ONLY)
        async function exportCompleteBackup() {
            // Check if premium
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nIl backup completo è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per proteggere il tuo lavoro!');
                showUpgradeModal();
                return;
            }

            try {
                // Gather all data
                const exercises = await getAllExercisesFromIndexedDB();
                const markers = soundscapeData || [];

                // Create backup object
                const backup = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    exercises: exercises,
                    markers: markers,
                    stats: {
                        totalExercises: exercises.length,
                        totalMarkers: markers.length
                    }
                };

                // Convert to JSON and export as text file
                const json = JSON.stringify(backup, null, 2);
                const filename = `soundscape-backup-${new Date().toISOString().split('T')[0]}.json`;

                await downloadOrShareTextFile(json, filename, 'Backup Completo Soundscape');

                if (!window.Capacitor) {
                    alert(`✅ Backup completo esportato!\n\n${exercises.length} esercizi\n${markers.length} markers\n\nFile: ${filename}`);
                }
            } catch (error) {
                console.error('Errore backup:', error);
                alert('❌ Errore durante l\'esportazione del backup!');
            }
        }

        // Import Complete Backup (PREMIUM ONLY)
        async function importCompleteBackup() {
            // Check if premium
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nL\'import del backup è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per ripristinare i tuoi dati!');
                showUpgradeModal();
                return;
            }

            // Show options: file picker or paste JSON
            const choice = confirm('📥 IMPORTA BACKUP\n\nPremi OK per selezionare un file\n\nPremi ANNULLA per incollare il contenuto JSON manualmente');

            if (choice) {
                // File picker method
                await importBackupFromFile();
            } else {
                // Manual paste method
                await importBackupFromPaste();
            }
        }

        // Method 1: Import from file picker
        async function importBackupFromFile() {
            // Confirm action
            if (!confirm('⚠️ ATTENZIONE\n\nL\'import sostituirà tutti i dati attuali con quelli del backup.\n\nSei sicuro di voler continuare?')) {
                return;
            }

            // Create file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,application/json,text/plain';

            input.onchange = async (e) => {
                try {
                    const file = e.target.files[0];
                    if (!file) return;

                    console.log('📄 File selected:', file.name, 'Size:', file.size, 'Type:', file.type);

                    // Read file
                    const text = await file.text();
                    console.log('📄 File read, length:', text.length);
                    console.log('📄 First 200 chars:', text.substring(0, 200));

                    await processBackupData(text);

                } catch (error) {
                    console.error('❌ Errore import file:', error);
                    console.error('Error type:', error.constructor.name);
                    console.error('Error message:', error.message);
                    console.error('Error stack:', error.stack);
                    alert(`❌ Errore durante l\'import del backup!\n\nErrore: ${error.message}\n\nProva il metodo "Incolla JSON" invece.`);
                }
            };

            input.click();
        }

        // Method 2: Import from pasted JSON
        async function importBackupFromPaste() {
            // Confirm action
            if (!confirm('⚠️ ATTENZIONE\n\nL\'import sostituirà tutti i dati attuali con quelli del backup.\n\nSei sicuro di voler continuare?')) {
                return;
            }

            // Create a modal with textarea
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:10000;display:flex;align-items:center;justify-content:center;padding:20px;';

            const content = document.createElement('div');
            content.style.cssText = 'background:white;border-radius:12px;padding:20px;max-width:600px;width:100%;max-height:80%;overflow:auto;';

            content.innerHTML = `
                <h3 style="margin:0 0 15px 0;color:#2d5f4f;">📥 Incolla il contenuto del backup JSON</h3>
                <p style="color:#666;font-size:14px;margin-bottom:15px;">
                    1. Apri il file backup con Note o un editor di testo<br>
                    2. Copia tutto il contenuto (Cmd+A, Cmd+C)<br>
                    3. Incolla qui sotto (Cmd+V)
                </p>
                <textarea id="backupJsonInput" style="width:100%;height:300px;padding:10px;border:2px solid #ddd;border-radius:6px;font-family:monospace;font-size:12px;" placeholder='{"version":"1.0","timestamp":"...",...}'></textarea>
                <div style="margin-top:15px;display:flex;gap:10px;">
                    <button id="importBackupBtn" style="flex:1;padding:12px;background:#2d5f4f;color:white;border:none;border-radius:6px;font-weight:600;cursor:pointer;">
                        ✅ Importa Backup
                    </button>
                    <button id="cancelBackupBtn" style="flex:1;padding:12px;background:#999;color:white;border:none;border-radius:6px;font-weight:600;cursor:pointer;">
                        ❌ Annulla
                    </button>
                </div>
            `;

            modal.appendChild(content);
            document.body.appendChild(modal);

            // Handle import
            document.getElementById('importBackupBtn').onclick = async () => {
                const jsonText = document.getElementById('backupJsonInput').value.trim();
                if (!jsonText) {
                    alert('❌ Incolla il contenuto JSON del backup!');
                    return;
                }

                try {
                    await processBackupData(jsonText);
                    document.body.removeChild(modal);
                } catch (error) {
                    alert(`❌ Errore: ${error.message}`);
                }
            };

            // Handle cancel
            document.getElementById('cancelBackupBtn').onclick = () => {
                document.body.removeChild(modal);
            };
        }

        // Process backup data (common function for both methods)
        async function processBackupData(text) {
            console.log('📄 Processing backup, length:', text.length);
            console.log('📄 First 200 chars:', text.substring(0, 200));

            const backup = JSON.parse(text);
            console.log('✅ JSON parsed successfully');
            console.log('📦 Backup keys:', Object.keys(backup));
            console.log('📦 Version:', backup.version);
            console.log('📦 Exercises count:', backup.exercises?.length);
            console.log('📦 Markers count:', backup.markers?.length);

            // Validate backup - be more lenient
            if (!backup.exercises || !Array.isArray(backup.exercises)) {
                console.error('❌ Validation failed!');
                console.error('Has version?', !!backup.version);
                console.error('Has exercises?', !!backup.exercises);
                console.error('Is exercises array?', Array.isArray(backup.exercises));
                console.error('Has markers?', !!backup.markers);
                throw new Error(`File di backup non valido!\n\nVersion: ${!!backup.version}\nExercises: ${!!backup.exercises && Array.isArray(backup.exercises)}\nMarkers: ${!!backup.markers}`);
            }

            // Clear existing data first
            console.log('🗑️ Clearing existing data...');
            try {
                // Clear all exercises from IndexedDB
                const allExercises = await getAllExercisesFromIndexedDB();
                for (const ex of allExercises) {
                    await deleteExerciseFromIndexedDB(ex.id);
                }
                console.log(`✅ Cleared ${allExercises.length} existing exercises`);
            } catch (error) {
                console.warn('⚠️ Error clearing data (may not exist):', error);
            }

            // Restore exercises to IndexedDB
            console.log('💾 Restoring exercises...');
            for (const exercise of backup.exercises) {
                // Remove the id field to let IndexedDB generate a new one
                const exerciseData = { ...exercise };
                delete exerciseData.id;
                await saveExerciseToIndexedDB(exerciseData);
            }
            console.log(`✅ ${backup.exercises.length} exercises restored`);

            // Restore markers (use empty array if not present)
            const markers = backup.markers || [];
            console.log('🗺️ Restoring markers...');
            soundscapeData = markers;
            saveSoundscapeData();
            console.log(`✅ ${markers.length} markers restored`);

            // Reload UI
            await updateCompletedExercisesCounter();
            if (document.getElementById('map') && document.getElementById('map').classList.contains('active')) {
                updateMarkersList();
                // Reload map markers
                if (leafletMap) {
                    mapMarkers.forEach(m => m.marker.remove());
                    mapMarkers = [];
                    soundscapeData.forEach(markerData => {
                        const icon = L.divIcon({
                            html: `<div style="font-size: 28px;">${categoryIcons[markerData.category]}</div>`,
                            className: 'custom-marker',
                            iconSize: [30, 30],
                            iconAnchor: [15, 30]
                        });
                        const marker = L.marker([markerData.lat, markerData.lng], { icon: icon }).addTo(leafletMap);
                        const popupContent = createPopupContent(markerData);
                        marker.bindPopup(popupContent, { maxWidth: 280, minWidth: 200 });
                        mapMarkers.push({ marker: marker, data: markerData });
                    });
                }
            }

            alert(`✅ Backup ripristinato con successo!\n\n${backup.exercises.length} esercizi\n${markers.length} markers\n\nRicarica la pagina per vedere tutti i dati.`);

            // Reload page to ensure everything is fresh
            setTimeout(() => location.reload(), 2000);
        }

        // ==================== NEW EXPORT FORMATS (PREMIUM) ====================

        // 📊 Export to Excel (.xlsx)
        async function exportToExcel() {
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nL\'export Excel è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per esportare i tuoi dati!');
                showUpgradeModal();
                return;
            }

            // Check if XLSX library is loaded
            if (typeof XLSX === 'undefined') {
                alert('❌ Errore: Libreria Excel non caricata.\n\nRicarica la pagina e riprova.');
                return;
            }

            try {
                const exercises = await getAllExercisesFromIndexedDB();

                if (exercises.length === 0) {
                    alert('ℹ️ Nessun esercizio da esportare\n\nCompleta almeno un esercizio prima di esportare.');
                    return;
                }

                // Prepare data for Excel
                const data = exercises.map(ex => ({
                    'Data': new Date(ex.timestamp).toLocaleDateString('it-IT'),
                    'Titolo': ex.exercise.title,
                    'Categoria': ex.exercise.category || 'N/A',
                    'Difficoltà': ex.exercise.difficulty || 'N/A',
                    'Luogo': ex.locationName || 'N/A',
                    'Coordinate': ex.locationCoords ? `${ex.locationCoords.lat}, ${ex.locationCoords.lon}` : 'N/A',
                    'Note': ex.notes || '',
                    'Audio': ex.audioFiles ? ex.audioFiles.length : 0,
                    'Foto': ex.photoFiles ? ex.photoFiles.length : 0
                }));

                // Create workbook
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(data);

                // Set column widths
                ws['!cols'] = [
                    {wch: 12}, // Data
                    {wch: 40}, // Titolo
                    {wch: 20}, // Categoria
                    {wch: 12}, // Difficoltà
                    {wch: 30}, // Luogo
                    {wch: 25}, // Coordinate
                    {wch: 50}, // Note
                    {wch: 8},  // Audio
                    {wch: 8}   // Foto
                ];

                XLSX.utils.book_append_sheet(wb, ws, "Esercizi Soundscape");

                // Generate filename
                const filename = `soundscape-esercizi-${new Date().toISOString().split('T')[0]}.xlsx`;

                // Generate blob for mobile
                const wbout = XLSX.write(wb, {bookType:'xlsx', type:'array'});
                const blob = new Blob([wbout], {type:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"});

                await downloadOrShareFile(blob, filename, 'Esporta Excel Esercizi');

                if (!window.Capacitor) {
                    alert(`✅ Export Excel completato!\n\n${exercises.length} esercizi esportati\n\nFile: ${filename}`);
                }

            } catch (error) {
                console.error('Excel export error:', error);
                alert('❌ Errore durante l\'export Excel:\n' + error.message);
            }
        }

        // 🗺️ Export to KML (Google Earth/Maps)
        async function exportToKML() {
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nL\'export KML è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per visualizzare i tuoi markers su Google Earth!');
                showUpgradeModal();
                return;
            }

            try {
                if (!soundscapeData || soundscapeData.length === 0) {
                    alert('ℹ️ Nessun marker da esportare\n\nAggiungi almeno un marker sulla mappa prima di esportare.');
                    return;
                }

                // KML header
                let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Soundscape Studio - Markers</name>
    <description>Soundscape markers esportati da Soundscape Studio</description>

    <!-- Styles for different categories -->
    <Style id="traffico">
      <IconStyle><color>ff0000ff</color><scale>1.1</scale></IconStyle>
    </Style>
    <Style id="mercato">
      <IconStyle><color>ff00ff00</color><scale>1.1</scale></IconStyle>
    </Style>
    <Style id="natura">
      <IconStyle><color>ff00aa00</color><scale>1.1</scale></IconStyle>
    </Style>
    <Style id="costa">
      <IconStyle><color>ffff8800</color><scale>1.1</scale></IconStyle>
    </Style>
    <Style id="default">
      <IconStyle><color>ffaaaaaa</color><scale>1.1</scale></IconStyle>
    </Style>
`;

                // Add placemarks
                soundscapeData.forEach(marker => {
                    const date = new Date(marker.timestamp).toLocaleDateString('it-IT');
                    const category = marker.category || 'default';
                    const notes = marker.notes ? marker.notes.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'Nessuna nota';

                    kml += `
    <Placemark>
      <name>${marker.exerciseTitle || 'Marker ' + marker.id}</name>
      <description><![CDATA[
        <b>Data:</b> ${date}<br/>
        <b>Categoria:</b> ${category}<br/>
        <b>Note:</b> ${notes}<br/>
        ${marker.hasAudio ? '<b>🎵 Audio presente</b>' : ''}
      ]]></description>
      <styleUrl>#${category}</styleUrl>
      <Point>
        <coordinates>${marker.lng},${marker.lat},0</coordinates>
      </Point>
    </Placemark>`;
                });

                kml += `
  </Document>
</kml>`;

                // Export as text file (KML is XML text)
                const filename = `soundscape-markers-${new Date().toISOString().split('T')[0]}.kml`;
                await downloadOrShareTextFile(kml, filename, 'Esporta KML per Google Earth');

                if (!window.Capacitor) {
                    alert(`✅ Export KML completato!\n\n${soundscapeData.length} markers esportati\n\nApri il file con:\n• Google Earth\n• Google Maps\n• Qualsiasi app GPS\n\nFile: ${filename}`);
                }

            } catch (error) {
                console.error('KML export error:', error);
                alert('❌ Errore durante l\'export KML:\n' + error.message);
            }
        }

        // 📝 Export to Word (.docx)
        async function exportToWord() {
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nL\'export Word è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per creare report professionali!');
                showUpgradeModal();
                return;
            }

            try {
                const exercises = await getAllExercisesFromIndexedDB();

                if (exercises.length === 0) {
                    alert('ℹ️ Nessun esercizio da esportare\n\nCompleta almeno un esercizio prima di esportare.');
                    return;
                }

                // Build text content for all exercises
                let content = `SOUNDSCAPE STUDIO - REPORT ESERCIZI

Generato il: ${new Date().toLocaleDateString('it-IT')}
Totale esercizi: ${exercises.length}

================================================================================

`;

                exercises.forEach((ex, index) => {
                    const date = new Date(ex.timestamp).toLocaleDateString('it-IT');
                    content += `
${index + 1}. ${ex.exercise.title}
----------------------------------------
Data: ${date}
Categoria: ${ex.exercise.category || 'N/A'}
Difficolta: ${ex.exercise.difficulty || 'N/A'}
${ex.locationName ? `Luogo: ${ex.locationName}` : ''}
${ex.locationCoords ? `Coordinate: ${ex.locationCoords.lat}, ${ex.locationCoords.lon}` : ''}

${ex.notes ? `NOTE:\n${ex.notes}\n` : ''}

${ex.audioFiles && ex.audioFiles.length > 0 ? `${ex.audioFiles.length} file audio registrati` : ''}
${ex.photoFiles && ex.photoFiles.length > 0 ? `${ex.photoFiles.length} foto allegate` : ''}

================================================================================

`;
                });

                content += `
Generato con Soundscape Studio Premium
Professional Field Recording & Composition Toolkit
`;

                // Create RTF format (compatible with Pages, Word, TextEdit)
                let rtfContent = `{\\rtf1\\ansi\\deff0
{\\fonttbl{\\f0\\fswiss\\fcharset0 Arial;}}
{\\colortbl;\\red47\\green95\\blue79;}
\\viewkind4\\uc1\\pard\\cf1\\f0\\fs28\\b SOUNDSCAPE STUDIO - REPORT ESERCIZI\\b0\\fs22\\par
\\par
\\cf0 Generato il: ${new Date().toLocaleDateString('it-IT')}\\par
Totale esercizi: ${exercises.length}\\par
\\par
================================================================================\\par
\\par
`;

                exercises.forEach((ex, index) => {
                    const date = new Date(ex.timestamp).toLocaleDateString('it-IT');
                    const title = ex.exercise.title.replace(/[\\{}]/g, '');
                    const category = (ex.exercise.category || 'N/A').replace(/[\\{}]/g, '');
                    const difficulty = (ex.exercise.difficulty || 'N/A').replace(/[\\{}]/g, '');
                    const location = ex.locationName ? ex.locationName.replace(/[\\{}]/g, '') : '';
                    const notes = ex.notes ? ex.notes.replace(/[\\{}]/g, '').replace(/\n/g, '\\par ') : '';

                    rtfContent += `\\b ${index + 1}. ${title}\\b0\\par
----------------------------------------\\par
Data: ${date}\\par
Categoria: ${category}\\par
Difficolta: ${difficulty}\\par
${location ? `Luogo: ${location}\\par` : ''}
${ex.locationCoords ? `Coordinate: ${ex.locationCoords.lat}, ${ex.locationCoords.lon}\\par` : ''}
\\par
${notes ? `NOTE:\\par ${notes}\\par\\par` : ''}
${ex.audioFiles && ex.audioFiles.length > 0 ? `${ex.audioFiles.length} file audio registrati\\par` : ''}
${ex.photoFiles && ex.photoFiles.length > 0 ? `${ex.photoFiles.length} foto allegate\\par` : ''}
\\par
================================================================================\\par
\\par
`;
                });

                rtfContent += `\\par
Generato con Soundscape Studio Premium\\par
Professional Field Recording & Composition Toolkit\\par
}`;

                const blob = new Blob([rtfContent], {
                    type: 'application/rtf'
                });

                const filename = `soundscape-report-${new Date().toISOString().split('T')[0]}.rtf`;

                await downloadOrShareFile(blob, filename, 'Esporta Report Word');

                if (!window.Capacitor) {
                    alert(`✅ Export Word completato!\n\n${exercises.length} esercizi esportati\n\nApri con Microsoft Word, Google Docs o Pages\n\nFile: ${filename}`);
                }

            } catch (error) {
                console.error('Word export error:', error);
                alert('❌ Errore durante l\'export Word:\n' + error.message);
            }
        }

        // Convert audio blob to MP3 using lamejs
        async function convertToMP3(audioBlob) {
            try {
                // Check if blob is valid
                if (!audioBlob || audioBlob.size === 0) {
                    console.warn('⚠️ Blob audio vuoto o non valido, conversione saltata');
                    return audioBlob;
                }

                // Create audio context
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Resume AudioContext if suspended (iOS requirement)
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                // Convert blob to array buffer
                const arrayBuffer = await audioBlob.arrayBuffer();

                // Validate array buffer
                if (arrayBuffer.byteLength === 0) {
                    console.warn('⚠️ Buffer audio vuoto, conversione saltata');
                    return audioBlob;
                }

                console.log(`🔄 Decodifica audio (${(arrayBuffer.byteLength / 1024).toFixed(1)} KB)...`);

                // Decode audio data with better error handling
                let audioBuffer;
                try {
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                } catch (decodeError) {
                    console.error('❌ Decodifica audio fallita:', decodeError);
                    console.warn('⚠️ Restituisco blob originale senza conversione MP3');
                    // Close context to prevent memory leak
                    await audioContext.close();
                    return audioBlob;
                }

                // Validate decoded audio
                if (!audioBuffer || audioBuffer.length === 0) {
                    console.warn('⚠️ Audio decodificato vuoto, restituisco blob originale');
                    await audioContext.close();
                    return audioBlob;
                }

                console.log(`✅ Audio decodificato: ${audioBuffer.duration.toFixed(2)}s, ${audioBuffer.sampleRate} Hz`);

                // Get samples from first channel (mono)
                const samples = audioBuffer.getChannelData(0);

                // Convert Float32Array to Int16Array for MP3 encoder
                const samplesInt16 = new Int16Array(samples.length);
                for (let i = 0; i < samples.length; i++) {
                    const s = Math.max(-1, Math.min(1, samples[i]));
                    samplesInt16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }

                // MP3 encoder configuration
                const sampleRate = audioBuffer.sampleRate;
                const kbps = 128; // 128 kbps quality
                const mp3encoder = new lamejs.Mp3Encoder(1, sampleRate, kbps);

                console.log(`🎵 Codifica in MP3 (${kbps} kbps)...`);

                // Encode to MP3
                const mp3Data = [];
                const sampleBlockSize = 1152; // Standard MP3 frame size

                for (let i = 0; i < samplesInt16.length; i += sampleBlockSize) {
                    const sampleChunk = samplesInt16.subarray(i, i + sampleBlockSize);
                    const mp3buf = mp3encoder.encodeBuffer(sampleChunk);
                    if (mp3buf.length > 0) {
                        mp3Data.push(mp3buf);
                    }
                }

                // Flush remaining data
                const mp3buf = mp3encoder.flush();
                if (mp3buf.length > 0) {
                    mp3Data.push(mp3buf);
                }

                // Create MP3 blob
                const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });

                console.log(`✅ MP3 creato: ${(mp3Blob.size / 1024).toFixed(1)} KB`);

                // Close audio context to free resources
                await audioContext.close();

                return mp3Blob;

            } catch (error) {
                console.error('❌ Errore conversione MP3:', error);
                console.warn('⚠️ Restituisco blob audio originale senza conversione');
                // Fallback: return original blob
                return audioBlob;
            }
        }

        // 🎵 Export Audio ZIP
        async function exportAudioZIP() {
            if (!isPremium) {
                alert('⚠️ Funzione Premium\n\nL\'export audio è disponibile solo nella versione Premium.\n\n🌟 Passa a Premium per scaricare tutti i tuoi audio!');
                showUpgradeModal();
                return;
            }

            try {
                // Get exercises audio
                const exercises = await getAllExercisesFromIndexedDB();
                const exercisesWithAudio = exercises.filter(ex => ex.audioFiles && ex.audioFiles.length > 0);

                // Get map markers audio
                const markersWithAudio = [];
                for (const marker of soundscapeData) {
                    const audioBlob = await getAudioFromIndexedDB(marker.id);
                    if (audioBlob) {
                        markersWithAudio.push({
                            marker: marker,
                            audioBlob: audioBlob
                        });
                    }
                }

                // Check if there's any audio to export
                if (exercisesWithAudio.length === 0 && markersWithAudio.length === 0) {
                    alert('ℹ️ Nessun audio da esportare\n\nCompleta almeno un esercizio con audio o registra audio su un marker della mappa.');
                    return;
                }

                // Create ZIP
                const zip = new JSZip();

                // Add README
                const totalExerciseAudio = exercisesWithAudio.reduce((sum, ex) => sum + ex.audioFiles.length, 0);
                const totalMarkerAudio = markersWithAudio.length;
                const totalAudio = totalExerciseAudio + totalMarkerAudio;

                let readme = `SOUNDSCAPE STUDIO - Audio Export
=================================

Data export: ${new Date().toLocaleString('it-IT')}
Totale esercizi: ${exercisesWithAudio.length}
Totale marker mappa: ${markersWithAudio.length}
Totale file audio: ${totalAudio}

FORMATO AUDIO:
-------------
Gli audio sono esportati nel formato originale di registrazione
Formati possibili: WebM, WAV, M4A
Compatibili con VLC, Audacity, DAW professionali

STRUTTURA CARTELLE:
------------------
/exercises/ - Audio dagli esercizi svolti
  Ogni esercizio ha la propria cartella con:
  - File audio numerati (audio-1.webm, audio-2.webm, etc.)
  - Info.txt con metadati dell'esercizio

/map-markers/ - Audio registrati sulla mappa
  Ogni marker ha un file audio con:
  - audio-{marker-id}.webm
  - Info.txt con coordinate e note

COME USARE:
----------
1. Estrai il file ZIP
2. Naviga nelle cartelle per trovare i tuoi audio
3. Importa in VLC, Audacity, DAW o altro software
4. Per convertire in MP3: usa Audacity (File > Export > MP3)
5. Compatibile con Windows, Mac, iOS, Android

Generato con Soundscape Studio Premium
https://soundscape-studio.app
`;

                zip.file('README.txt', readme);

                // Add EXERCISES audio files
                let totalAudioCount = 0;
                for (const ex of exercisesWithAudio) {
                    const date = new Date(ex.timestamp).toISOString().split('T')[0];
                    const folderName = `exercises/${date}-${ex.exercise.title.substring(0, 30).replace(/[^a-zA-Z0-9]/g, '-')}`;

                    // Add exercise info
                    const info = `Esercizio: ${ex.exercise.title}
Data: ${new Date(ex.timestamp).toLocaleString('it-IT')}
Categoria: ${ex.exercise.category || 'N/A'}
Luogo: ${ex.locationName || 'N/A'}
Note: ${ex.notes || 'Nessuna nota'}
Numero file audio: ${ex.audioFiles.length}
`;
                    zip.file(`${folderName}/Info.txt`, info);

                    // Add audio files (original format - no conversion)
                    for (let i = 0; i < ex.audioFiles.length; i++) {
                        const audioBlob = ex.audioFiles[i];

                        // Validate that audioBlob exists and has data
                        if (!audioBlob) {
                            console.warn(`⚠️ Skipping audio ${i + 1}: null or undefined`);
                            continue;
                        }

                        // Check if it's a Blob or Blob-like object (has size and type properties)
                        if (!(audioBlob instanceof Blob) && (!audioBlob.size || audioBlob.size === undefined)) {
                            console.warn(`⚠️ Skipping audio ${i + 1}: not a Blob and no size property`);
                            console.log('Audio object:', audioBlob);
                            continue;
                        }

                        // Skip empty blobs
                        if (audioBlob.size === 0) {
                            console.warn(`⚠️ Skipping audio ${i + 1}: empty (0 bytes)`);
                            continue;
                        }

                        // If it's not a Blob but has data, try to convert it
                        let finalBlob = audioBlob;
                        if (!(audioBlob instanceof Blob)) {
                            console.log(`🔄 Converting audio ${i + 1} to Blob...`);
                            try {
                                finalBlob = new Blob([audioBlob], { type: audioBlob.type || 'audio/webm' });
                            } catch (convErr) {
                                console.warn(`⚠️ Failed to convert audio ${i + 1} to Blob:`, convErr);
                                continue;
                            }
                        }

                        // Get file extension from blob type
                        const fileExt = finalBlob.type === 'audio/webm' ? 'webm' :
                                       finalBlob.type === 'audio/wav' ? 'wav' :
                                       finalBlob.type === 'audio/mp4' ? 'm4a' : 'webm';

                        console.log(`Adding exercise audio ${i + 1}/${ex.audioFiles.length} (${fileExt}, ${(finalBlob.size / 1024).toFixed(1)} KB)...`);

                        // Convert Blob to ArrayBuffer using FileReader (compatible with all browsers)
                        const arrayBuffer = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsArrayBuffer(finalBlob);
                        });
                        zip.file(`${folderName}/audio-${i + 1}.${fileExt}`, arrayBuffer);
                        totalAudioCount++;
                    }
                }

                // Add MAP MARKERS audio files
                for (let i = 0; i < markersWithAudio.length; i++) {
                    const item = markersWithAudio[i];
                    const marker = item.marker;
                    const audioBlob = item.audioBlob;

                    // Create folder name
                    const date = new Date(marker.timestamp || Date.now()).toISOString().split('T')[0];
                    const categoryName = marker.category || 'other';
                    // Convert marker.id to string before using substring
                    const markerIdStr = String(marker.id);
                    const folderName = `map-markers/${date}-${categoryName}-${markerIdStr.substring(0, 8)}`;

                    // Add marker info
                    const info = `Marker ID: ${marker.id}
Data: ${new Date(marker.timestamp || Date.now()).toLocaleString('it-IT')}
Categoria: ${marker.category || 'N/A'}
Coordinate: ${marker.lat.toFixed(6)}, ${marker.lng.toFixed(6)}
Note: ${marker.notes || 'Nessuna nota'}
`;
                    zip.file(`${folderName}/Info.txt`, info);

                    // Validate that audioBlob exists and has data
                    if (!audioBlob) {
                        console.warn(`⚠️ Skipping marker audio ${i + 1}: null or undefined`);
                        continue;
                    }

                    // Check if it's a Blob or Blob-like object
                    if (!(audioBlob instanceof Blob) && (!audioBlob.size || audioBlob.size === undefined)) {
                        console.warn(`⚠️ Skipping marker audio ${i + 1}: not a Blob and no size property`);
                        console.log('Marker audio object:', audioBlob);
                        continue;
                    }

                    // Skip empty blobs
                    if (audioBlob.size === 0) {
                        console.warn(`⚠️ Skipping marker audio ${i + 1}: empty (0 bytes)`);
                        continue;
                    }

                    // If it's not a Blob but has data, try to convert it
                    let finalBlob = audioBlob;
                    if (!(audioBlob instanceof Blob)) {
                        console.log(`🔄 Converting marker audio ${i + 1} to Blob...`);
                        try {
                            finalBlob = new Blob([audioBlob], { type: audioBlob.type || 'audio/webm' });
                        } catch (convErr) {
                            console.warn(`⚠️ Failed to convert marker audio ${i + 1} to Blob:`, convErr);
                            continue;
                        }
                    }

                    // Add audio in original format (no conversion)
                    const fileExt = finalBlob.type === 'audio/webm' ? 'webm' :
                                   finalBlob.type === 'audio/wav' ? 'wav' :
                                   finalBlob.type === 'audio/mp4' ? 'm4a' : 'webm';

                    console.log(`Adding marker audio ${i + 1}/${markersWithAudio.length} (${fileExt}, ${(finalBlob.size / 1024).toFixed(1)} KB)...`);

                    // Convert Blob to ArrayBuffer using FileReader (compatible with all browsers)
                    const arrayBuffer = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(finalBlob);
                    });
                    zip.file(`${folderName}/audio-${markerIdStr.substring(0, 8)}.${fileExt}`, arrayBuffer);
                    totalAudioCount++;
                }

                // Generate ZIP
                const content = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                }, (metadata) => {
                    console.log(`Compressing: ${metadata.percent.toFixed(0)}%`);
                });

                // Generate filename with full timestamp to avoid overwrite prompts
                const now = new Date();
                const timestamp = now.toISOString().replace(/[:.]/g, '-').split('.')[0]; // Format: 2025-10-24T14-30-45
                const filename = `soundscape-audio-${timestamp}.zip`;

                // Use helper function for binary file
                await downloadOrShareFile(content, filename, 'Esporta Audio ZIP');

                if (!window.Capacitor) {
                    alert(`✅ Export Audio ZIP completato!\n\n${exercisesWithAudio.length} esercizi\n${markersWithAudio.length} marker mappa\n${totalAudioCount} file audio totali\n\nEstrai il ZIP per accedere agli audio organizzati per categoria\n\nFile: ${filename}`);
                }

            } catch (error) {
                console.error('Audio ZIP export error:', error);
                alert('❌ Errore durante l\'export Audio ZIP:\n' + error.message);
            }
        }

        // Make functions global
        window.exportCompleteBackup = exportCompleteBackup;
        window.importCompleteBackup = importCompleteBackup;
        window.exportToExcel = exportToExcel;
        window.exportToKML = exportToKML;
        window.exportToWord = exportToWord;
        window.exportAudioZIP = exportAudioZIP;

        // Initialize premium UI on load
        window.addEventListener('DOMContentLoaded', () => {
            updatePremiumUI();
            initEmailJS();
        });

        // ==================== CONTACT FORM (MAILTO FALLBACK) ====================
        function initEmailJS() {
            const contactForm = document.getElementById('contactForm');
            const contactForm2 = document.getElementById('contactForm2');

            if (contactForm) {
                contactForm.addEventListener('submit', sendContactEmail);
            }
            if (contactForm2) {
                contactForm2.addEventListener('submit', sendContactEmail);
            }
        }

        function sendContactEmail(e) {
            e.preventDefault();

            const formId = e.target.id;
            const formSuffix = formId === 'contactForm2' ? '2' : '';

            // Get form values
            const name = document.getElementById('contactName' + formSuffix).value;
            const email = document.getElementById('contactEmail' + formSuffix).value;
            const subject = document.getElementById('contactSubject' + formSuffix).value;
            const message = document.getElementById('contactMessage' + formSuffix).value;

            // Create mailto link with pre-filled content
            const mailtoSubject = encodeURIComponent(`[Soundscape Studio ITA] ${subject}`);
            const mailtoBody = encodeURIComponent(
                `Nome: ${name}\n` +
                `Email: ${email}\n` +
                `Oggetto: ${subject}\n\n` +
                `Messaggio:\n${message}`
            );

            const mailtoLink = `mailto:soundscapestudiopro@gmail.com?subject=${mailtoSubject}&body=${mailtoBody}`;

            // Open Mail app with pre-filled data
            window.location.href = mailtoLink;

            // Show confirmation and reset form
            const statusEl = document.getElementById('contactFormStatus' + formSuffix);
            statusEl.textContent = '✅ Apertura app Mail... Completa l\'invio dalla tua app Mail.';
            statusEl.style.display = 'block';
            statusEl.style.color = '#4CAF50';

            setTimeout(() => {
                e.target.reset();
                statusEl.style.display = 'none';
            }, 3000);
        }

        // ==================== SPECTROGRAM PLAYBACK SECTION ====================

        // Variables for spectrogram playback
        let spectrogramPlaybackAudioContext = null;
        let spectrogramPlaybackAnalyser = null;
        let spectrogramPlaybackSource = null;
        let spectrogramPlaybackGainNode = null;
        let spectrogramPlaybackDataArray = null;
        let spectrogramPlaybackAnimationId = null;
        let spectrogramPlaybackCanvas = null;
        let spectrogramPlaybackCtx = null;
        let spectrogramPlaybackImageData = null;
        let spectrogramCurrentAudio = null;
        let spectrogramAudioBuffer = null;
        let spectrogramStartTime = 0;
        let spectrogramPauseTime = 0;
        let spectrogramIsPlaying = false;
        let spectrogramIsPaused = false;

        // Initialize spectrogram playback on page load
        function initSpectrogramPlayback() {
            console.log('🎵 Initializing Spectrogram Playback...');

            // Get canvas
            spectrogramPlaybackCanvas = document.getElementById('spectrogramPlaybackCanvas');
            if (!spectrogramPlaybackCanvas) {
                console.error('❌ Spectrogram canvas not found');
                return;
            }
            spectrogramPlaybackCtx = spectrogramPlaybackCanvas.getContext('2d');

            // Load available audio files
            loadSpectrogramAudioList();
            console.log('✅ Spectrogram Playback initialized');
        }

        // Show/hide source panels
        function showSpectrogramSource(source) {
            // Hide all panels
            document.getElementById('spectrogramExercisesPanel').style.display = 'none';
            document.getElementById('spectrogramMarkersPanel').style.display = 'none';
            document.getElementById('spectrogramDevicePanel').style.display = 'none';

            // Reset button styles
            document.querySelectorAll('#spectrogramSourceExercises, #spectrogramSourceMarkers, #spectrogramSourceDevice').forEach(btn => {
                btn.style.background = '#4a9d7f';
                btn.style.opacity = '0.7';
            });

            // Show selected panel and highlight button
            if (source === 'exercises') {
                document.getElementById('spectrogramExercisesPanel').style.display = 'block';
                document.getElementById('spectrogramSourceExercises').style.opacity = '1';
                loadSpectrogramExercises();
            } else if (source === 'markers') {
                document.getElementById('spectrogramMarkersPanel').style.display = 'block';
                document.getElementById('spectrogramSourceMarkers').style.opacity = '1';
                loadSpectrogramMarkers();
            } else if (source === 'device') {
                document.getElementById('spectrogramDevicePanel').style.display = 'block';
                document.getElementById('spectrogramSourceDevice').style.opacity = '1';
            }
        }

        // Load exercises with audio
        async function loadSpectrogramExercises() {
            const selector = document.getElementById('spectrogramExerciseSelector');
            const noMsg = document.getElementById('spectrogramNoExercises');

            if (!selector) return;

            // Clear options
            selector.innerHTML = '<option value="">-- Seleziona un esercizio --</option>';

            let count = 0;

            // Load from database
            const allExercises = await getAllExercisesFromIndexedDB();

            for (const ex of allExercises) {
                // Check if exercise has audio files (array)
                if (ex.audioFiles && ex.audioFiles.length > 0) {
                    const option = document.createElement('option');
                    option.value = ex.id;
                    const categoryName = ex.exercise?.category || ex.category || 'Esercizio';
                    const dateStr = ex.date || ex.timestamp;
                    option.textContent = `${categoryName} - ${new Date(dateStr).toLocaleDateString()}`;
                    selector.appendChild(option);
                    count++;
                }
            }

            // Show/hide message
            noMsg.style.display = count === 0 ? 'block' : 'none';
            selector.disabled = count === 0;

            console.log(`📝 Loaded ${count} exercises with audio`);
        }

        // Load markers with audio
        async function loadSpectrogramMarkers() {
            const selector = document.getElementById('spectrogramMarkerSelector');
            const noMsg = document.getElementById('spectrogramNoMarkers');

            if (!selector) return;

            // Clear options
            selector.innerHTML = '<option value="">-- Seleziona un marker --</option>';

            let count = 0;

            // Load markers from soundscapeData (array in memory/localStorage)
            for (const marker of soundscapeData) {
                // Check if marker has audio by checking hasAudio flag or trying to get audio from IndexedDB
                if (marker.hasAudio) {
                    const option = document.createElement('option');
                    option.value = marker.id;
                    const categoryName = document.querySelector(`#markerCategory option[value="${marker.category}"]`)?.textContent || marker.category || 'Marker';
                    option.textContent = `${categoryName} - ${marker.notes || new Date(marker.timestamp).toLocaleDateString()}`;
                    selector.appendChild(option);
                    count++;
                }
            }

            // Show/hide message
            noMsg.style.display = count === 0 ? 'block' : 'none';
            selector.disabled = count === 0;

            console.log(`📍 Loaded ${count} markers with audio`);
        }

        // Handle exercise selection
        async function onSpectrogramExerciseSelected(exerciseId) {
            if (!exerciseId) return;

            const id = parseInt(exerciseId);
            console.log(`🎵 Loading exercise audio #${id}`);

            // Stop current playback
            stopSpectrogramAudio();

            // Load from database using the correct function
            const exercise = await getExerciseFromIndexedDB(id);

            if (exercise && exercise.audioFiles && exercise.audioFiles.length > 0) {
                // Use first audio file from array
                const audioBlob = exercise.audioFiles[0];
                const categoryName = exercise.exercise?.category || exercise.category || 'Esercizio';
                const dateStr = exercise.date || exercise.timestamp;

                const audioInfo = {
                    source: 'Esercizio',
                    category: categoryName,
                    date: new Date(dateStr).toLocaleString(),
                    duration: exercise.duration || 'N/A',
                    location: exercise.location || 'N/A'
                };
                await loadSpectrogramAudio(audioBlob, audioInfo);
            } else {
                alert('❌ Audio non trovato');
            }
        }

        // Handle marker selection
        async function onSpectrogramMarkerSelected(markerId) {
            if (!markerId) return;

            const id = parseInt(markerId);
            console.log(`🎵 Loading marker audio #${id}`);

            // Stop current playback
            stopSpectrogramAudio();

            // Find marker in soundscapeData
            const marker = soundscapeData.find(m => m.id === id);

            if (!marker) {
                alert('❌ Marker non trovato');
                return;
            }

            // Get audio from IndexedDB
            const audioBlob = await getAudioFromIndexedDB(id);

            if (audioBlob) {
                const categoryName = document.querySelector(`#markerCategory option[value="${marker.category}"]`)?.textContent || marker.category || 'Marker';
                const audioInfo = {
                    source: 'Marker',
                    category: categoryName,
                    date: new Date(marker.timestamp).toLocaleString(),
                    notes: marker.notes || 'N/A',
                    location: `${marker.lat.toFixed(6)}, ${marker.lng.toFixed(6)}`
                };
                await loadSpectrogramAudio(audioBlob, audioInfo);
            } else {
                alert('❌ Audio non trovato');
            }
        }

        // Handle device file selection
        async function onSpectrogramDeviceFileSelected(input) {
            const file = input.files[0];
            if (!file) return;

            console.log(`📁 Loading file: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);

            // Stop current playback
            stopSpectrogramAudio();

            // Check file type
            if (!file.type.startsWith('audio/')) {
                alert('❌ File non valido. Seleziona un file audio.');
                input.value = '';
                return;
            }

            // Create blob from file
            const audioBlob = new Blob([await file.arrayBuffer()], { type: file.type });

            const audioInfo = {
                source: 'Device File',
                filename: file.name,
                size: `${(file.size / 1024 / 1024).toFixed(2)} MB`,
                type: file.type,
                date: new Date().toLocaleString()
            };

            await loadSpectrogramAudio(audioBlob, audioInfo);
        }

        // Compatibility function for old code
        async function loadSpectrogramAudioList() {
            // Default to exercises view
            showSpectrogramSource('exercises');
        }

        // Load audio blob and prepare for playback
        async function loadSpectrogramAudio(audioBlob, audioInfo) {
            try {
                console.log('🔄 Loading audio blob...');

                // Create or resume AudioContext
                if (!spectrogramPlaybackAudioContext) {
                    spectrogramPlaybackAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                } else if (spectrogramPlaybackAudioContext.state === 'suspended') {
                    await spectrogramPlaybackAudioContext.resume();
                }

                // Create analyser
                spectrogramPlaybackAnalyser = spectrogramPlaybackAudioContext.createAnalyser();
                spectrogramPlaybackAnalyser.fftSize = 2048;
                spectrogramPlaybackAnalyser.smoothingTimeConstant = 0.8;
                spectrogramPlaybackDataArray = new Uint8Array(spectrogramPlaybackAnalyser.frequencyBinCount);

                // Convert blob to array buffer
                const arrayBuffer = await audioBlob.arrayBuffer();

                // Decode audio data
                spectrogramAudioBuffer = await spectrogramPlaybackAudioContext.decodeAudioData(arrayBuffer);

                console.log(`✅ Audio loaded: ${spectrogramAudioBuffer.duration.toFixed(2)}s`);

                // Update UI
                document.getElementById('spectrogramDuration').textContent = formatTime(spectrogramAudioBuffer.duration);
                document.getElementById('spectrogramCurrentTime').textContent = '00:00';
                document.getElementById('spectrogramProgressBar').style.width = '0%';

                // Enable play button
                document.getElementById('spectrogramPlayBtn').disabled = false;
                document.getElementById('spectrogramPauseBtn').disabled = true;
                document.getElementById('spectrogramStopBtn').disabled = true;

                // Show audio info
                displaySpectrogramAudioInfo(audioInfo);

                // Update status
                document.getElementById('spectrogramPlaybackStatus').textContent = 'Pronto';
                document.getElementById('spectrogramPlaybackStatus').style.color = '#00d4ff';

            } catch (error) {
                console.error('❌ Error loading audio:', error);
                alert('Errore nel caricamento dell\'audio');
            }
        }

        // Display audio information
        function displaySpectrogramAudioInfo(info) {
            const infoContainer = document.getElementById('spectrogramAudioInfo');
            const infoContent = document.getElementById('spectrogramAudioInfoContent');

            let html = '';
            for (const [key, value] of Object.entries(info)) {
                const label = key.charAt(0).toUpperCase() + key.slice(1);
                html += `<strong>${label}:</strong> ${value}<br>`;
            }

            infoContent.innerHTML = html;
            infoContainer.style.display = 'block';
        }

        // Play audio with spectrogram
        async function playSpectrogramAudio() {
            if (!spectrogramAudioBuffer) {
                alert('Seleziona prima un audio da riprodurre');
                return;
            }

            try {
                // Resume AudioContext if suspended
                if (spectrogramPlaybackAudioContext.state === 'suspended') {
                    await spectrogramPlaybackAudioContext.resume();
                }

                // If paused, resume from pause time
                if (spectrogramIsPaused) {
                    spectrogramIsPaused = false;
                    spectrogramStartTime = spectrogramPlaybackAudioContext.currentTime - spectrogramPauseTime;
                } else {
                    // Create new source
                    spectrogramPlaybackSource = spectrogramPlaybackAudioContext.createBufferSource();
                    spectrogramPlaybackSource.buffer = spectrogramAudioBuffer;

                    // Create gain node for volume control
                    if (!spectrogramPlaybackGainNode) {
                        spectrogramPlaybackGainNode = spectrogramPlaybackAudioContext.createGain();
                    }
                    const volume = parseInt(document.getElementById('spectrogramVolume').value) / 100;
                    spectrogramPlaybackGainNode.gain.value = volume;

                    // Connect: source -> gain -> analyser -> destination
                    spectrogramPlaybackSource.connect(spectrogramPlaybackGainNode);
                    spectrogramPlaybackGainNode.connect(spectrogramPlaybackAnalyser);
                    spectrogramPlaybackAnalyser.connect(spectrogramPlaybackAudioContext.destination);

                    // Handle end of playback
                    spectrogramPlaybackSource.onended = () => {
                        if (spectrogramIsPlaying) {
                            stopSpectrogramAudio();
                        }
                    };

                    // Start playback
                    spectrogramPlaybackSource.start(0);
                    spectrogramStartTime = spectrogramPlaybackAudioContext.currentTime;
                }

                spectrogramIsPlaying = true;

                // Update UI
                document.getElementById('spectrogramPlayBtn').disabled = true;
                document.getElementById('spectrogramPauseBtn').disabled = false;
                document.getElementById('spectrogramStopBtn').disabled = false;
                document.getElementById('spectrogramPlaybackStatus').textContent = '▶️ In riproduzione';
                document.getElementById('spectrogramPlaybackStatus').style.color = '#00ff00';

                // Start visualization
                startSpectrogramVisualization();
                updateSpectrogramProgress();

                console.log('▶️ Playback started');

            } catch (error) {
                console.error('❌ Error playing audio:', error);
                alert('Errore durante la riproduzione');
            }
        }

        // Pause audio
        function pauseSpectrogramAudio() {
            if (!spectrogramIsPlaying) return;

            spectrogramPauseTime = spectrogramPlaybackAudioContext.currentTime - spectrogramStartTime;
            spectrogramIsPaused = true;
            spectrogramIsPlaying = false;

            // Stop source
            if (spectrogramPlaybackSource) {
                spectrogramPlaybackSource.stop();
                spectrogramPlaybackSource = null;
            }

            // Stop visualization
            if (spectrogramPlaybackAnimationId) {
                cancelAnimationFrame(spectrogramPlaybackAnimationId);
                spectrogramPlaybackAnimationId = null;
            }

            // Update UI
            document.getElementById('spectrogramPlayBtn').disabled = false;
            document.getElementById('spectrogramPauseBtn').disabled = true;
            document.getElementById('spectrogramPlaybackStatus').textContent = '⏸️ In pausa';
            document.getElementById('spectrogramPlaybackStatus').style.color = '#f4a261';

            console.log('⏸️ Playback paused');
        }

        // Stop audio
        function stopSpectrogramAudio() {
            spectrogramIsPlaying = false;
            spectrogramIsPaused = false;
            spectrogramPauseTime = 0;

            // Stop source
            if (spectrogramPlaybackSource) {
                try {
                    spectrogramPlaybackSource.stop();
                } catch (e) {
                    // Already stopped
                }
                spectrogramPlaybackSource = null;
            }

            // Stop visualization
            if (spectrogramPlaybackAnimationId) {
                cancelAnimationFrame(spectrogramPlaybackAnimationId);
                spectrogramPlaybackAnimationId = null;
            }

            // Clear canvas
            if (spectrogramPlaybackCtx && spectrogramPlaybackCanvas) {
                spectrogramPlaybackCtx.fillStyle = '#0a0a15';
                spectrogramPlaybackCtx.fillRect(0, 0, spectrogramPlaybackCanvas.width, spectrogramPlaybackCanvas.height);
                spectrogramPlaybackImageData = null;
            }

            // Reset UI
            document.getElementById('spectrogramCurrentTime').textContent = '00:00';
            document.getElementById('spectrogramProgressBar').style.width = '0%';
            document.getElementById('spectrogramPlayBtn').disabled = false;
            document.getElementById('spectrogramPauseBtn').disabled = true;
            document.getElementById('spectrogramStopBtn').disabled = true;
            document.getElementById('spectrogramPlaybackStatus').textContent = 'Pronto';
            document.getElementById('spectrogramPlaybackStatus').style.color = '#00d4ff';

            console.log('⏹️ Playback stopped');
        }

        // Update volume
        function updateSpectrogramVolume(value) {
            document.getElementById('spectrogramVolumeValue').textContent = value + '%';

            // Update gain node if audio is playing
            if (spectrogramPlaybackGainNode) {
                spectrogramPlaybackGainNode.gain.value = parseInt(value) / 100;
                console.log(`🔊 Volume updated to ${value}%`);
            }
        }

        // Start spectrogram visualization
        function startSpectrogramVisualization() {
            drawSpectrogramPlayback();
        }

        // Draw spectrogram (scrolling visualization)
        function drawSpectrogramPlayback() {
            if (!spectrogramIsPlaying) return;

            spectrogramPlaybackAnimationId = requestAnimationFrame(drawSpectrogramPlayback);

            if (!spectrogramPlaybackAnalyser || !spectrogramPlaybackDataArray || !spectrogramPlaybackCtx) return;

            // Get frequency data
            spectrogramPlaybackAnalyser.getByteFrequencyData(spectrogramPlaybackDataArray);

            const width = spectrogramPlaybackCanvas.width;
            const height = spectrogramPlaybackCanvas.height;

            // Scroll existing image to the left
            if (spectrogramPlaybackImageData) {
                spectrogramPlaybackCtx.putImageData(spectrogramPlaybackImageData, -1, 0);
            } else {
                // First frame: clear canvas
                spectrogramPlaybackCtx.fillStyle = '#0a0a15';
                spectrogramPlaybackCtx.fillRect(0, 0, width, height);
            }

            // Calculate frequency range: 20 Hz to 10 kHz
            const sampleRate = spectrogramPlaybackAudioContext.sampleRate || 48000;
            const nyquist = sampleRate / 2;
            const binCount = spectrogramPlaybackDataArray.length;
            const hzPerBin = nyquist / binCount;

            // Find bin indices for 20 Hz and 10000 Hz
            const startBin = Math.floor(20 / hzPerBin);
            const endBin = Math.floor(10000 / hzPerBin);
            const usefulBins = endBin - startBin;

            // Find peak frequency
            let maxValue = 0;
            let maxBin = 0;
            for (let i = startBin; i < endBin; i++) {
                if (spectrogramPlaybackDataArray[i] > maxValue) {
                    maxValue = spectrogramPlaybackDataArray[i];
                    maxBin = i;
                }
            }
            const peakFrequency = Math.round(maxBin * hzPerBin);
            document.getElementById('spectrogramFrequencyPeak').textContent = `Peak: ${peakFrequency} Hz`;

            // Draw new column on the right edge
            const frequencyBands = height;

            for (let i = 0; i < frequencyBands; i++) {
                // Map from screen Y to frequency bin (inverted: top = high freq)
                const binIndex = Math.max(startBin, Math.min(endBin - 1,
                    startBin + Math.floor((frequencyBands - i - 1) * usefulBins / frequencyBands)));

                const value = spectrogramPlaybackDataArray[binIndex] || 0;
                const normalized = value / 255;

                // Get color based on intensity
                const color = getSpectrumColor(normalized);

                // Draw pixel column
                spectrogramPlaybackCtx.fillStyle = color;
                spectrogramPlaybackCtx.fillRect(width - 1, i, 1, 1);
            }

            // Capture the current frame for next scroll
            spectrogramPlaybackImageData = spectrogramPlaybackCtx.getImageData(0, 0, width, height);
        }

        // Update progress bar and time
        function updateSpectrogramProgress() {
            if (!spectrogramIsPlaying || !spectrogramAudioBuffer) return;

            const currentTime = spectrogramPlaybackAudioContext.currentTime - spectrogramStartTime;
            const duration = spectrogramAudioBuffer.duration;
            const progress = (currentTime / duration) * 100;

            // Update UI
            document.getElementById('spectrogramCurrentTime').textContent = formatTime(currentTime);
            document.getElementById('spectrogramProgressBar').style.width = progress + '%';

            // Continue updating
            if (spectrogramIsPlaying && currentTime < duration) {
                requestAnimationFrame(updateSpectrogramProgress);
            }
        }

        // Format time as MM:SS
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return '00:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Export spectrogram functions to global scope
        window.loadSpectrogramAudioList = loadSpectrogramAudioList;

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            initSpectrogramPlayback();
        });

    </script>

    <!-- Paywall Modal -->
    <div id="paywall-modal" class="paywall-modal">
        <div class="paywall-content">
            <button class="paywall-close" onclick="closeUpgradeModal()">×</button>
            <h2 style="color: #d4af37; margin-bottom: 10px; text-align: center; font-size: 20px;">🌟 Premium</h2>

            <p style="text-align: center; color: #666; margin-bottom: 15px; font-size: 12px;">
                <strong>⚠️ Gratuito: dati SOLO locali</strong><br>
                <strong style="color: #d4af37;">Upgrade per proteggere il tuo lavoro</strong>
            </p>

            <ul class="premium-features" style="margin-bottom: 15px;">
                <li style="margin-bottom: 8px;">💾 Backup Completo</li>
                <li style="margin-bottom: 8px;">♾️ Markers Illimitati</li>
                <li style="margin-bottom: 8px;">📄 Export PDF & GeoJSON</li>
            </ul>

            <div style="text-align: center; margin-top: 15px;">
                <div style="background: linear-gradient(135deg, #fff8e1 0%, #ffe082 20%); padding: 12px; border-radius: 12px; margin-bottom: 12px; border: 2px solid #d4af37;">
                    <div style="font-size: 36px; font-weight: 800; color: #d4af37; margin-bottom: 3px;">€49.99</div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Pagamento unico</div>
                    <div style="font-size: 11px; color: #999;">✓ Nessun abbonamento</div>
                </div>

                <button onclick="upgradeToPremium()" style="padding: 12px 30px; background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 16px; box-shadow: 0 4px 12px rgba(212,175,55,0.3); transition: transform 0.2s; width: 100%; margin-bottom: 10px;">
                    🔒 Acquista Premium
                </button>

                <button onclick="restorePurchases()" style="padding: 10px 20px; background: transparent; color: #666; border: 2px solid #ccc; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 13px; transition: all 0.2s; width: 100%;" onmouseover="this.style.borderColor='#d4af37'; this.style.color='#d4af37'" onmouseout="this.style.borderColor='#ccc'; this.style.color='#666'">
                    🔄 Ripristina Acquisti
                </button>

                <p style="margin-top: 10px; font-size: 10px; color: #999;">
                    Acquisto sicuro tramite App Store
                </p>
            </div>
        </div>
    </div>

    <!-- WhatsApp/Facebook Share Script - Complete solution with emoji support -->
    <script>
    // Soluzione completa: Web Share API + fallback per emoji sia nel messaggio che nell'anteprima
    async function shareApp(platform) {
        const shareMessage = `🎵 SOUNDSCAPE STUDIO - Aggiornamento Importante! 🎵

• 📊 Export professionali (Excel, Word, PDF)
• 🗺️ Export GIS (KML, GeoJSON, CSV)
• 💾 Backup completo illimitato
• 🎵 Export archivio audio ZIP
• ⭐ Markers illimitati

🔗 Accedi ora:
🇮🇹 https://soundscape-project-studio.netlify.app
🇬🇧 https://soundscape-studio-eng.netlify.app

💡 Usa dal browser, App iOS/Android in arrivo!
🙏 Aiutami a migliorare: testa l'app!`;

        const shareUrl = 'https://soundscape-project-studio.netlify.app';
        const shareTitle = '🎧 Soundscape Studio';

        // SOLUZIONE 1: Web Share API (nativa per PWA/Mobile) - emoji perfetti sia nel testo che nell'anteprima
        if (navigator.share) {
            try {
                await navigator.share({
                    title: shareTitle,
                    text: shareMessage, // Testo CON emoji mostrato sopra il box
                    url: shareUrl // URL per generare l'anteprima dai meta tag og:
                });
                console.log('✅ Condivisione riuscita tramite Web Share API');
                return;
            } catch (err) {
                if (err.name === 'AbortError') {
                    console.log('ℹ️ Condivisione annullata dall\'utente');
                    return;
                } else {
                    console.error('❌ Errore Web Share API:', err);
                    // Continua con fallback
                }
            }
        }

        // SOLUZIONE 2: Fallback wa.me con encodeURIComponent (per desktop)
        const encodedMessage = encodeURIComponent(shareMessage);
        let fallbackUrl = '';

        if (platform === 'whatsapp') {
            fallbackUrl = `https://wa.me/?text=${encodedMessage}`;
        } else if (platform === 'facebook') {
            const encodedUrl = encodeURIComponent(shareUrl);
            fallbackUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodedUrl}&quote=${encodedMessage}`;
        }

        if (fallbackUrl) {
            window.open(fallbackUrl, '_blank', 'noopener,noreferrer');
        }
    }

    // Esponi la funzione globalmente per onclick
    window.shareApp = shareApp;
    </script>

</body>
</html>
